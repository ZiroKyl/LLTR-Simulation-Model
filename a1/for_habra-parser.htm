<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<title>Часть 1</title>

	<link rel="stylesheet" href="../css/main.css">
	<link rel="stylesheet" href="../css/habrahabr.css">

	<script src="../js/habrahabr.js" defer></script>
	<script src="js/main.js" defer></script>
	<script src="../js/hljs.js" defer></script>

	<style>img[src$="Git-Icon_2x.png"] { vertical-align: top; }</style>

	<meta name="robots" content="noindex">
	<meta name="googlebot" content="noimageindex">
</head>
<body>
<h1>LLTR Часть 1: Первые шаги в OMNeT++ и INET</h1>
<!-----------------------------[You have a Message]--------------------------------!<
  Напоминание: перед редактированием включить (если выключен) режим
               "Отключить автоматические переносы строк и создание ссылок".

  На всякий случай продолжу оставлять такую шапку во всех частях,
  по аналогии с [Частью 0](https://habr.com/p/414799).

  В этой части, также как и в "Части 0":
  - используется атрибут "cite" в <blockquote>;
  - в ссылках оставлены прежние домены (habrahabr.ru и geektimes.ru)
    для web.archive.org ;
  - несколько прежних комментариев (HTML-комментарии) в тексте.

  И добавлено:
  - тег <kbd> (когда парсер начнет пропускать его - он уже будет в разметке);
  - несколько новых хаков, рядом с которыми, также как и раньше,
    есть HTML-комментарий.
    (но иногда HTML-комментария нет, как в случае с [target](#js-bookmarklet))
<-- ----------------------------------------------------------------------------- -->
<p>
	<strong><nobr>OMNeT++</nobr></strong> (<strong>O</strong>bjective <strong>M</strong>odular <strong>N</strong>etwork <strong>T</strong>estbed in <nobr>C<strong>++</strong></nobr>) Discrete Event Simulator – это модульная, <a href="https://ru.wikipedia.org/wiki/Компонентно-ориентированное_программирование?stable=1">компонентно‑ориентированная</a> <nobr>C++</nobr> библиотека и фреймворк для <strong>дискретно‑событийного <a href="https://habr.com/post/415707/" title="Ричард Хэмминг: Глава 18. Моделирование">моделирования</a></strong>, используемая прежде всего для создания <strong>симуляторов сетей</strong>. Попросту говоря это “симулятор дискретных событий”, включающий: IDE для создания моделей, и сам симулятор (GUI).
</p><p><br />
	<strong>INET</strong> Framework – <a href="https://inet.omnetpp.org/Introduction.html">“библиотека” сетевых моделей</a> для <nobr>OMNeT++</nobr>.
</p>
<br /><anchor>LLTR_a1_habr-pic</anchor><img alt="КДПВ: LLTR Часть 1 – OMNeT++ 5 the Open Simulator :: LLTR Model :: for freedom use" title="Раньше здесь была 'мерцающая' GIF: https://habrastorage.org/webt/o5/dp/in/o5dpinus8lymcgvoehndedgvueu.gif#splash-preview.gif

Почему она мерцает (так сложилось исторически - legacy):
- www.imagemagick.org/discourse-server/viewtopic.php?t=22855#p95627
- bugzilla.mozilla.org/show_bug.cgi?id=890743#c42
- superuser.com/questions/569924/why-is-the-gif-i-created-so-slow
- nullsleep.tumblr.com/post/16524517190/animated-gif-minimum-frame-delay-browser

Легкая попытка убрать мерцание:
 https://habrastorage.org/getpro/habr/conversation/3dc/898/604/3dc898604a67a4f14aa77307d75c3898.svg
 (не подключить как <img>)
Чуть тяжелый, но сжатый SVGZ-zopfli:
 https://habrastorage.org/getpro/habr/post_images/a8a/73a/2db/a8a73a2dbdbff50fec9b190e0b0b0d0f.svg
 (https://bugs.chromium.org/p/chromium/issues/detail?id=106283#c5 но Opera Presto его откроет :-)" align="center" height="330" src="https://habrastorage.org/getpro/habr/post_images/c8f/f17/9be/c8ff179be21a7aa1f133a6f4ee0c759e.svg"/>
<p><br />
	<a href="https://habrastorage.org/getpro/habr/post_images/a8b/399/99a/a8b39999a18513692acc46bd4ee80209.gif#splash.gif">Полная версия GIF (15.7 MiB)</a><!-- alt-src: "https://lh3.googleusercontent.com/eygPWMp_vdTCPQg_AGS7aeMrTHz0urNyG_hOa585IXBvJG-S7qDnv1Mn4Ji4ApmEkGExwLUIAm1TfgVJoBBPO1mg83UfJhQTW38wrF-9mdMSUi7eTOLElnvZxH5axPK6kpXVMVD3Uw=w500-h330-no", "https://github.com/ZiroKyl/LLTR-Simulation-Model/releases/download/a1_v0.1.0/splash.gif" -->
</p><p><br />
	В предыдущих частях…
</p><p><br />
	0. <a href="https://habr.com/post/414799/">Автоматическое определение топологии сети и неуправляемые коммутаторы. Миссия невыполнима?</a> (+ <a href="https://habr.com/post/414799/#user-css" title="Набор стилей, упрощающих чтение больших статей"><em>classic Habrahabr <strong>UserCSS</strong></em></a>)
</p><p><br />
	В этой части:
</p>
<br /><ul>
	<li>создадим “свой первый” протокол (на примере LLTR Basic);</li>
	<li>выберем подходящий симулятор сити для отладки протокола (и создания его модели);</li>
	<li>познаем тонкости настройки окружения для симулятора и его IDE (конфигурирование, компиляция, линковка, тюнинг, патчинг, игнорирование устаревшей документации; и другие англицизмы в большом количестве);</li>
	<li>столкнемся со всем, с чем можно столкнуться, при создании своей первой модели своего первого протокола в <s>не своем</s> незнакомом симуляторе сети;</li>
	<li>пройдем весь путь вместе:
		<ul>
			<li>от счастья, принесенного успешной (наконец!) компиляции первого проекта с пустой сетью,</li>
			<li>до полного погружения в эксперименты с функционирующей моделью протокола;</li>
		</ul>
	</li>
	<li><strong>tutorial</strong>, все описано в виде <strong>tutorial</strong> – мы будем учиться на ошибках – будем совершать их, и будем понимать их (природу), дабы элегантно/эффективно с ними справится;</li>
	<li>репозиторий (git <img alt="" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/>), в коммитах и тегах которого сохранены все шаги (<nobr>“Add …”</nobr>, <nobr>“Fix …”</nobr>, <nobr>“Fix …”</nobr>, <nobr>“Modify …”</nobr>, <nobr>“Correct …”</nobr>, …), от начала и до конца. </li>
</ul>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> <a href="https://habr.com/post/414799/#comment_18833769">дополнительная информация</a> для читателей хаба “Mesh-сети”.
</p><p><br />
	{ объем изображений: 2.2+(2.1) MiB; текста: 484 KiB; смайликов: 22 шт. }
</p>
<cut text="Читать дальше —{объем изображений: 2.2+(2.1) MiB; текста: 484 KiB; смайликов: 22 шт.}→"/>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> [про используемую структуру разделов] структура разделов tutorial/how‑to обычно отличается от структуры разделов в справочнике: в справочнике – структура разделов позволяет за минимальное количество шагов дойти до искомой информации (сбалансированное дерево); в tutorial/how‑to, где разделы сильно связаны логически, а отдельный раздел, по сути, является одним из шагов в последовательности шагов, структура представляет собой иерархию закладок (якорей), которая позволяет в любом месте tutorial/how‑to напомнить (сослаться) о фрагменте описанном ранее.
</p>
<br /><spoiler title="off‑topic: про html5 тег <section> и теги заголовков <h#>"><hr />
	<p>
		Как хорошо, что в HTML5 появился тег <code>&lt;section&gt;</code>, с его помощью стало возможным напрямую задавать уровень вложенности раздела (при помощи манипуляции вложенностью тегов <code>&lt;section&gt;</code> друг в друга). Структуру текста теперь можно было явно отразить во вложенности (иерархии) тегов.
	</p><p><br />
		Это повлияло и на теги заголовков <code>&lt;h#&gt;</code>, т.к. теперь вложенность разделов определяется вложенностью тега <code>&lt;section&gt;</code>, то для указания названия раздела – достаточно было использовать всего лишь один тег <code>&lt;h1&gt;</code> в виде: “<code>&lt;section&gt;&lt;h1&gt;название раздела&lt;/h1&gt;текст раздела&lt;/section&gt;</code>”.
	</p><p><br />
		Я этим пользовался уже давно (с самого появления <code>&lt;section&gt;</code>), но создавая эту статью, увидел еще одно достоинство использования <code>&lt;section&gt;</code>.
	</p><p><br />
		Хорошее название раздела должно точно отражать его суть, однако бывают случаи, когда нужно придержать (не раскрывать) суть до середины раздела. То есть, такой раздел должен вначале притворится “рутинным”, а в середине создать “wow/wtf‑эффект”. Логически это все – один раздел, но если раскрыть его название в самом начале раздела, то само название будет являться <a href="https://ru.wikipedia.org/wiki/Спойлер_(художественные_произведения)?stable=1">спойлером</a>. Представьте книгу (детектив), на обложке которой будет <a href="https://ru.wiktionary.org/wiki/спойлер#Значение">вся информация</a> о “убийце”.
	</p><p><br />
		Здесь “на сцену выходит” тег <code>&lt;section&gt;</code>. Он позволяет определить название раздела в любом месте внутри себя, т.е. не обязательно в самом начале. Пример: “<code>&lt;section&gt;текст раздела&lt;h1&gt;название раздела&lt;/h1&gt;продолжение текста раздела&lt;/section&gt;</code>”. Получается, мы можем одновременно сохранить логическую структуру текста, и показать название раздела в нужный момент. Можно даже сделать так, чтобы название раздела визуально появлялось в его начале, после того как читатель дойдет до определенного момента (до тега <code>&lt;h1&gt;</code> в html).
	</p><p><br />
		Вот только более чем за 9 лет существования <code>&lt;section&gt;</code>, браузеры так и <a href="http://html5doctor.com/computer-says-no-to-html5-document-outline/">не научились правильно строить “HTML5 document outline”</a> для <a href="https://www.w3.org/TR/WCAG20-TECHS/H42.html#H42-description">обеспечения доступности</a>.
	</p><p><br />
		Почему не научились? В документе со сложной структурой <em>трудно<a href="#html5-section-h_footnote-difficult">*</a></em> определить, начиная с какого тега (section, article, …) следует начать нумерацию заголовков (h1, h2, h3, …). А теперь представьте, что сам документ размещен на странице подобной этой (с множеством дополнительных блоков, не имеющих отношение к самому документу, но имеющих заголовки), причем везде для заголовков используется h1. А если на одной странице не один документ, а несколько? Тем не менее, визуально все выглядит хорошо (<a href="http://zirokyl.github.io/DFD2015-TeHI/TeHI-PoC/">пример документа</a>).
	</p><p><br />
		<anchor>html5-section-h_footnote-difficult</anchor>* – на самом деле это не трудно, в <a href="https://www.w3.org/TR/html5/sections.html#outline">стандарте</a> все <a href="https://www.w3.org/TR/html5/sections.html#sectioning-roots">описано</a>, но в реальности это не работает (объяснение см. ниже).
	</p><p><br />
		Почему визуально все выглядит хорошо? Здесь, благодаря <a href="https://github.com/ZiroKyl/DFD2015-TeHI/blob/695d699dfe3f4fce11945d6047b9c417ca670ad2/TeHI-PoC/css/main.css#L51-L55">стилям</a>, появилась дополнительная информация – соответствие между иерархией section и уровнями заголовков (h#). Так может при построении “HTML5 document outline” следует воспользоваться информацией из CSS? Для этого потребуется добавить в CSS дополнительное свойство для элемента заголовка, указывающее его уровень, например:
	</p>
	<br /><source lang="css">body&gt;section&gt;h2                                 { heading-level: 1; font-size: 1.8em;  }
body&gt;section&gt;section&gt;h2                         { heading-level: 2; font-size: 1.4em;  }
body&gt;section&gt;section&gt;section&gt;h2                 { heading-level: 3; font-size: 1.17em; }
body&gt;section&gt;section&gt;section&gt;section&gt;h2         { heading-level: 4; font-size: 1em;    }
body&gt;section&gt;section&gt;section&gt;section&gt;section&gt;h2 { heading-level: 5; font-size: 0.83em; }</source>
	<p><br />
		Либо более строгий вариант – в одной секции допускается использовать только один заголовок. В этом случае уровень заголовка задает сама секция:
	</p>
	<br /><source lang="css">body&gt;section                                 { heading-level: 1; }
body&gt;section&gt;section                         { heading-level: 2; }
body&gt;section&gt;section&gt;section                 { heading-level: 3; }
body&gt;section&gt;section&gt;section&gt;section         { heading-level: 4; }
body&gt;section&gt;section&gt;section&gt;section&gt;section { heading-level: 5; }</source>
	<p><br />
		, и неважно, какой в итоге будет использоваться тег заголовка: h1 или h5.
	</p><p><br />
		Однако, если раньше для создания “<a href="https://www.w3.org/TR/html5/sections.html#outline">heading-level outline</a>” достаточно было иметь только разметку (HTML), то теперь нужны еще и стили (CSS). Может можно ограничиться только разметкой (HTML)? Этим вопросом мы вплотную подошли к проблеме алгоритма построения “heading-level outline”, описанного в стандарте. Так вот, проблема не в самом алгоритме, а в том, что в качестве “<a href="https://www.w3.org/TR/html5/sections.html#sectioning-roots">sectioning root</a>” элемента может выступать только ограниченный (фиксированный) набор тегов. Но у людей часто возникают “нестандартные желания”: “я хочу, чтобы на моей странице со списком статей тег article являлся ‘sectioning root’ элементом”, “а я хочу, чтобы произвольная секция стала ‘sectioning root’ элементом”. Раньше им достаточно было для этого использовать несколько тегов h1 на одной странице (и они это делали). Так может сделать так, чтобы любая секция (теги: section, article, …) становилась “sectioning root” элементом, если заголовок в ней задан при помощи тега h1?..
	</p>
<hr /></spoiler>

<br /><h2><anchor>pervye-shagi-pered-modelirovaniem--mozgovoy-shturm</anchor><a href="#pervye-shagi-pered-modelirovaniem--mozgovoy-shturm" title="Ссылка на раздел"><font color="gray">#</font></a> Первые шаги: “перед моделированием” / “мозговой штурм”</h2><hr />
<anchor>fig_sticker</anchor><img alt="Листочек" align="center" height="436" src="https://habrastorage.org/webt/hr/vf/my/hrvfmymwbe-veowly2meo8l_fuo.png#sticker.png"/>
<p align="center"><!-- очень не хватает align="center" для подписей к изображениям ( а также <figure> и <figcaption> http://htmlbook.ru/blog/elementy-figure-i-figcaption https://web-standards.ru/articles/figure-figcaption/#comment-683 ); справа - "креативный костыль"; альтернатива: поместить текст в SVG, и вставить его, используя <img alt="текст подписи" align="center" src=".svg"/> --><font color="#FFF"><sup>НЛО</sup><sub>прилетело</sub>и<sup>оставило</sup><sub>этот</sub><sup>пробел</sup><sub>здесь</sub>? </font>
	<em>Обратная сторона <a href="https://habr.com/post/414799/#fig_sticker2">листочка из предыдущей статьи</a></em>.
</p>
<br /><h3><anchor>detalizaciya-protokola</anchor><a href="#detalizaciya-protokola" title="Ссылка на раздел"><font color="gray">#</font></a> Детализация протокола</h3>
<p><br />
	В начале определим, что нам нужно включить в протокол. На примере LLTR Basic.
</p><p><br /><anchor>need-to-sync-all-hosts</anchor>
	Основа <abbr title="Link Layer Topology Reveal">LLTR</abbr> – это итерации сбора статистики на множестве хостов во время сканирования сети. Итераций в LLTR много <nobr>( &gt;1)</nobr>, поэтому первое, что нужно включить в протокол – <em>управление</em> запуском и остановкой каждой итерации. Если учесть, что хостов тоже много <nobr>( &gt;1)</nobr>, то <em>управление</em> будет заключаться в том, чтобы определенным способом сообщать всем хостам время начала итерации и время окончания итерации. То есть синхронизировать все хосты.
</p><p><br /><anchor>need-to-select-unicast-src-dst</anchor>
	В каждой итерации есть свой unicast src хост и unicast dst хост, поэтому следующее, что нужно включить – способ <em>назначения</em> для каждой итерации unicast src и dst. То есть в каждой итерации один из хостов должен “осознавать” себя unicast src хостом, цель которого посылать трафик на unicast dst хост.
</p><p><br /><anchor>need-to-process-data-at-the-end</anchor>
	И последнее. По <em>завершению</em> всех итераций, всю собранную статистику со всех хостов нужно отправить на один хост для обработки. Этот хост проанализирует собранную статистику, и построит топологию сети.
</p><p><br />
	Также, на этом шаге, можно подумать про некоторые детали реализации (ограничения) протокола. Например, мы хотим, чтобы программа, использующая LLTR, смогла работать без root прав, и из пространства пользователя (т.е. без установки в систему специального драйвера), значит, LLTR должен работать, например, поверх TCP и UDP.
</p><p><br />
	Все остальные делали реализации, определятся сами, в процессе создания модели. То есть, конечно, можно сразу же продумать все до мелочей, но при этом есть риск “скатится в локальный оптимум”, и не заметить “более лучший” вариант реализации. Хорошо, когда моделей будет несколько – если для каждого варианта реализации будет своя модель, то появится возможность комбинировать модели, и шаг за шагом приходить к лучшей реализации. <em>Вспоминая генетический алгоритм </em>；）. Например, в одной реализации/модели может быть централизованное управление, в другой – децентрализованное, в третей – комбинация лучших частей из предыдущих двух вариантов.
</p>
<br /><h3><anchor>vybor-simulyatora-seti</anchor><a href="#vybor-simulyatora-seti" title="Ссылка на раздел"><font color="gray">#</font></a> Выбор симулятора сети</h3>
<p><br />
	Теперь настало время определится с симулятором сети, в котором будем создавать модели и ставить эксперименты.
</p><p><br />
	В основном, от симулятора сети нам нужна возможность реализации “своего” протокола. Не все симуляторы позволяют легко это сделать.
</p><p><br />
	А вот присутствие эмуляторов <abbr title="Операционных систем">ОС</abbr> реального сетевого оборудования “мировых брендов”, наоборот – не нужно. Скорее всего, эмуляторы создадут множество ограничений, которые будут только мешать в ходе экспериментов.
</p><p><br />
	С выбором симулятора мне помогла статья <a href="http://www.finmars.co.uk/blog/4-evaluating-network-simulation-tools">Evaluating Network Simulation Tools</a> (наши требования к симулятору во многом совпадали) и <a href="http://www.finmars.co.uk/blog/8-omnet-general-network-simulation"><nobr>OMNeT++</nobr> General 'Network' Simulation</a>.
</p>

<br /><h2><anchor>ustanovka-omnet-i-inet</anchor><a href="#ustanovka-omnet-i-inet" title="Ссылка на раздел"><font color="gray">#</font></a> Установка <nobr>OMNeT++</nobr> и INET</h2><hr />
<p>
	<a href="https://omnetpp.org/omnetpp">Загружаем <nobr>OMNeT++</nobr></a> <a href="https://omnetpp.org/component/jdownloads/download/32-release-older-versions/2307-omnetpp-50-windows">5.0</a>.
</p><p><br />
	И так как <nobr>OMNeT++</nobr> – это всего лишь “симулятор дискретных событий”, то понадобится еще и <a href="https://inet.omnetpp.org/Introduction.html">INET</a> – библиотека сетевых моделей (протоколы и устройства). <a href="https://inet.omnetpp.org/Download.html">Качаем INET</a> <a href="https://github.com/inet-framework/inet/releases/tag/v3.4.0">3.4.0</a>. На самом деле его можно было <a href="https://inet.omnetpp.org/Installation.html">установить из IDE</a>, но я рекомендую поставить вручную (позже будет ясно почему).
</p><p><br />
	Установка в *nix и в Windows мало чем отличается. Продолжу на примере Windows.
</p><p><br />
	Распаковываем <nobr>OMNeT++</nobr> в %ProgramData% (C:\ProgramData\), и открываем файл INSTALL.txt (C:\ProgramData\omnetpp-5.0\INSTALL.txt). В нем сказано, что подробная инструкция находится в “doc/InstallGuide.pdf”, дальше написано, что если не хотите ее читать, то просто выполните:
</p>
<blockquote>
	$ . setenv<br />
	$ ./configure<br />
	$ make
</blockquote>
<p>
	Но не спешите это делать!
</p><p><br />
	Во‑первых, обратите внимание на первую команду “<code>. setenv</code>”. В директории “omnetpp-5.0” нет файла “<code>setenv</code>” (в версии 5.0b1 он был). Он и не нужен (для Windows), поэтому просто запускаем “mingwenv.bat” (советую перед запуском посмотреть, что он делает… <a href="https://habrahabr.ru/post/204580">во избежание</a> <a href="http://www.opennet.ru/opennews/art.shtml?num=41897">внезапного <code>rm</code></a> ). По окончании отколется терминал (mintty).
</p><p><br />
	Во‑вторых, советую немного подправить файл “configure.user” (если упомянутый параметр закомментирован в файле, то его нужно раскомментировать):
</p>
<br /><ul>
	<li>Если хотите использовать Clang (по умолчанию), то оставьте<br />
		<code>PREFER_CLANG=yes</code><br />
		и настройте:
		<ul>
			<li>CFLAGS_RELEASE (опции компилятора):<br />
				<code>CFLAGS_RELEASE='-O2 -march=native -DNDEBUG=1'</code></li>
		</ul>
	</li>
	<li>Если хотите использовать GCC вместо Clang (а вы, скорее всего, захотите использовать именно GCC, увидев, что написано в 398 строчке файла “configure.in”), то установите<br />
		<code>PREFER_CLANG=no</code><br />
		и настройте:
		<ul>
			<li>CFLAGS_RELEASE (опции компилятора). Можно выбрать или<br />
				<code>CFLAGS_RELEASE='-O2 -mfpmath=sse,387 -ffast-math -fpredictive-commoning -ftree-vectorize -march=native -freorder-blocks-and-partition -pipe -DNDEBUG=1'</code><br />
				или<br />
				<code>CFLAGS_RELEASE='-O2 -fpredictive-commoning -march=native -freorder-blocks-and-partition -pipe -DNDEBUG=1'</code><br />
				или<br />
				<code>CFLAGS_RELEASE='-O2 -march=native -freorder-blocks-and-partition -pipe -DNDEBUG=1'</code><br />
				(расположено в порядке уменьшения вероятности возникновения глюков).</li>
			<li>Также стоит добавить CXXFLAGS в виде '<code>-std=c++11 </code>'+CFLAGS_RELEASE. Например:<br />
				<code>CXXFLAGS='-std=c++11 -O2 -fpredictive-commoning -march=native -freorder-blocks-and-partition -pipe -DNDEBUG=1'</code></li>
			<li>JAVA_CFLAGS (просто раскомментируем):<br />
				<code>JAVA_CFLAGS=-fno-strict-aliasing</code></li>
		</ul>
	</li>
	<li><code>PREFER_QTENV=yes</code></li>
	<li>Отключаем 3D визуализацию:<br />
		<code>WITH_OSG=no</code><br />
		Она конечно <a href="https://omnetpp.org/21-articles/3737-3ddemo">красивая</a>, но нам не понадобится.</li>
	<li>Параллельное (на множестве CPU) выполнение симуляции (WITH_PARSIM), к сожалению, тоже стоит отключить, однако без него компоновка (linker) завершается неудачей, поэтому оставим включенным:<br />
		<code>WITH_PARSIM=yes</code></li>
</ul>
<br /><spoiler title="Почему его стоит отключить?"><hr />
	<p>
		Если его явно не использовать, то он не нужен (в теории). Подробнее в разделе 16.1, 16.3, и 16.3.2 “Parallel Simulation Example” в “doc/InstallGuide.pdf”, или <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:parallel-exec:parallel-simulation-example">тут</a>.
	</p>
<hr /></spoiler>
<p><br />
	Теперь в терминале (mintty) можно выполнить:
</p>
<br /><source lang="bash">./configure &amp;&amp; make clean MODE=release
make MODE=release –j17</source>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> “<code>17</code>” следует заменить на количество ядер <nobr>CPU + 1</nobr>, либо на 1.5×ядер.
</p>
<br /><spoiler title="Предостережение для любознательных (сборка 64bit)"><hr />
	<p>
		В директории “tools/win32” находится <a href="http://www.linux.org.ru/forum/desktop/10819573">MSYS2</a> его пакеты компиляторов можно обновлять:
	</p>
	<br /><ul>
		<li>MSYS2 installer<br /><a href="http://msys2.github.io">msys2.github.io</a></li>
		<li>Updating packages &amp; General Package Management<br /><a href="https://web.archive.org/web/20161011161459/https://sourceforge.net/p/msys2/wiki/MSYS2%20installation">sourceforge.net/p/msys2/wiki/MSYS2 installation</a></li>
		<li>Re-installing<br /><a href="https://web.archive.org/web/20151108111604/https://sourceforge.net/p/msys2/wiki/MSYS2%20re-installation/">sourceforge.net/p/msys2/wiki/MSYS2 re-installation</a></li>
		<li>Building Packages<br /><a href="https://web.archive.org/web/20151128115031/http://sourceforge.net:80/p/msys2/wiki/Contributing%20to%20MSYS2/">sourceforge.net/p/msys2/wiki/Contributing to MSYS2</a></li>
		<li>Downgrading packages<br /><a href="https://wiki.archlinux.org/index.php/Downgrading_packages">wiki.archlinux.org/index.php/Downgrading_packages</a><br />&amp;<br />packages repo<br /><a href="https://sourceforge.net/projects/msys2/files/REPOS/MSYS2/x86_64/">sourceforge.net/projects/msys2/files/REPOS/MSYS2/x86_64/</a></li>
	</ul>
	<p><br />
		А <nobr>OMNeT++</nobr> можно <a href="http://stackoverflow.com/questions/16888270/omnet-4-3-build-issue-on-mac-os-x-lion">собрать под 64bit</a>.
	</p><p><br />
		<strong>Но</strong> <nobr>OMNeT++</nobr> может просто не собраться более новой версией GCC (так было с первой бэткой пятой версии <nobr>OMNeT++</nobr> – без правки исходников она нормально собиралась только с GCC 4.x). А для перехода на 64bit потребуется еще больше усилий. Для начала потребуется пересмотреть опции компиляции (<a href="https://github.com/michaelkirsche/6lowpan4omnet-diy/blob/master/1_contiki_platform_omnet/contiki-2.6/platform/omnetpp/Makefile.omnetpp#L36">fPIC</a>, <a href="http://www.cyberforum.ru/cpp-beginners/thread1506530.html">не нужен?</a>). Затем, если пролистаете исходники <nobr>OMNeT++</nobr>, то увидите, что там часто используется тип <strong>long</strong> вместо int32_t, <a href="http://www.viva64.com/ru/t/0030/">size_t и ptrdiff_t (а также uintptr_t и intptr_t)</a>. Чем это грозит? В *nix в 64bit (LP64) сборке размер long будет 64bit, а в Windows (LLP64) – 32bit (см. <a href="http://www.viva64.com/ru/a/0050/#ID0EOB">модели данных</a>). Придется заменять long на size_t и ptrdiff_t, но и здесь вас будут поджидать “подводные камни”. Например, можно открыть “src/utils/opp_lcg32_seedtool.cc”, и взглянуть на строку 231 – <code>index</code> либо можно оставить 32bit (заменить на int32_t), либо сделать 64bit и модифицировать все битовые_маски+описания+(возможно)немного_логики. Поэтому часть long переменных нужно будет оставить 32bit, а другую часть сделать 64bit. В общем, для корректной работы, нужно проделать все пункты из:
	</p>
	<br /><ul>
		<li><a href="http://www.viva64.com/ru/a/0042/">7 шагов по переносу программы на 64-битную систему</a> (viva64)</li>
		<li><a href="https://habrahabr.ru/company/pvs-studio/blog/97751/">Коллекция примеров 64-битных ошибок в реальных программах</a> (habr:pvs-studio)</li>
		<li><a href="http://www.viva64.com/ru/a/0004/">20 ловушек переноса Си++ – кода на 64-битную платформу</a> (viva64)</li>
	</ul>
	<p><br />
		Причем то же самое надо проделать и с многочисленными библиотеками для <nobr>OMNeT++</nobr>, например, с INET.
	</p><p><br />
		В общем, <strong>предостерегаю от попыток сделать 64bit сборку <nobr>OMNeT++</nobr>.</strong>
	</p><p><br />
		Под *nix я также рекомендую использовать 32bit сборку (по крайне мере с версией 5.0 и меньше).
	</p><p><br />
		Возможно, когда‑нибудь @Andrey2008 возьмется проверить код <nobr>OMNeT++</nobr> и INET… А пока предлагаю просто найти и просмотреть все “<code>FIXME</code>”/“<code>Fix</code>” в коде ；）.
	</p><p><br />
		P.S. упоминания о том, что код <nobr>OMNeT++</nobr> проверяли статическим анализатором кода – отсутствуют, а вот в файлах “ChangeLog” INET 3.4.0 можно найти 70 упоминаний про устранение дефектов после сканирования в Coverity.
	</p>
<hr /></spoiler>
<p><br />
	<nobr>OMNeT++</nobr> использует Eclipse в качестве IDE. Для удобства можно создать ярлык на IDE “%ProgramData%\omnetpp-5.0\ide\omnetpp.exe”, и расположить его в легкодоступном месте. В директории “ide/jre/” находится JRE v1.8.0_66-b18. Если в системе уже установлен совместимый JRE/JDK, то директорию “ide/jre/” можно спокойно удалить, заменив <a href="https://ru.wikipedia.org/wiki/Символьная_ссылка?stable=1">символьной ссылкой</a> на местоположение системного JRE.
</p><p><br />
	При первом запуске Eclipse предлагает поместить workspace в директорию “samples”, однако лучше расположить ее в любой другой удобной вам директории вне “%ProgramData%”. Главное, чтобы в пути к новой директории использовались только латинские буквы (+ символы), и не было пробелов.
</p><p><br />
	После закрытия Welcome, IDE предложит установить INET (как было написано выше), и импортировать примеры – откажитесь от обоих пунктов.
</p>
<br /><spoiler title="Настройки Eclipse, опции JVM, дополнительные плагины и темы"><hr />
	<p>
		<strong>Опции JVM</strong>. Добавить в файл “ide/omnetpp.ini” (для правки подойдет любой редактор, понимающий LF перевод строки; notepad не подойдет), сохранив пустую последнюю строку:
	</p>
	<br /><source lang="ini">-XX:+UseParNewGC
-XX:+UseConcMarkSweepGC
-XX:+AggressiveOpts
-XX:+TieredCompilation
-XX:CompileThreshold=100</source>
	<br /><anchor>fig_Eclipse_tuning</anchor><a href="https://habrastorage.org/webt/pr/an/ha/pranhatat29l-sdulpllkv2hfuq.png#Eclipse_tuning.png"><img alt="Eclipse tuning (un[7z]me)" align="center" height="491" src="https://habrastorage.org/webt/pr/an/ha/pranhatat29l-sdulpllkv2hfuq.png#Eclipse_tuning.png"/></a>
	<p><br />
		Чтобы сделать Eclipse, таким как на картинке – загляни внутрь картинки.
	</p>
<hr /></spoiler>
<p><br />
	Настало время установить INET. Директорию “inet” из скаченного ранее архива (inet-3.4.0-src.tgz) нужно перенести в workspace. В директории есть файл “INSTALL” с пошаговым описанием установки. Можно воспользоваться им (раздел “If you are using the IDE”), но только не собирайте (Build) проект!
</p><p><br />
	Импортируем INET:
</p>
<br /><ol>
	<li>В Eclipse открыть: <nobr>File &gt;</nobr> Import.</li>
	<li>Выбрать: General / Existing Projects to the Workspace.</li>
	<li>В качестве “root directory” выбрать местоположение workspace.</li>
	<li>Удостоверьтесь, что опция “Copy projects into workspace” выключена.</li>
	<li>После нажатия на кнопку “Finish”, дождитесь окончания индексации проекта (% выполнения см. внизу, в строке статуса – “<nobr>C/C++</nobr> Indexer”).</li>
</ol>
<p><br />
	Настроим проект:
</p>
<br /><ul>
	<li>A. отключим ненужные для LLTR компоненты;</li>
	<li>B. переключим сборку на релиз;</li>
	<li>C. избавимся от глюков “<nobr>OMNeT++</nobr> Make Builder” (opp_makemake) – раньше, при его выборе, часто происходила перегенерирация Makefile, даже когда этого не требовалось;</li>
	<li>D. <a href="http://www.gnu.org/software/make/manual/make.html#Parallel">включим параллельную компиляцию</a>;</li>
	<li>E. включим оптимизации;</li>
	<li>F. включим подсветку синтаксиса для <nobr>c++11</nobr>, в нескольких местах;</li>
	<li>G. подправить баг связанный с “<code>#include</code>” (случается, если несколько раз менять “Current builder”; может случиться и в других случаях).</li>
</ul>
<p><br />
	Перед настройкой <strong>{A}</strong> надо подправить один из файлов проекта. В файле “inet/.oppfeatures” есть строка “<code>inet.examples.visualization</code>” нужно добавить после нее пустую строку, в которой написать “<code>inet.tutorials.visualization</code>”, желательно сохранив отступ слева (по аналогии с другими параметрами “<code>nedPackages</code>” в файле). Если это не сделать, то ничего страшного не случится, просто после настройки в “Problems” (<kbd>Alt+Shift+Q</kbd>,<kbd>X</kbd>) будут всегда висеть ошибки, связанные с “<code>inet.tutorials.visualization</code>”. Можно вначале сделать <strong>{A}</strong>, и посмотреть на ошибки, а затем подправить файл “inet/.oppfeatures” – при этом Eclipse предупредит о нарушении целостности в настройках, и предложит профиксить их (соглашаемся на это).
</p><p><br />
	Приступим (панель <nobr>“Project Explorer” &gt;</nobr> <nobr>проект “inet” &gt;</nobr> <nobr>контекстное меню &gt;</nobr> <strong>Properties</strong>):
</p>
<br /><ol>
	<li>Раздел <nobr>“OMNeT++” &gt;</nobr> подраздел “Project Features”
		<ol type="a">
			<li><strong>{A}</strong> убираем все, кроме:
				<ul>
					<li>TCP Common</li>
					<li>TCP (INET)</li>
					<li>IPv4 protocol</li>
					<li>UDP protocol</li>
					<li>Ethernet</li>
				</ul>
			</li>
			<li>кнопка “Apply”.</li>
		</ol>
	</li>
	<li>Раздел “С/С++ Build”:
		<ol type="a">
			<li>кнопка <nobr>“Manage Configurations…” &gt;</nobr> сделать активным “gcc-release” <strong>{B}</strong>;</li>
			<li>выбрать конфигурацию “gcc-release [ Active ]” <strong>{B}</strong>.</li>
			<li>Подраздел “Tool Chain Editor”:
				<ol type="I">
					<li>в качестве “Current builder” выбрать “GNU Make Builder” для обеих конфигураций: “gcc-debug” и “gcc-release” <strong>{C}</strong>, <strong>внимание</strong>: если в будущем изменить “Current builder”, то все придется перенастраивать заново!</li>
					<li>кнопка “Apply”.</li>
				</ol>
			</li>
			<li>Вкладка “Behavior” (вернутся в корень раздела “С/С++ Build”):
				<ol type="I">
					<li><anchor>use-parallel-jobs</anchor>установить “Use parallel jobs” равным N (в качестве N можно выбрать либо число ядер <nobr>CPU + 1</nobr>, либо 1.5×ядер) – это позволит <a href="http://stackoverflow.com/a/414725" title="Compiling with g++ using multiple cores">использовать все ядра CPU для компиляции</a> <strong>{D}</strong> (настраиваем для “gcc-debug” и “gcc-release”).</li>
				</ol>
			</li>
			<li>Вкладка “Build Settings”:
				<ol type="I">
					<li>отключить “Use default build command”;</li>
					<li>строку “Build command” заменить на “<code>make MODE=release CONFIGNAME=${ConfigName} -j17</code>” (“<code>17</code>” заменить на предыдущее значение в строке, т.е. на выбранный N) <strong>{E}</strong>, то же самое можно сделать и для конфигурации “gcc-debug”, заменив в строке “<code>MODE=release</code>” на “<code>MODE=debug</code>”, после этого не забудь переключиться обратно на “gcc-release [ Active ]”.</li>
				</ol>
			</li>
			<li>кнопка “Apply”.</li>
		</ol>
	</li>
	<li>Раздел “С/С++ General”:
		<ol type="a">
			<li>Подраздел “Paths and Symbols”:
				<ol type="I">
					<li>Вкладка “Includes”:
						<ol>
							<li>кнопка Add: добавить директорию “<code>../src</code>” с выбранными “Add to all configurations” и “Add to all languages” <strong>{G}</strong> – изначально “<code>../src</code>” есть в языке “GNU <nobr>C++</nobr>”, но, в неопределенный момент, он может стереться из списка;</li>
							<li>кнопка “Apply”, и проверь, что “<code>../src</code>” появилось во всех языках и конфигурациях.</li>
						</ol>
					</li>
					<li>Вкладка “Symbols”:
						<ol>
							<li>кнопка Add: добавить символ “<code>__cplusplus</code>” со значением “<code>201103L</code>” и выбранными “Add to all configurations” и “Add to all languages” – <strong>{F}</strong> <a href="http://stackoverflow.com/questions/13591020/eclipse-cdt-parser-support-for-c11/24628502#24628502" title="Eclipse CDT parser support for C++11?">подробнее</a>;</li>
							<li>кнопка “Apply”, и проверь, что в конфигурации “gcc-debug” у “<code>__cplusplus</code>” значение “<code>201103L</code>”.</li>
						</ol>
					</li>
					<li>Вкладка “Source Location”:
						<ol>
							<li>Проверь, что в списке один пункт, и он указывает на “<code>/inet/src</code>” <strong>{G}</strong>, если там что‑то другое (например, просто “<code>/inet</code>”), то удаляй то, что есть и добавь (“Add Folder…”) “<code>/inet/src</code>”. Затем кнопка “Apply”, и возвращение к <strong>{A}</strong>, т.к. все фильтры при удалении были стерты. Кстати, “<code>/inet</code>” на самом деле можно оставить – с ним тоже все нормально собирается, но лучше сузить до оригинального “<code>/inet/src</code>”.</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>Подраздел <nobr>“Preprocessor Include Paths, Marcos etc.” &gt;</nobr> вкладка “Providers”:
				<ol type="I">
					<li>Выбрать “CDT GCC Build-in Compiler Settings”:
						<ol>
							<li>В группе “Language Settings Provider Options” нажать на ссылку “Workspace Settings”:
								<ol type="a">
									<li>вкладка “Discovery”: опять выбрать “CDT GCC Build-in Compiler Settings”, и добавить “<code>-std=c++11 </code>” перед “<code>${FLAGS}</code>” в “Command to get compiler specs”, должно получится примерно так `<code>${COMMAND} -std=c++11 ${FLAGS} -E -P -v -dD &quot;${INPUTS}&quot;</code>` <strong>{F}</strong>, подробнее <a href="https://www.eclipse.org/forums/index.php?t=msg&th=490066&goto=1068001&#msg_1068001" title="C++11 standard library indexing fails, __cplusplus recognized with wrong value">здесь</a> и <a href="http://stackoverflow.com/questions/9131763/eclipse-cdt-c11-c0x-support/24561615#24561615" title="How to enable C++11/C++0x support in Eclipse CDT?">здесь</a>;</li>
									<li>кнопка “Apply”, “Ok” (закрываем окно).</li>
								</ol>
							</li>
							<li>переместить “CDT GCC Build-in Compiler Settings” выше “CDT Managed Build System Entries” (для обеих конфигураций: “gcc-release” и “gcc-debug”) <strong>{F}</strong>, <a href="http://www.linux.org.ru/forum/development/9680812#comment-9684038" title="Как заставить eclipse индексировать по стандарту c++11">подробнее</a> – после этого мы потеряем возможность переопределять символы “CDT GCC Build-in Compiler Settings” через “CDT Managed Build System Entries” (<nobr>“С/С++ General” &gt;</nobr> <nobr>“Paths and Symbols” &gt;</nobr> “Symbols”), переопределить можно будет только через добавление значений в “CDT User Settings Entries” во вкладке “Entries” для каждого языка по отдельности (альтернатива: не меняем порядок, т.к. в “CDT Managed Build System Entries” уже исправили значение “<code>__cplusplus</code>”; не меняем порядок, удаляем все упоминания “<code>__cplusplus</code>” из “CDT Managed Build System Entries”, и следим, чтобы он там не появлялся в будущем);</li>
							<li>кнопка “Apply”, и проверить, что во вкладке “Entries” у языка “GNU <nobr>C++</nobr>” в “CDT GCC Build-in Compiler Settings” (чекбокс [в нижней части окна] “Show build-in values” должен быть включен) есть запись “<code>__cplusplus=201103L</code>” (она будет ближе к концу).</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>Подраздел “Indexer”:
				<ol type="I">
					<li>в качестве “Build configuration for indexer” выбрать “gcc-release” <strong>{B}</strong>;</li>
					<li>кнопка “Apply”.</li>
				</ol>
			</li>
		</ol>
	</li>
</ol>
<p><br />
	Некоторые проблемы могут возникнуть с <strong>{E}</strong>. Поясню. Если все нормально, то Eclipse <a href="http://adamcavendish.is-programmer.com/posts/42316.html">должен подхватить</a> те настройки, которые были заданы в “configure.user” перед конфигурированием <nobr>OMNeT++</nobr> (./configure). В таком случае Eclipse передаст нужные параметры в g++ через make. Однако не всегда все идет, как планировалось, и лучше проверить, что происходит в реальности. Проверить можно, дописав в “Build command” <strong>{E}</strong> “<a href="http://www.gnu.org/software/make/manual/make.html#index-printing-of-recipes"><code>--just-print</code></a>” или “<a href="http://www.gnu.org/software/make/manual/make.html#index-_002d_002dtrace"><code>--trace</code></a>”, и, запустив сборку (панель <nobr>“Project Explorer” &gt;</nobr> <nobr>проект “inet” &gt;</nobr> <nobr>контекстное меню &gt;</nobr> <nobr>“Clean Project” и</nobr> “Build Project”), открыть “Console” (<kbd>Alt+Shift+Q</kbd>,<kbd>C</kbd>), в нем должно выводится что‑то похожее на “<code>g++ -c -std=c++11 -O2 -fpredictive-commoning -march=native -freorder-blocks-and-partition -pipe -DNDEBUG=1 …</code>”. Если этого нет, то можно последовать совету из <a href="http://adamcavendish.is-programmer.com/posts/42316.html">уже упомянутой статьи</a>.
</p>
<br /><spoiler title="Либо подправить переменные окружения"><hr />
	<p>
		Опять открываем настройки проекта (панель <nobr>“Project Explorer” &gt;</nobr> <nobr>проект “inet” &gt;</nobr> <nobr>контекстное меню &gt;</nobr> <strong>Properties</strong>):
	</p>
	<br /><ol>
		<li>Раздел “С/С++ Build”:
			<ol type="a">
				<li>Подраздел “Build Variables” (проверь, что текущая конфигурация “gcc-release [ Active ]”):
					<ol type="I">
						<li>кнопка “Add…”, имя “<code>CFLAGS</code>”, тип “String”, значение “<code>-O2 -fpredictive-commoning -march=native -freorder-blocks-and-partition -pipe</code>”;</li>
						<li>кнопка “Add…”, имя “<code>CXXFLAGS</code>”, тип “String”, значение “<code>-std=c++11 -O2 -fpredictive-commoning -march=native -freorder-blocks-and-partition -pipe</code>”;</li>
						<li>кнопка “Apply”.</li>
					</ol>
				</li>
				<li>Подраздел “Environment”:
					<ol type="I">
						<li>кнопка “Add…”, имя “<code>CFLAGS</code>”, значение “<code>${CFLAGS}</code>”;</li>
						<li>кнопка “Add…”, имя “<code>CXXFLAGS</code>”, значение “<code>${CXXFLAGS}</code>”;</li>
						<li>кнопка “Apply”.</li>
					</ol>
				</li>
			</ol>
		</li>
	</ol>
<hr /></spoiler>
<p><br />
	Кстати, при некоторой сноровке, параметры запуска g++ можно было посмотреть, не используя флаги “<a href="http://www.gnu.org/software/make/manual/make.html#index-printing-of-recipes"><code>--just-print</code></a>” и “<a href="http://www.gnu.org/software/make/manual/make.html#index-_002d_002dtrace"><code>--trace</code></a>”, а используя <a href="https://technet.microsoft.com/ru-ru/bb896653.aspx">Process Explorer</a>. В Process Explorer также можно посмотреть, во что раскрывается “<code>-march=native</code>” при передаче в “cc1plus.exe”.
</p><p><br />
	Теперь, наконец, можно собрать INET! Проверьте, что сейчас активна конфигурация “gcc-release” <strong>{B}</strong>, и если добавляли ранее флаги “<a href="http://www.gnu.org/software/make/manual/make.html#index-printing-of-recipes"><code>--just-print</code></a>” или “<a href="http://www.gnu.org/software/make/manual/make.html#index-_002d_002dtrace"><code>--trace</code></a>” для проверки <strong>{E}</strong>, то их нужно убрать. <strong>Собираем</strong> (панель <nobr>“Project Explorer” &gt;</nobr> <nobr>проект “inet” &gt;</nobr> <nobr>контекстное меню &gt;</nobr> <nobr>“Clean Project” и</nobr> “Build Project”), за процессом можно наблюдать в “Console” (<kbd>Alt+Shift+Q</kbd>,<kbd>C</kbd>).
</p><p><br />
	Если все прошло хорошо, то рекомендую закрыть Eclipse, и сделать бекап файла “.cproject” и директории “.settings” с настройками проекта <strong>{B-G}</strong>, а также файлов: “.oppfeatures”, “.oppfeaturestate”, “.nedexclusions” – <strong>{A}</strong>.
</p><p><br />
	Наконец, настройка завершена, и можно перейти к самому интересному.
</p>

<br /><h2><anchor>sozdanie-pervogo-proekta</anchor><a href="#sozdanie-pervogo-proekta" title="Ссылка на раздел"><font color="gray">#</font></a> Создание первого проекта</h2><hr />
<p>
	<font color="#54524F"><b>Note</b>:</font> Первое, что я сделал после настройки окружения – стал изучать содержимое директории “doc” у <nobr>OMNeT++</nobr> и INET. Это были Simulation Manual и User Guide, позже к ним присоединился Stack Overflow (в виде stackoverflow.com, и в виде состояния мозга). Ниже я покажу, как можно сделать первые шаги, не читая всю документацию, и расскажу, с какими “особенностями” можно столкнуться.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> Для тех, кто еще не успел установить себе <nobr>OMNeT++</nobr> и INET, но уже хочет посмотреть на код, текст ниже содержит ссылки на исходники INET в GitHub. Все ссылки ведут на исходники версии 3.4.0 (эти ссылки будут доступны всегда, даже если в будущих версиях расположение файлов в INET изменится).
</p><p><br />
	Перед созданием своего проекта хорошо бы посмотреть на уже готовые модели в INET, посмотреть, как они устроены. Может в нем уже реализовано то, что нам нужно?
</p><p><br />
	После непродолжительного блуждания по дереву INET в “Project Explorer”, можно наткнуться на директорию “inet/src/inet/applications”, и обнаружить в ней “<a href="https://github.com/inet-framework/inet/tree/v3.4.0/src/inet/applications/udpapp">udpapp</a>” (UDP Application). UDP пригодится нам для broadcast рассылки. Внутри директории лежат несколько моделей, и, судя по названию и размеру исходников, самый простой из них, это “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/udpapp/UDPEchoApp.cc">UDPEchoApp</a>”. Там есть еще и “UDPBasicApp”, но он <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/udpapp/UDPBasicApp.cc">оказался</a> не таким уж и “Basic”. Каждая модель состоит из “.cc”, “.h” и “.ned” файлов. Пока не ясно, зачем нужны “.ned” файлы, но судя по их содержанию (наличию <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/udpapp/UDPEchoApp.ned#L31">строчки “<code>parameters:</code>”</a>) в них могут описываться параметры модели.
</p><p><br />
	Продолжим поиски интересных моделей. Посмотрим, какие примеры (<a href="https://github.com/inet-framework/inet/tree/v3.4.0/examples">inet/examples</a>) есть в INET. И нам повезло, в нем есть пример с названием “broadcast” (<a href="https://github.com/inet-framework/inet/tree/v3.4.0/examples/inet/broadcast">inet/examples/inet/broadcast</a>)! Этот пример помимо файлов “.cc”, “.h” и “.ned”, содержит еще “.ini” и “.xml” файлы. Пора разобраться, зачем эти файлы нужны:
</p>
<br /><ul>
	<li><strong>.ned</strong> – <a href="https://omnetpp.org/doc/omnetpp/manual/#cha:ned-lang">файл/язык</a>, описывающий либо модель сети (<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-lang:warmup:network">Network</a>), либо простейшие блоки (<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-lang:warmup:the-simple-modules">Simple modules</a>) “кирпичики”, из которых можно собирать модули (<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:warmup:ned-lang:node-compound-module">Compound module</a>). В целом это выглядит <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:overview:modeling-concepts">так</a> (картинка), т.е. можно собрать модель сети, и провести несколько экспериментов не написав ни одной строчки на <nobr>C++</nobr>.</li>
	<li>omnetpp<strong>.ini</strong> – <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:overview:parameters">файл</a>, в котором можно <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:config-sim:config-file">задать/переопределить</a> параметры модели. Если нужно провести несколько экспериментов с разными параметрами, то всех их можно перечислить (<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:config-sim:named-configurations">Named Configurations</a>) в этом же файле.</li>
	<li><strong>.xml</strong> – <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-lang:xml-parameters">просто файл</a> с <a href="https://github.com/inet-framework/inet/blob/v3.4.0/examples/inet/broadcast/UDPBroadcastNetwork.ned#L39">настройками</a>, которые считывает один из используемых модулей (<a href="https://github.com/inet-framework/inet/blob/v3.4.0/examples/inet/broadcast/UDPBroadcastNetwork.ned#L37">IPv4NetworkConfigurator</a>).</li>
</ul>
<p><br />
	К сожалению, этот пример (“broadcast”) нам не подойдет, т.к. в его сеть <a href="https://github.com/inet-framework/inet/blob/v3.4.0/examples/inet/broadcast/UDPBroadcastNetwork.ned#L29-L36">включены маршрутизаторы</a>. Однако, по аналогии с ним, можно создать свой проект.
</p><p><br /><anchor>js-bookmarklet</anchor>
	<font color="#54524F"><b>Note</b>:</font> Далее я продолжу ссылаться на разные разделы <a href="https://omnetpp.org/doc/omnetpp/manual/">Simulation Manual</a>. Как видите, он достаточно большой, браузеру требуется время (и RAM) для его открытия. Для решения этой проблемы я сделал небольшой <a href="http://javascript.ru/unsorted/bookmarklet">JS</a>‑<a href="http://habrahabr.ru/post/52346/">bookmark</a><a href="https://ru.wikipedia.org/wiki/Букмарклет">let</a>. После <a href="#comment_18998409">его</a> запуска все ссылки, ведущие на разделы Simulation Manual, перестанут плодить вкладки (пожирая ресурсы), и начнут переключать разделы в одной единственной дополнительной вкладке (на самом деле он просто прописывает <code>target</code> для каждой ссылки на Simulation Manual). Bookmarklet расположен в <a href="#comment_18998409">первом комментарии</a> к этой статье. И, для того, чтобы отличить ссылки на Simulation Manual от остальных ссылок, bookmarklet изменяет их цвет.
</p>
<br /><spoiler title="Почему bookmarklet находится в комментарии, а не прямо здесь?"><hr />
	<p>
		При повторном открытии статьи bookmarklet придется запускать заново. На Хабре авторы статей могут в любой момент изменить содержимое статьи. Содержимое комментария можно изменить только в течение первых 5-и минут. При первом запуске bookmarklet вы наверняка проверили, что он делает.<br />
		⇒ запускать bookmarklet из тела статьи потенциально не безопасно – они могут в любой момент изменится; если же bookmarklet размещен в комментарии, то достаточно проверить его всего один раз (по истечении 5-и минут с момента публикации комментария) – в будущем он не изменится.
	</p>
<hr /></spoiler>
<br /><h3><anchor>sozdaem-proekt</anchor><a href="#sozdaem-proekt" title="Ссылка на раздел"><font color="gray">#</font></a> Создаем проект</h3>
<p><br />
	Пустой проект “LLTR”, с директориями “src” и “simulations”, и единственной конфигурацией “gcc-release” (File → New → <nobr>OMNeT++</nobr> Project…):
</p>
<br /><anchor>fig_wizard</anchor><a href="https://habrastorage.org/webt/nr/my/ue/nrmyueye1npx24ijreifuysoo60.png#wizard.png"><img alt="New OMNeT++ project Wizard" align="center" height="188" src="https://habrastorage.org/webt/nr/my/ue/nrmyueye1npx24ijreifuysoo60.png#wizard.png"/></a>
<p><br />
	Осталось настроить проект также как и “inet”, и можно будет двигаться дальше. В основном, настройка будет отличаться отсутствием необходимости настраивать “gcc-debug” (т.к. он отсутствует в “LLTR”), и добавлением в зависимости “inet”. Более конкретно: вместо <strong>{A,B,G}</strong> надо открыть раздел “Project References”, и включить зависимость от “inet”.
</p>
<br /><h4><anchor>struktura-proekta</anchor><a href="#struktura-proekta" title="Ссылка на раздел"><font color="gray">#</font></a> Структура проекта</h4>
<p><br />
	Если посмотрите на файлы, которые создал Wizard, то увидите, что файл “package.ned” встречается дважды: в директории “src”, и в “simulations”. Содержимое тоже отличается – “<code>package lltr;</code>” и “<code>package lltr.simulations;</code>” соответственно. Один из этих файлов нам не понадобится.
</p><p><br />
	Если провести аналогию со структурой проекта INET, то директория “inet/src” – это “LLTR/src”, а “inet/examples” – это “LLTR/simulations”. То есть в “LLTR/simulations” лучше размещать файлы “.ned” c <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-lang:warmup:network">Network</a>, а в “LLTR/src” – составные части сети (модули).
</p><p><br />
	Существует еще один нюанс – в INET очень хорошая внутренняя структура директорий, и если в будущем нам потребуется изменить один из стандартных модулей в INET, то лучше будет создать новый модуль, и положить его рядом с оригиналом в INET. То же самое можно применить и к модулю, созданному с нуля – найти ему подходящее место в INET.
</p><p><br />
	В свете вышеописанного, “.ned” в директории “LLTR/src” нам не нужен (все будет в “inet/src”), также как и не нужен дополнительный подпакет “<code>package lltr.simulations;</code>” в “LLTR/simulations”. Поэтому переносим “package.ned” из “LLTR/src” в “LLTR/simulations”.
</p>
<br /><h4><anchor>probnyy-zapusk</anchor><a href="#probnyy-zapusk" title="Ссылка на раздел"><font color="gray">#</font></a> Пробный запуск</h4>
<p><br />
	Попробуйте запустить LLTR. Для этого достаточно открыть файл “LLTR/simulations/omnetpp.ini”, и нажать (<nobr>Run &gt;</nobr> <nobr>Run As &gt;</nobr> 1 <nobr>OMNeT++</nobr> Simulation):
</p>
<br /><anchor>fig_Run-Simulation</anchor><img alt="Run simulation from toolbar" align="center" height="138" src="https://habrastorage.org/webt/in/wp/wm/inwpwmagzp9vyoejjs7vj2g1-bk.png#Run-Simulation.png"/>
<p><br />
	При этом Eclipse предложит создать новую конфигурацию “simulations” для запуска симулятора. Соглашаемся, и сразу же сталкиваемся с проблемой: “LLTR/src/LLTR.exe” не был найден. Все верно, ведь “LLTR.exe” никто не собирал, поэтому вначале собираем проект (меню Project → Build Project), а затем опять запускаем симулятор (тем же самым способом).
</p><p><br />
	После запуска симулятора появилось предупреждение “No network specified in the configuration.”, его можно исправить, добавив строку “<code>network = lltr.<strong>Network</strong></code>” в секцию “<code>[General]</code>” файла “omnetpp<strong>.ini</strong>”, и добавив строку “<code>network <strong>Network</strong> {}</code>” в конец файла “package<strong>.ned</strong>”. Этим мы создали пустую сеть (в “.ned” файле), и настроили (в “.ini” файле) симулятор на загрузку этой сети (<strong>Network</strong> – имя сети) при запуске.
</p><p><br />
	Теперь можно попробовать опять запустить симулятор (<nobr>Run &gt;</nobr> <nobr>Run As &gt;</nobr> 1 <nobr>OMNeT++</nobr> Simulation), и вместо ошибки должно открыться серое поле (прямоугольник) сети <strong>Network</strong> на зеленом фоне.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> Есть различие между запуском через (<nobr>Run &gt;</nobr> <nobr>Run As &gt;</nobr> 1 <nobr>OMNeT++</nobr> Simulation), и через (<nobr>Run &gt;</nobr> 1 simulations): в первом случае запуск проходит быстрее, т.к. во втором случае, перед запуском симулятора, Eclipse начинает собирать проект.
</p><p><br /><anchor>git-tag-a1_v0-1-0</anchor>
	<font color="#54524F"><b>Note</b>:</font> (или можно форкнуть – <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/tree/a1_v0.1.0">тег a1_v0.1.0</a> (“a” – article) “<a href="http://stackoverflow.com/questions/791959/download-a-specific-tag-with-git/792027#792027"><code>git checkout -b ‹my_branch› tags/a1_v0.1.0</code></a>”) <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/tree/a1_v0.1.0"><img alt="" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>
</p>
<br /><h4><anchor>rekomendacii-po-ispolzovaniyu-repozitoriya</anchor><a href="#rekomendacii-po-ispolzovaniyu-repozitoriya" title="Ссылка на раздел"><font color="gray">#</font></a> Рекомендации по использованию репозитория</h4>
<p><br />
	Репозиторий я создавал таким образом, чтобы:
</p>
<br /><ul>
	<li>каждый шажок из tutorial совпадал с коммитом в git;</li>
	<li>можно было легко сослаться из tutorial на конкретный коммит – для этого каждый значимый коммит имеет свой тег;</li>
	<li>можно было клонировать (скачать) к себе только коммиты, относящиеся к текущей части (article) – для этого каждая часть имеет свою ветку (формат имени: “article_#”), указывающую на последний коммит/тэг части;</li>
	<li>любой смог легко создавать <strong>свою версию</strong> исходного кода из репозитория, “шагая” по tutorial.</li>
</ul>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> без веток “article_#” можно было бы обойтись, и указывать, при клонировании, название последнего тега части (которое еще надо найти), но с веткой проще/быстрее.
</p><p><br />
	Как забрать репозиторий “к себе”? Лучше всего, вначале его <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/network/members">форкнуть на GitHub</a>, а затем свой форк:
</p>
<br /><ul>
	<li>либо клонировать весь “<code>git clone</code>”;</li>
	<li>либо клонировать только коммиты по текущую часть “<a href="https://stackoverflow.com/questions/1778088/how-to-clone-a-single-branch-in-git/9920956#9920956"><code>git clone --branch ‹article_#› --single-branch</code></a>” (без использования “<a href="https://stackoverflow.com/questions/20280726/how-to-git-clone-a-specific-tag/27421557#27421557"><code>--depth</code></a>”), а для получения коммитов следующей части использовать “<a href="https://stackoverflow.com/questions/17714159/how-do-i-undo-a-single-branch-clone/27860061#27860061"><code>git remote set-branches –add</code></a>” (и <a href="https://stackoverflow.com/questions/41075972/how-to-update-a-git-shallow-clone/41369314#41369314">если что‑то пойдет не так…</a>)</li>
</ul>
<p><br />
	Далее, для создания <strong>личной ветки</strong> на основе конкретного тега, можно использовать “<a href="http://stackoverflow.com/questions/791959/download-a-specific-tag-with-git/792027#792027"><code>git checkout -b ‹<strong>my_branch</strong>› tags/‹tag_name›</code></a>”.
</p><p><br />
	Как создавать <strong>свою версию</strong> кода, т.е. изменять код? Если в будущем не возникнет желания сделать Pull Request, то ничего вам не мешает делать с форком что хотите &gt;:-) , однако я советую, при <strong><font color="#9F8CA1">появлении изменений</font></strong>, которые хочется сохранить, делать так):
</p>
<br /><anchor>fig_git-hcs-flow</anchor><img alt="Git: History Control System flow" align="center" height="160" src="https://habrastorage.org/webt/4r/_m/ej/4r_mejqijia-cxxxmoi7c-rmd44.png#git-hcs-flow.svg.png"/>
<p><br />
	Одинаковая схема наименования тегов поможет в будущем избежать коллизий, даже не смотря на то, что <a href="https://stackoverflow.com/questions/12278660/adding-tags-to-a-pull-request">теги при Pull Request не переносятся</a>.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> Если я в будущем буду вносить изменения в репозиторий, то <strong>я поступлю также</strong>: оригинальный код сохранится, а измененный будет идти параллельно оригинальному (с “<font color="#548DD4">накатанными</font>” всеми изменениями из остальных (будущих) тегов, и с новыми именами тегов). Только вместо добавления “<strong>-u</strong>” к именам новых тегов тегам, я буду увеличивать номер. Например, теги оригинального кода “a1_v0.1.<strong>0</strong>”, “a1_v0.2.<strong>0</strong>”, … – теги измененного кода “a1_v0.1.<strong>1</strong>”, “a1_v0.2.<strong>1</strong>”, … При следующем изменении, номер еще раз увеличится: “a1_v0.1.<strong>2</strong>”, “a1_v0.2.<strong>2</strong>”, …
</p><p><br /><anchor>git-tag-mark</anchor>
	<font color="#54524F"><b>Note</b>:</font> в tutorial все места, завершающие очередной “шажок”, помечены значком git <img alt="git tag diff icon" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/>, и рядом с ним будет ссылка на соответствующий git tag.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> git <strong>diff</strong> использовался стандартный, патчи генерировались автоматически, и они редко будут показывать логической связи в произошедших изменениях (в частности, при добавлении нового кода и изменении уровня вложенности / форматирования существующего кода) (здесь бы пригодилось отслеживание изменений на уровне <a href="https://ru.wikipedia.org/wiki/Абстрактное_синтаксическое_дерево?stable=1"><abbr title="Абстрактное синтаксическое дерево">AST</abbr></a>), похожее на <a href="https://bitbucket.org/sealuzh/tools-changedistiller/wiki/Home#markdown-header-references">этот проект для Java</a>.
</p>

<br /><h2><anchor>sozdanie-pervoy-modeli-link-layer-topology-reveal</anchor><a href="#sozdanie-pervoy-modeli-link-layer-topology-reveal" title="Ссылка на раздел"><font color="gray">#</font></a> Создание первой модели (Link Layer Topology Reveal)</h2><hr />
<br /><h3><anchor>shag-1-sobiraem-set</anchor><a href="#shag-1-sobiraem-set" title="Ссылка на раздел"><font color="gray">#</font></a> Шаг −1: собираем сеть</h3>
<p><br />
	Откроем “package.ned” в режиме графического редактирования схемы (вкладка “Design” снизу), и попробуем набросать сеть из <a href="#LLTR_a1_habr-pic"><abbr title="Картинка Для Привлечения Внимания">КДПВ</abbr></a>:
</p>
<br /><anchor>fig_Network</anchor><img alt="Network editor" align="center" height="418" src="https://habrastorage.org/webt/qj/-w/fp/qj-wfpl-rd19pk1xd8uiiknlwfw.png#Network.png"/>
<p><br />
	Сеть построена из тех же модулей, которые были использованы в примере <a href="https://github.com/inet-framework/inet/blob/v3.4.0/examples/inet/broadcast/UDPBroadcastNetwork.ned">broadcast</a>:
</p>
<br /><ul>
	<li>хосты – StandardHost;</li>
	<li>свитчи – EtherSwitch.</li>
</ul>
<p><br />
	А вот в качестве “провода” (канала связи) выбран Eth100M (скорость: 100 Mbps; длина: 10 метров). Кстати, почему именно <strong>10 метров</strong>, где они задаются, и можно ли поменять это значение? (ответ чуть ниже)
</p><p><br /><anchor>git-tag-a1_v0-2-0</anchor>
	Если переключится в режим редактирования кода (вкладка “Source” снизу), то вы должны <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.2.0/LLTR/simulations/package.ned">увидеть примерно это (git tag a1_v0.2.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.1.0...a1_v0.2.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>. Пояснение структуры:
</p>
<br /><source lang="cpp">package ‹<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-ref:packages">имя пакета</a>›; //<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-ref:directory-structure">особенности наименования</a>

import ‹<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-lang:imports-and-name-resolution">имя подключаемого пакета</a>›;

network ‹<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-lang:warmup:network">название описываемой сети</a>›
{
    @display(‹визуальные параметры сети, например, размер области›);
    <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-ref:submodules">submodules</a>:
        ‹<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-lang:submodules">название узла</a>›: ‹тип узла› { @display(‹визуальные параметры узла, например, местоположение›); }
    <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-ref:connections">connections</a>:
        ‹название узла›.‹<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-lang:gates">точка соединения</a>› &lt;--&gt; ‹тип канала связи› &lt;--&gt; ‹название узла›.‹точка соединения›;
}</source>
<!-- TODO: убрать Warning и спойлер после обновления хабра-парсера -->
<p><br />
	<font color="#e07c00"><b>&#9888;&#8986; Warning</b>:</font> К сожалению Хабр пока не поддерживает вставку ссылок при помощи тега <code>&lt;a&gt;...&lt;/a&gt;</code> – вместо ссылок сейчас в код “вставляются” сами теги. И так происходит не только с этим блоком кода, но и со всеми ниже, в которых использовалась вставка ссылок, либо выделение частей кода при помощи тегов (<code><strong>&lt;strong&gt;...&lt;/strong&gt;</strong></code>, <code><em>&lt;em&gt;...&lt;/em&gt;</em></code>).
</p>
<br /><spoiler title="⌚ Временная замена блоку кода"><hr />
<code>package ‹<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-ref:packages">имя пакета</a>›; //<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-ref:directory-structure">особенности наименования</a><br /><br />import ‹<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-lang:imports-and-name-resolution">имя подключаемого пакета</a>›;<br /><br />network ‹<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-lang:warmup:network">название описываемой сети</a>›<br />{<br />    @display(‹визуальные параметры сети, например, размер области›);<br />    <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-ref:submodules">submodules</a>:<br />        ‹<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-lang:submodules">название узла</a>›: ‹тип узла› { @display(‹визуальные параметры узла, например, местоположение›); }<br />    <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-ref:connections">connections</a>:<br />        ‹название узла›.‹<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-lang:gates">точка соединения</a>› &lt;--&gt; ‹тип канала связи› &lt;--&gt; ‹название узла›.‹точка соединения›;<br />}</code>
<hr /></spoiler>
<p><br />
	Отдельно стоит сказать про “точки соединения” (Gates) и <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-lang:warmup:introducing-a-channel">каналы связи</a>:
</p>
<br /><ol>
	<li><a href="https://web.archive.org/web/20150508223508/http://omnetpp.org/doc/omnetpp/tictoc-tutorial/part3.html#s10">Gates могут быть объявлены как векторы</a>, в этом случае подключатся к ним можно явно, <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-ref:connections">указав номер gate</a> “<code>‹название узла›.‹gate›[‹номер›]</code>”, либо автоматически – <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-ref:connections"><strong>инкрементально</strong></a> “<code>‹название узла›.‹gate›<strong>++</strong></code>”.</li>
	<li>Параметры канала либо могут быть <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-lang:channel-specification">заданы в месте использования</a> (например: “<code>… &lt;--&gt; { delay = 100ms; } &lt;--&gt; …</code>”), либо могут иметь <a href="https://web.archive.org/web/20150508223508/http://omnetpp.org/doc/omnetpp/tictoc-tutorial/part3.html#s11"><strong>имя/тип</strong></a>, <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-lang:channel-names">на которое можно ссылаться</a> (как в примере <a href="https://github.com/inet-framework/inet/blob/v3.4.0/examples/inet/broadcast/UDPBroadcastNetwork.ned#L15">broadcast</a>: “<code>… &lt;--&gt; C &lt;--&gt; …</code>”), либо могут иметь тип и быть <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-ref:static-channel-type">переопределены на месте</a> (например: “<code>… &lt;--&gt; FastEthernet {per = 1e-6;} &lt;--&gt; …</code>”), <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-ref:parametric-channel-type">либо…</a></li>
	<li>Gates могут быть однонаправленными (тип при объявлении: <code>output</code> / <code>input</code>; соединители при подключении: <code>--&gt;</code> / <code>&lt;--</code>), и <a href="https://web.archive.org/web/20150508223508/http://omnetpp.org/doc/omnetpp/tictoc-tutorial/part3.html#s12"><strong>двунаправленными</strong></a> (тип при объявлении: <code>inout</code>; соединитель при подключении: <code>&lt;--&gt;</code> ). Двунаправленные состоят из двух однонаправленных, к которым можно обратиться напрямую, <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-ref:inout-gates">дописав суффикс “<strong><code>$i</code></strong>” либо “<strong><code>$o</code></strong>”</a>.</li>
</ol>
<br /><h4><anchor>issleduem-parametry-moduley</anchor><a href="#issleduem-parametry-moduley" title="Ссылка на раздел"><font color="gray">#</font></a> Исследуем параметры модулей</h4>
<p><br />
	Так почему же у Eth100M длина <strong>10 метров</strong>? Для ответа на этот вопрос, переключимся назад в редактор схемы (“Design”), выберем любое соединение, откроем его контекстное меню, и откроем “Parameters…”:
</p>
<br /><anchor>fig_Eth100M-Parameters</anchor><img alt="Eth100M parameters" align="center" height="321" src="https://habrastorage.org/webt/aj/na/bg/ajnabgtb_ecjpuehxvmk4prhjbc.png#Eth100M-Parameters.png"/>
<p><br />
	Вот эти <strong>10 метров</strong>, записанные как “<code>default(<strong>10m</strong>)</code>”.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> Только те параметры, которые были заданы как “<code>default()</code>” можно менять. Если же изменить, например, “<code>datarate</code>”, то IDE не ругнется на это, но симулятор откажется принимать такой “.ned” файл.
</p><p><br />
	Вы наверняка уже заметили, что если навести указатель (мышку) на значок хоста или свитча, то появится всплывающая подсказка. В них есть несколько интересных моментов. Фрагмент подсказки хоста:
</p>
<blockquote>
	Can be connected via ethernet interface to other nodes using the ethg gate. By default full-duplex connections are supported only (twisted pair). Set **.eth[*].typename=&quot;EthernetInterface&quot; for a full/half-duplex CSMA/CD implementation (coaxial cable)
</blockquote>
<p>
	Фрагмент подсказки свитча:
</p>
<blockquote>
	The duplexChannel attributes of the MACs must be set according to the medium connected to the port; if collisions are possible (it's a bus or hub) it must be set to false, otherwise it can be set to true. By default used half duples CSMA/CD mac
</blockquote>
<p>
	Начнем с хоста. Судя по описанию все хорошо – по умолчанию используется full-duplex. А вот со свитчем проблема – по умолчанию используется “half duples CSMA/CD mac”. Будим настраивать!
</p><p><br />
	В подсказке упоминается параметр/атрибут “<code>duplexChannel</code>”, поэтому откроем “Parameters…” у “switch0” и:
</p>
<br /><anchor>fig_switch-Parameters</anchor><img alt="switch parameters" align="center" height="404" src="https://habrastorage.org/webt/gu/kv/ax/gukvaxbzzor_kuvvbkb7uwgvgbs.png#switch-Parameters.png"/>
<p><br />
	… так, а где здесь “<code>duplexChannel</code>”? Параметра “<code>eth[*].typename</code>” из подсказки хоста тоже не видно. Однако есть другие параметры с говорящим названием. Пока их менять не будем, а посмотрим на “Parameters…” у “host0”, и:
</p>
<br /><anchor>fig_host-Parameters</anchor><img alt="host parameters" align="center" height="787" src="https://habrastorage.org/webt/ed/_p/zc/ed_pzcjljaklgdh1vouqij5pnas.png#host-Parameters.png"/>
<p><br />
	… и здесь “<code>eth[*].typename</code>” нет.
</p><p><br />
	На самом деле отсутствие “<code>eth[*].typename</code>” вполне объяснимо – “Parameters…” отображает только параметры текущего модуля, а из параметров вложенных модулей он отображает только те, которые были переопределены в текущем модуле. У переопределенных значений вложенных модулей столбец “Type” пуст.
</p><p><br />
	В <nobr>OMNeT++</nobr> есть панель, которая отображает все параметры модуля, включая параметры вложенных модулей. Называется “NED Parameters”, находится внизу:
</p>
<br /><anchor>fig_host-NED-Parameters</anchor><img alt="host NED Parameters" align="center" height="457" src="https://habrastorage.org/webt/uf/ye/tm/ufyetmtorykmlra2-mgkullrez4.png#host-NED-Parameters.png"/>
<p><br />
	И опять же здесь нет “<code>eth[*].typename</code>”.
</p><p><br />
	Вряд ли он будет в свитче, но все же посмотрим:
</p>
<br /><anchor>fig_switch-NED-Parameters</anchor><img alt="switch NED Parameters" align="center" height="633" src="https://habrastorage.org/webt/wp/vu/th/wpvuthrmphdixnxnkebnzlhs6dq.png#switch-NED-Parameters.png"/>
<p><br />
	Как и ожидалось, “<code>eth[*].typename</code>” отсутствует. Параметр “<code>duplexChannel</code>” тоже отсутствует. Скорее всего их заменили на “<code>macType</code>”, который зависит (<code>csmacdSupport ? &quot;EtherMAC&quot; : &quot;EtherMACFullDuplex&quot;</code>) от “<code>csmacdSupport</code>”, а комментарий подправить забыли. Также видно (по точкам, и Remark), что “<code>switch0.csmacdSupport</code>” и “<code>switch0.macType</code>” переопределяют “<code>switch0.eth[*].csmacdSupport</code>” и “<code>switch0.eth[*].macType</code>” соответственно. Если выбрать “Open NED Declaration” на “<code>switch0.macType</code>”, то можно будет изучить <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/node/ethernet/EtherSwitch.ned#L47">“.ned” файл модуля “EtherSwitch”</a> (там же будет текст всплывающей подсказки с “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/node/ethernet/EtherSwitch.ned#L33-L36"><code>duplexChannel</code></a>”).
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> в исходниках “.ned” также работают горячие клавиши Eclipse, и можно быстро открывать файл с определением любого подключенного модуля, используя <kbd>Ctrl+Click</kbd>.
</p><p><br />
	Можно попробовать открыть “Open NED Declaration” у “<code>switch0.eth[*].csmacdSupport</code>”, и у “<code>host0.eth[*].csmacdSupport</code>”, должен открыться один и тот же файл.
</p><p><br />
	Что теперь со всем этим делать? Можно открыть “Parameters…” каждого свитча, и установить в них “<code>csmacdSupport = false</code>”. Также выглядит подозрительным, что “<code>switch0.eth[*].mac.duplexMode</code>” и “<code>host0.eth[*].mac.duplexMode</code>” ничему не назначены, поэтому для каждого хоста и свитча добавляем “<code>eth[*].mac.duplexMode = true</code>”.
</p><p><br /><anchor>git-tag-a1_v0-3-0</anchor>
	Изменений получилось много, поэтому проще их внести в режиме редактора кода (вкладка “Source”). Должно получится <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.3.0/LLTR/simulations/package.ned">примерно так (git tag a1_v0.3.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.2.0...a1_v0.3.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>.
</p>
<br /><h4><anchor>vybor-mesta-dlya-zadaniya-parametrov-moduley</anchor><a href="#vybor-mesta-dlya-zadaniya-parametrov-moduley" title="Ссылка на раздел"><font color="gray">#</font></a> Выбор места для задания параметров модулей</h4>
<p><br />
	Все равно то, что сделали выше, не очень хорошо выглядит – пришлось для каждого узла применять практически одинаковые параметры, и если в будущем захотим что‑то изменить, то придется вносить изменения для каждого узла. Благо, что можно вынести эти записи в “<code>parameters:</code>” к “Network”:
</p>
<br /><source lang="cpp">parameters:
    @display(&quot;bgb=693,416,grey99&quot;);
    **.csmacdSupport = false;
    **.eth[*].mac.duplexMode = true;</source>
<p><br /><anchor>git-tag-a1_v0-4-0</anchor>
	Должно получиться <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.4.0/LLTR/simulations/package.ned">примерно так (git tag a1_v0.4.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.3.0...a1_v0.4.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>. Здесь нужно использовать <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:config-sim:asterisk-vs-double-asterisk">именно “<code>**</code>”</a> (<a href="https://git-scm.com/docs/gitignore#_pattern_format">аналогия с Git</a>).
</p><p><br />
	Однако, эти же параметры можно задать и в “.ini” файле. <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-lang:parameter-assignments">Документация рекомендует</a> использовать “.ini” файл для параметров модели, которые, скорее всего, будут манятся в процессе экспериментирования, а в “.ned” файлах следует оставить неизменяемые значения:
</p>
<blockquote cite="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-lang:parameter-assignments">
	<p>
		NOTE
	</p><p><br />
		How do you decide whether to assign a parameter from NED or from an ini file? The advantage of ini files is that they allow a cleaner separation of the model and experiments. NED files (together with <nobr>C++</nobr> code) are considered to be part of the model, and to be more or less constant. Ini files, on the other hand, are for experimenting with the model by running it several times with different parameters. Thus, parameters that are expected to change (or make sense to be changed) during experimentation should be put into ini files.
	</p>
</blockquote>
<p>
	Тем не менее, в документации не рассмотрен еще один случай: в будущем, скорее всего, нам понадобится проводить эксперименты с разными сетями (разными топологиями; каждая топология будет лежать в отдельном “.ned” файле), но с одинаковыми параметрами. Если следовать их рекомендации, то “<code>csmacdSupport</code>” и “<code>duplexMode</code>” нужно будет разместить в каждом “.ned” файле сети, т.к. вряд ли мы их будем менять в ходе экспериментов. Что опять приводит нас к дублированию одинаковых настроек.
</p><p><br /><anchor>git-tag-a1_v0-5-0</anchor>
	Поэтому удобнее будет включить общие параметры сетей в секцию “<code>[General]</code>” “.ini” файла, и, используя <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:config-sim:named-configurations">именованные конфигурации</a>, появится возможность переключатся между сетями с распространением на них общих параметров. В итоге должно получиться <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/commit/2af118ad12620820c006e4923d2218daf4f65824">примерно так (git tag a1_v0.5.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.4.0...a1_v0.5.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>.
</p>
<br /><h4><anchor>probnyy-zapusk-1</anchor><a href="#probnyy-zapusk-1" title="Ссылка на раздел"><font color="gray">#</font></a> Пробный запуск</h4>
<p><br />
	Переключаемся на “omnetpp.ini”, запускаем (<a href="#probnyy-zapusk"><nobr>Run &gt;</nobr> <nobr>Run As &gt;</nobr> 1 <nobr>OMNeT++</nobr> Simulation</a>), и симулятор сообщает о проблеме:
</p>
<blockquote>
	Error in module (inet::IPv4NodeConfigurator) Network.host0.networkLayer.configurator (id=73) during network initialization: Configurator module 'configurator' not found (check the '<strong>networkConfiguratorModule</strong>' parameter).
</blockquote>
<p>
	В сообщении явно указывается место ошибки – “<code>Network.host0.networkLayer.configurator</code>”. Посмотрим на него: откроем “package.ned”, переключимся в редактор схемы (вкладка “Design”), и откроем панель “NED Parameters” на узле “host0”. Среди параметров будет “<code>host0.networkLayer.configurator.<strong>networkConfiguratorModule</strong></code>”, посмотрим (Open NED Declaration) на “.ned” файл в котором он находится. Этот файл называется “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/configurator/ipv4/IPv4NodeConfigurator.ned">IPv4<strong>Node</strong>Configurator.ned</a>”, часть из его описания:
</p>
<blockquote cite="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/configurator/ipv4/IPv4NodeConfigurator.ned#L24-L37">
	<p>
		This module acts like a bridge between the node and the network's global configurator module - IPv4<strong>Network</strong>Configurator.
	</p><p><br />
		IPv4<strong>Network</strong>Configurator only computes and remembers configuration data (assigned IP addresses, static routes, etc), but doesn't configure the nodes routing tables and interfaces accordingly. The actual configuration is carried out by this module...
	</p>
</blockquote>
<p>
	То есть в узлах сети есть локальный конфигуратор (*<strong>Node</strong>Configurator), который запрашивает параметры сети у глобального конфигуратора (*<strong>Network</strong>Configurator), и настраивает локальный узел. В примере “<a href="https://github.com/inet-framework/inet/tree/v3.4.0/examples/inet/broadcast/UDPBroadcastNetwork.ned#L37">broadcast</a>” был глобальный конфигуратор – “IPv4<strong>Network</strong>Configurator”, а в свою сеть мы забыли его включить…
</p>
<br /><h4><anchor>naznachenie-ip-adresov-ustroystvam-v-seti</anchor><a href="#naznachenie-ip-adresov-ustroystvam-v-seti" title="Ссылка на раздел"><font color="gray">#</font></a> Назначение IP адресов устройствам в сети</h4>
<p><br />
	Как выяснили выше, для настройки IP (адреса, маршруты, …) в сети, используется связка из глобального конфигуратора (*<strong>Network</strong>Configurator) и локального (*<strong>Node</strong>Configurator). Но как локальный конфигуратор узнает, к какому модулю сети обращаться для получения конфигурации, ведь глобальный конфигуратор – это такой же модуль сети, как и все остальные модули (хосты, свитчи, …)?
</p><p><br />
	Посмотрим опять на ошибку, которую вывел симулятор сети при запуске: “Configurator module 'configurator' not found”. То есть он искал модуль с названием “<code>configurator</code>”. Это <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/configurator/ipv4/IPv4NodeConfigurator.ned#L44">его поведение по умолчанию</a>. Поэтому нам надо добавить в сеть глобальный конфигуратор (*<strong>Network</strong>Configurator), и дать ему имя “<code>configurator</code>”.
</p><p><br />
	В доке “inet/doc/<a href="https://omnetpp.org/doc/inet/api-3.4.0/inet-manual-draft.pdf">inet-manual-draft.pdf</a>” на 80 странице начинается раздел “11.9 Configuring IPv4 networks”. В разделе рассказывается про 3 способа настройки сети: 1 новый (используя модуль “IPv4<strong>Network</strong>Configurator”), и 2 старых (для автоматической настройки – модуль “Flat<strong>Network</strong>Configurator” [страница 87], и для ручной – конфиг‑файлы). Ссылки на краткие описания работы модулей: “<a href="https://omnetpp.org/doc/inet/api-3.4.0/neddoc/index.html?p=inet.networklayer.configurator.ipv4.FlatNetworkConfigurator.html">Flat<strong>Network</strong>Configurator</a>” и “<a href="https://omnetpp.org/doc/inet/api-3.4.0/neddoc/index.html?p=inet.networklayer.configurator.ipv4.IPv4NetworkConfigurator.html">IPv4<strong>Network</strong>Configurator</a>”.
</p>
<br /><spoiler title="Скачать “inet-manual-draft.pdf”, сгенерированный 2016-01-22 (включен в INET v3.4.0)"><hr />
	<p>
		В этой статье я буду ссылаться именно на эту версию “inet-manual-draft.pdf”:
	</p>
	<br /><anchor>fig_inet-manual-draft-2016-01-22-un_7z_me-pdf</anchor><img alt="inet-manual-draft-2016-01-22-un_7z_me.pdf.png" height="32" src="https://habrastorage.org/webt/m9/fi/_n/m9fi_ncxone58rnmmbosp_kqcmu.png#inet-manual-draft-2016-01-22-un_7z_me.pdf.png"/>
	<p><br />
		Картинку нужно сохранить под именем “inet-manual-draft-2016-01-22-un_7z_me.pdf<strong>.png</strong>”, и распаковать (7zip).
	</p><p><br />
		<font color="#54524F"><b>Note</b>:</font> также эта версия “inet-manual-draft.pdf” сохранена в <a href="http://web.archive.org/web/20170803162902/https://omnetpp.org/doc/inet/api-current/inet-manual-draft.pdf">web.archive</a>, и, возможно, сохранится <a href="https://omnetpp.org/doc/inet/api-3.4.0/inet-manual-draft.pdf">на основном сайте</a>.
	</p>
<hr /></spoiler>
<p><br />
	Мы сделали плоскую сеть, поэтому возможностей “Flat<strong>Network</strong>Configurator” должно хватить. Также его легче настраивать, и он проще устроен, чем “IPv4<strong>Network</strong>Configurator”. Единственное, преимущество использования “IPv4<strong>Network</strong>Configurator” для нас – это то, что он оптимизирует таблицу маршрутизации, а “Flat<strong>Network</strong>Configurator” – не делает это (из “inet-manual-draft.pdf”):
</p>
<blockquote cite="https://omnetpp.org/doc/inet/api-3.4.0/inet-manual-draft.pdf">
	NOTE: This configurator (&quot;Flat<strong>Network</strong>Configurator&quot;) does not try to optimize the routing tables. If the network contains n nodes, the size of all routing tables will be proportional to n<sup>2</sup>, and the time of the lookup of the best matching route will be proportional to n.
</blockquote>
<p>
	Попробуем оба конфигуратора, и посмотрим, как они работают.
</p><p><br />
	Начнем с “Flat<strong>Network</strong>Configurator”. Его можно добавить через редактор схемы (“Design”) или редактор кода (“Source”). В палитре редактора схемы его поможет найти фильтр “configurator”:
</p>
<br /><anchor>fig_FlatNetworkConfigurator-filter</anchor><img alt="FlatNetworkConfigurator – filter" align="center" height="386" src="https://habrastorage.org/webt/zx/zi/ym/zxziym1qnmx4ogd_eyahnm1isei.png#FlatNetworkConfigurator-filter.png"/>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> Если заметили на скриншоте HostAutoConfigurator, то знайте, что он – <a href="https://omnetpp.org/doc/inet/api-3.4.0/neddoc/index.html?p=inet.networklayer.configurator.ipv4.HostAutoConfigurator.html">deprecated</a>.
</p><p><br />
	После добавления задайте параметры: networkAddress “<code>&quot;10.0.1.0&quot;</code>”, netmask “<code>&quot;255.255.255.0&quot;</code>”. И, как помните, следует сменить его название на “<code>configurator</code>” (без этого локальные конфигураторы [*<strong>Node</strong>Configurator] его попросту не найдут).
</p><p><br />
	Если же хотите использовать редактор кода, то просто, вначале подключите модуль “<code>import inet.networklayer.configurator.ipv4.FlatNetworkConfigurator;</code>”, а затем в “<code>submodules:</code>” добавьте:
</p>
<br /><source lang="cpp">configurator: FlatNetworkConfigurator {
    parameters:
        @display(&quot;p=62,31&quot;);
        networkAddress = &quot;10.0.1.0&quot;;
        netmask = &quot;255.255.255.0&quot;;
}</source>
<p><br /><anchor>git-tag-a1_v0-6-0</anchor>
	Должно получиться <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.6.0/LLTR/simulations/package.ned">примерно так (git tag a1_v0.6.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.5.0...a1_v0.6.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>.
</p><p><br />
	Запускаем симулятор, и получаем сообщение:
</p>
<blockquote>
	Error in module (inet::IPv4NodeConfigurator) Network.host0.networkLayer.configurator (id=74) during network initialization: check_and_cast(): cannot cast (inet::FlatNetworkConfigurator*)Network.configurator to type 'inet::IPv4NetworkConfigurator *'.
</blockquote>
<p>
	Похоже, что “<code>host0.networkLayer.configurator</code>” (IPv4<strong>Node</strong>Configurator) ожидает увидеть именно “IPv4<strong>Network</strong>Configurator”. В Google Группе <a href="https://groups.google.com/d/msg/omnetpp/tXjg1W_lbhs/KpNTeB0BXy8J"><nobr>OMNeT++</nobr> Users</a> предлагают выкинуть “Flat<strong>Network</strong>Configurator” и использовать нормальный “IPv4<strong>Network</strong>Configurator”, но мы все же заставим “Flat<strong>Network</strong>Configurator” работать.
</p><p><br />
	Вообще‑то проблема не в “Flat<strong>Network</strong>Configurator”, а в “IPv4<strong>Node</strong>Configurator” – его сделали специально для “IPv4<strong>Network</strong>Configurator” (<a href="#probnyy-zapusk-1">вспомните предыдущий пробный запуск</a>). То же самое написано и в <a href="https://omnetpp.org/doc/inet/api-3.4.0/neddoc/index.html?p=inet.networklayer.configurator.ipv4.IPv4NetworkConfigurator.html">описании</a> “IPv4<strong>Network</strong>Configurator”:
</p>
<blockquote cite="https://omnetpp.org/doc/inet/api-3.4.0/neddoc/index.html?p=inet.networklayer.configurator.ipv4.IPv4NetworkConfigurator.html">
	IMPORTANT: as of INET 2.2, this module does NOT assign addresses or add routes directly, just stores them in its internal data structures. Network nodes are supposed to contain an instance of IPv4NodeConfigurator (normally part of the network layer compound module) that actually configures the node's interface table and routing table based on the information stored in the global network configurator module.
</blockquote>
<p>
	Для функционирования “Flat<strong>Network</strong>Configurator” модуль “IPv4<strong>Node</strong>Configurator” не нужен. Поэтому в “omnetpp.ini” добавляем:
</p>
<br /><source lang="ini">**.networkLayer.configurator.networkConfiguratorModule = &quot;&quot;</source>
<p><br />
	Кстати, в <a href="https://groups.google.com/forum/#!topic/omnetpp/tXjg1W_lbhs">той же теме на форуме</a> это решение было написано в первом посте.
</p><p><br /><anchor>git-tag-a1_v0-7-0</anchor>
	В итоге должно получиться <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.7.0/LLTR/simulations/omnetpp.ini">примерно так (git tag a1_v0.7.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.6.0...a1_v0.7.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>.
</p><p><br />
	<a href="#probnyy-zapusk">Запускаем симулятор</a>, и:
</p>
<br /><anchor>fig_FlatNetworkConfigurator-network_32mask</anchor><img alt="FlatNetworkConfigurator: network mask 32" align="center" height="416" src="https://habrastorage.org/webt/al/75/yt/al75ytcec0x87x9jxjgyj49vhxc.png#FlatNetworkConfigurator-network_32mask.png"/>
<p><br />
	… почему маска “/32”? Даже если изменить параметр “<code>netmask</code>” на любое другое (кроме “<code>&quot;0.0.0.0&quot;</code>” и “<code>&quot;255.255.255.255&quot;</code>”) значение, то маска останется та же – “/32”. Проверено.
</p><p><br />
	Похоже, пора последовать совету с форума и забыть про “Flat<strong>Network</strong>Configurator”, но т.к. мы уже запустили симулятор, посмотрим какие настройки внес этот конфигуратор в узлы сети.
</p><p><br />
	В симуляторе есть очень удобный инструмент для отображения текущего состояния модулей сети. По сути, в данном случае, симулятор – это отладчик сети, наподобие отладчика программы, в котором выполнение программы можно приостановить, и посмотреть текущие значения переменных (на изображении сети выбираем “host0”, и переключаем режим отображения левой панели на “children mode”):
</p>
<br /><anchor>fig_FlatNetworkConfigurator-qtenv-host0-children</anchor><img alt="FlatNetworkConfigurator: qtenv host0 children" align="center" height="654" src="https://habrastorage.org/webt/zf/_m/yb/zf_mybqfrx3yleianeylr-ijnzm.png#FlatNetworkConfigurator-qtenv-host0-children.png"/>
<p><br />
	Можно просматривать не только текущие значения параметров, которые отображались в “NED Parameters”, но и некоторую дополнительную информацию. Значения можно менять (я двойным кликом открыл параметр “<code>forwarding</code>”, переключился в “grouped” режим, и завершающий двойной клик открыл поле для редактирования “<code>value</code>”):
</p>
<br /><anchor>fig_FlatNetworkConfigurator-qtenv-host0-grouped-forwarding-value</anchor><img alt="FlatNetworkConfigurator: qtenv host0 grouped forwarding value" align="center" height="285" src="https://habrastorage.org/webt/y3/tv/kc/y3tvkc3skghtymmjin89bitjh40.png#FlatNetworkConfigurator-qtenv-host0-grouped-forwarding-value.png"/>
<p><br />
	Кстати, это скриншоты из GUI симулятора, который появился в <nobr>OMNeT++</nobr> 5.0 – Qtenv, он основан на Qt, и он быстрее предыдущего – Tkenv (<a href="https://ru.wikipedia.org/wiki/Tcl?stable=1">Tcl/Tk</a>). Однако в Tkenv визуализация дерева параметров была реализована лучше/аккуратнее (ИМХО):
</p>
<br /><anchor>fig_FlatNetworkConfigurator-tkenv-host0-grouped-forwarding-value</anchor><img alt="FlatNetworkConfigurator: tkenv host0 grouped forwarding value" align="center" height="320" src="https://habrastorage.org/webt/h3/r6/ep/h3r6epwmouvguyb-eyskjizvup8.png#FlatNetworkConfigurator-tkenv-host0-grouped-forwarding-value.png"/>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> Переключится на Tkenv можно в <nobr>Eclipse &gt;</nobr> <nobr>Run &gt;</nobr> Run Configurations.
</p><p><br />
	Мы немного отвлеклись на GUI… Пора вспомнить, зачем мы полезли в параметры сети.
</p><p><br />
	Мы хотели, перед тем как придать “Flat<strong>Network</strong>Configurator” забвению, посмотреть в каком месте у хостов он прописал адреса, и маршруты. В его <a href="https://omnetpp.org/doc/inet/api-3.4.0/neddoc/index.html?p=inet.networklayer.configurator.ipv4.FlatNetworkConfigurator.html">документации</a> сказано следующее:
</p>
<blockquote cite="https://omnetpp.org/doc/inet/api-3.4.0/neddoc/index.html?p=inet.networklayer.configurator.ipv4.FlatNetworkConfigurator.html">
	<p>
		It is assumed that the routing table (IPv4RoutingTable module) is the &quot;<strong>routingTable</strong>&quot; or &quot;networkLayer.routingTable&quot; submodule in all hosts and routers.
	</p><p><br />
		...
	</p><p><br />
		In stage 0, interfaces register themselves in the <strong>InterfaceTable</strong> modules...
	</p>
</blockquote>
<p>
	Посмотрим на “InterfaceTable”:
</p>
<br /><anchor>fig_FlatNetworkConfigurator-qtenv-host0-children-grouped-InterfaceTable</anchor><img alt="FlatNetworkConfigurator: qtenv host0 children grouped InterfaceTable" align="center" height="125" src="https://habrastorage.org/webt/fb/o_/tw/fbo_twfdqpnso9ojy1zqvz_oyvc.png#FlatNetworkConfigurator-qtenv-host0-children-grouped-InterfaceTable.png"/>
<br /><!-- nohighlight --><source lang="bash">eth0 id=101  on:nwLayer.ifOut[1]  MTU:1500 BROADCAST MULTICAST  macAddr:0A-AA-00-00-00-07 IPv4:{inet_addr:<strong>10.0.1.1/32</strong> mcastgrps:224.0.0.1}</source>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> Копирование значений в Qtenv пока не поддерживается, а вот в Tkenv оно работает:
</p>
<br /><anchor>fig_tkenv-copy</anchor><img alt="tkenv – context menu – copy" align="center" height="215" src="https://habrastorage.org/webt/5l/r3/pn/5lr3pn-cppu4u03exaxm6-afa1m.png#tkenv-copy.png"/>
<p><br />
	А теперь посмотрим на “<code>routingTable</code>”:
</p>
<br /><anchor>fig_FlatNetworkConfigurator-qtenv-host0-children-grouped-routingTable</anchor><img alt="FlatNetworkConfigurator: qtenv host0 children grouped routingTable" align="center" height="329" src="https://habrastorage.org/webt/h8/pc/we/h8pcweycf3wsj6sqybiakymz5wm.png#FlatNetworkConfigurator-qtenv-host0-children-grouped-routingTable.png"/>
<br /><!-- nohighlight --><source lang="bash">dest:*  gw:*  mask:*  metric:0 if:eth0(10.0.1.1)  DIRECT MANUAL</source>
<p><br />
	Если “<code>*</code>” означает адрес “0.0.0.0”, то все будет работать нормально, и мы зря беспокоились насчет маски. Может он ставит маску “/32” специально? Вообще‑то так и есть.
</p><p><br />
	Поищем исходники FlatNetworkConfigurator:
</p>
<br /><ol>
	<li>раскроем дерево inet в “Project Explorer” (если не раскрыть, то на 3‑м этапе “Project Explorer” не перейдет на “FlatNetworkConfigurator.ned”),</li>
	<li>через редактор кода “package.ned” открыть место определения “FlatNetworkConfigurator” (<kbd>Ctrl+Click</kbd>),</li>
	<li>в “Project Explorer”, рядом с открывшимся файлом, увидеть “FlatNetworkConfigurator.cc”.</li>
</ol>
<br /><anchor>fig_Open-FlatNetworkConfigurator_cc</anchor><img alt="Open FlatNetworkConfigurator.cc" align="center" height="596" src="https://habrastorage.org/webt/6c/ys/r0/6cysr0glqqc5xahvvftymrlctua.png#Open-FlatNetworkConfigurator_cc.png"/>
<p><br /><anchor>IPv4Address-ALLONES_ADDRESS</anchor>
	В “FlatNetworkConfigurator.cc” будет <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/configurator/ipv4/FlatNetworkConfigurator.cc#L103">строчка</a>, в которой назначается маска сети:
</p>
<br /><source lang="cpp">ie-&gt;ipv4Data()-&gt;setNetmask(IPv4Address::ALLONES_ADDRESS);    // full address must match for local delivery</source>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> “<code>ALLONES_ADDRESS</code>” равен “255.255.255.255”.
</p><p><br />
	Комментарий весьма странный. Получается, что если переписать код, и назначить маску, отличную от “255.255.255.255”, то пакеты перестанут ходить между узлами одной подсети??? Вряд ли, т.к. единственное предназначение этого конфигуратора – настраивать плоскую сеть (одна подсеть). Возможно, имеется в виду случай, когда приложения хоста используют адрес внешнего интерфейса в качестве loopback адреса???
</p><p><br />
	К счастью <nobr>OMNeT++</nobr>/INET не является черным ящиком: можно поменять “<code>IPv4Address::ALLONES_ADDRESS</code>” на “<code>netmask</code>”, можно просмотреть всю логику работы, можно … Предлагаю в будущем с этим поэкспериментировать, а мы уже переходим к “IPv4<strong>Network</strong>Configurator”.
</p><p><br />
	Чтобы перейти с “Flat<strong>Network</strong>Configurator” на “IPv4<strong>Network</strong>Configurator” нужно:
</p>
<br /><ol>
	<li>удалить из “omnetpp.ini” строчку<br />
		'<code>**.networkLayer.configurator.networkConfiguratorModule = &quot;&quot;</code>', чтобы включить “IPv4<strong>Node</strong>Configurator”;</li>
	<li>через редактор кода “package.ned” заменяем “<code>Flat<strong>Network</strong>Configurator</code>” на “<code>IPv4<strong>Network</strong>Configurator</code>” (заменяем в двух местах: в импорте, и в месте использования);</li>
	<li>убираем из параметров конфигуратора “<code>networkAddress</code>” и “<code>netmask</code>”, т.к. “IPv4<strong>Network</strong>Configurator” не использует эти параметры.</li>
</ol>
<p><br /><anchor>git-tag-a1_v0-8-0</anchor>
	Должно получиться <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/commit/4f8e0ac51756eba4aa357148542b6f39f88b60df">примерно так (git tag a1_v0.8.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.7.0...a1_v0.8.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>.
</p><p><br />
	<a href="#probnyy-zapusk">Запускаем симулятор</a>:
</p>
<br /><anchor>fig_IPv4NetworkConfigurator-network</anchor><img alt="IPv4NetworkConfigurator: network" align="center" height="416" src="https://habrastorage.org/webt/ll/1q/fs/ll1qfsizbldauh1l_4yfpzb0h9q.png#IPv4NetworkConfigurator-network.png"/>
<p><br />
	Все хорошо, маска как раз такая, чтобы вместить 4+<strong>2</strong> адреса (<a href="https://habrahabr.ru/post/129664"><strong>2</strong>: 10.0.0.0 – адрес подсети; 10.0.0.7 – broadcast адрес</a>).
</p><p><br />
	А как изменились маршруты на хостах? Посмотрим на “<code>host0.<strong>routingTable</strong>.routes</code>”:
</p>
<br /><anchor>fig_IPv4NetworkConfigurator-qtenv-host0-grouped-routingTable-routes</anchor><img alt="IPv4NetworkConfigurator: qtenv host0 grouped routingTable routes" align="center" height="128" src="https://habrastorage.org/webt/ln/7k/gi/ln7kgi7eplcrl-dbpufcimylggq.png#IPv4NetworkConfigurator-qtenv-host0-grouped-routingTable-routes.png"/>
<br /><!-- nohighlight --><source lang="bash">[0] = dest:10.0.0.0  gw:*  mask:255.255.255.248  metric:0 if:eth0(10.0.0.1)  DIRECT MANUAL
[1] = dest:10.0.0.0  gw:*  mask:255.255.255.248  metric:20 if:eth0(10.0.0.1)  DIRECT IFACENETMASK</source>
<p><br />
	Самое время вспомнить цитату из документации (“inet-manual-draft.pdf”), в которой говорилось, что “IPv4<strong>Network</strong>Configurator” оптимизирует таблицу маршрутизации, а “Flat<strong>Network</strong>Configurator” не делает этого. В итоге у “Flat<strong>Network</strong>Configurator” в таблице маршрутизации было 2 записи, а у “IPv4<strong>Network</strong>Configurator” – 3 записи. Почему так произошло?
</p>
<br /><anchor>fig_That-Detective-is-the-right-question-Program-terminated</anchor><img alt="That, Detective, is the right question. Program terminated." align="center" height="339" src="https://habrastorage.org/webt/zo/c8/q4/zoc8q45hirh8gh2dfk4jnm40wyy.jpeg#That-Detective-is-the-right-question-Program-terminated.jpg"/>
<br /><spoiler title="спойлер"><hr />
	<p>
		Намек на параметр “<code>addStaticRoutes</code>”.
	</p>
<hr /></spoiler>
<p><br /><anchor>configure-IPv4NetworkConfigurator</anchor>
	Сейчас “IPv4<strong>Network</strong>Configurator” работает в автоматическом режиме, выдавая адреса по умолчанию. Попробуем настроить его на раздачу адресов, из подсети “10.0.1.0”, с маской “/24”.
</p><p><br />
	Вначале посмотрим на дамп его текущей “автоматической” конфигурации. Для этого надо настроить параметр “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/configurator/ipv4/IPv4NetworkConfigurator.ned#L427"><code>dumpConfig</code></a>”:
</p>
<br /><source lang="cpp">configurator: IPv4NetworkConfigurator {
    parameters:
        @display(&quot;p=62,31&quot;);
        dumpConfig = &quot;config_dump.xml&quot;;
}</source>
<p><br /><anchor>git-tag-a1_v0-9-0</anchor>
	После запуска симулятора, появится <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.9.0/LLTR/simulations/config_dump.xml">файл “LLTR/simulations/config_dump.xml” (git tag a1_v0.9.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.8.0...a1_v0.9.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>. Однако, все, что в нем есть мы уже и так знали.
</p>
<br /><spoiler title="не совсем так"><hr />
	<p>
		Обратите внимание на запись:
	</p>
	<br /><source lang="xml">&lt;route hosts=&quot;Network.host3&quot; destination=&quot;<strong>10.0.0.0</strong>&quot; netmask=&quot;255.255.255.252&quot; gateway=&quot;*&quot; interface=&quot;eth0&quot; metric=&quot;0&quot;/&gt;</source>
	<p><br />
		Маска “<code>255.255.255.252</code>”, при том, что IP этого хоста “<code>10.0.0.4</code>”:
	</p>
	<br /><source lang="xml">&lt;interface hosts=&quot;Network.host3&quot; names=&quot;eth0&quot; address=&quot;10.0.0.4&quot; netmask=&quot;255.255.255.248&quot; metric=&quot;20&quot;/&gt;</source>
	<p><br />
		Говорит нам об оптимизации: <nobr>“<strong>10.0.0.0</strong>” &amp; “255.255.255.252” + 1 = “10.0.0.1”</nobr>  ..  <nobr>“10.0.0.0” | ~“255.255.255.252” = “10.0.0.3”</nobr>, т.е. маска включает все адреса других хостов сети, за исключением адреса текущего хоста (“10.0.0.4”).
	</p>
<hr /></spoiler>
<p><br />
	Более интересен конфиг, из которого получился этот дамп. Этот конфиг прописан прямо внутри “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/configurator/ipv4/IPv4NetworkConfigurator.ned#L416">IPv4NetworkConfigurator.ned</a>”:
</p>
<br /><source lang="xml">&lt;config&gt;&lt;interface hosts='**' address='10.x.x.x' netmask='255.x.x.x'/&gt;&lt;/config&gt;</source>
<p><br />
	Про “<code>x</code>” подробно написано в “inet-manual-draft.pdf” на 82-83 странице. Вкратце, “<code>x</code>” рассчитывается на основе количества устройств (точнее их интерфейсов) в сети, которым нужен IP. Для “<code>address</code>” вместо “<code>x</code>” подставляется номер текущего устройства, а “<code>x</code>” в “<code>netmask</code>” регулирует размер маски так, чтобы <a href="https://habrahabr.ru/post/129664">длина маски</a> была наибольшей для данной подсети. Например, маска “<code>255.x.x.0</code>” может принимать итоговые значения:
</p>
<br /><ul>
	<li>“255.255.255.0” (/24), если количество устройств ≤ 254 (256−2);</li>
	<li>от “255.255.254.0” (/23) по “255.0.0.0” (/8), если количество устройств лежит в диапазоне от 255 по 16777214 (16777216−2) соответственно;</li>
	<li>“error”, если количество устройств превышает 16777214.</li>
</ul>
<p><br />
	Про “<code>**</code>” уже писалось ранее (полная аналогия с <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:config-sim:asterisk-vs-double-asterisk">заданием параметров</a> и с <a href="https://git-scm.com/docs/gitignore#_pattern_format">Git</a>).
</p><p><br /><anchor>IPv4NetworkConfigurator-config</anchor>
	В нашем случае иерархии хостов нет, поэтому обойдемся “<code> hosts='*' </code>”. Остальные параметры: “<code> address='10.0.1.x' </code>”, “<code> netmask='255.255.255.0' </code>”. Конфиг с этими параметрами можно сохранить в файл “LLTR/simulations/config.xml”, и указать путь к нему в параметрах конфигуратора:
</p>
<br /><source lang="cpp">configurator: IPv4NetworkConfigurator {
    parameters:
        @display(&quot;p=62,31&quot;);
        config = xmldoc(&quot;config.xml&quot;);
        dumpConfig = &quot;config_dump.xml&quot;;
}</source>
<p><br /><anchor>git-tag-a1_v0-10-0</anchor>
	Должно получиться <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/commit/6ec637cf3d8e9a4de27c4d5a05ae5bd585972243">примерно так (git tag a1_v0.10.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.9.0...a1_v0.10.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-lang:xml-parameters"><code>xmldoc()</code></a>” нужен для загрузки xml из внешнего файла.
</p><p><br />
	После запуска симулятора появится <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.9.0...a1_v0.10.0#diff-03f33aa874def70bfa9a9b083d1fc6aa" title="diff между git tag a1_v0.10.0 и git tag a1_v0.9.0">новый дамп конфига</a>. Обратите внимание на отличия. Сохранилась прежняя маска в записях с метрикой “<code>0</code>”, а записи с метрикой “<code>20</code>” обновили маску на “<code>255.255.255.0</code>”. Выше, когда смотрели “<code>host0.<strong>routingTable</strong>.routes</code>”, можно было заметить, что запись с метрикой “<code>0</code>” подписана как “<code>DIRECT MANUAL</code>”, а метрика “<code>20</code>” как “<code>DIRECT IFACENETMASK</code>”. (<s>здесь был намек на спойлеры</s> ;-) )
</p><p><br />
	Генерация дампа конфига нам уже не нужна (все, что надо мы уже посмотрели), поэтому убираем из “package.ned” параметр “<code>dumpConfig</code>”. Также симулятор на карте сети не очень хорошо отображает “IP/mask” (надписи наползают друг на друга), поэтому отключим вывод надписей. На одном из предыдущих скриншотов симулятора был виден параметр “<code>displayAddresses</code>” у “<code>interfaceTable</code>”. Достаточно добавить строку “<code>**.interfaceTable.displayAddresses = false</code>” в “omnetpp.ini”, чтобы отключить вывод “IP/mask”.
</p><p><br /><anchor>git-tag-a1_v0-11-0</anchor>
	Должно получиться <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/commit/37b1512b5bb6c41a051293b9a2876931c980ac39">примерно так (git tag a1_v0.11.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.10.0...a1_v0.11.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>.
</p>
<br /><anchor>fig_IPv4NetworkConfigurator-network-clear</anchor><img alt="IPv4NetworkConfigurator: clear network" align="center" height="416" src="https://habrastorage.org/webt/gq/yu/zn/gqyuzndfrfxksatex7pqwpxvhom.png#IPv4NetworkConfigurator-network-clear.png"/>
<p align="center"><!-- очень не хватает align="center" для подписей к изображениям ( а также <figure> и <figcaption> http://htmlbook.ru/blog/elementy-figure-i-figcaption https://web-standards.ru/articles/figure-figcaption/#comment-683 ); справа - "креативный костыль"; альтернатива: поместить текст в SVG, и вставить его, используя <img alt="текст подписи" align="center" src=".svg"/> --><font color="#FFF"><sup>НЛО</sup><sub>прилетело</sub>и<sup>оставило</sup><sub>этот</sub><sup>пробел</sup><sub>здесь</sub>? </font>
	<em>Да будет чистота! А IP определим по номеру хоста+1.</em>
</p>
<br /><h4><anchor>a-kto-naznachaet-mac-adresa</anchor><a href="#a-kto-naznachaet-mac-adresa" title="Ссылка на раздел"><font color="gray">#</font></a> А кто назначает MAC адреса?</h4>
<p><br />
	Возможно, это делает “L2<strong>Network</strong>Configurator”? Однако, <a href="https://omnetpp.org/doc/inet/api-3.4.0/neddoc/index.html?p=inet.linklayer.configurator.L2NetworkConfigurator.html">по описанию</a>, он предназначен для <a href="https://omnetpp.org/doc/inet/api-3.4.0/neddoc/index.html?p=inet.examples.ieee8021d.SwitchNetwork.html">другого</a>:
</p>
<blockquote cite="https://omnetpp.org/doc/inet/api-3.4.0/neddoc/index.html?p=inet.linklayer.configurator.L2NetworkConfigurator.html">
	The STP and RSTP related parameters such as link cost, port priority and the &quot;is-edge&quot; flag...
</blockquote>
<p>
	Краткий ответ: никто. Точнее отдельного модуля, назначающего уникальные MAC адреса в INET нет.
</p><p><br />
	Попробуем найти то место в INET, в котором генерируются MAC адреса. <a href="#fig_switch-NED-Parameters" title="форсировали из-за того, что на свитчах по умолчанию используется “half duples CSMA/CD mac”">Ранее</a> мы форсировали использование “EtherMACFullDuplex” на всех узлах сети. Он и будет нашей отправной точкой.
</p><p><br />
	Посмотрим на метод “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/linklayer/ethernet/EtherMACFullDuplex.cc#L37"><code>initialize()</code></a>” (подробнее про его назначение, и про <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/common/InitStages.h">стадии инициализации</a> будет сказано ниже):
</p>
<br /><source lang="cpp">void EtherMACFullDuplex::initialize(int stage)
{
    EtherMACBase::initialize(stage);</source>
<p><br />
	Так как “EtherMACFullDuplex” <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/linklayer/ethernet/EtherMACFullDuplex.h#L33">наследуется</a> от “EtherMACBase”, то здесь просто вызывается аналогичный метод родителя. Заглянем в <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/linklayer/ethernet/EtherMACBase.cc#L152">него</a>. Здесь интересен <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/linklayer/ethernet/EtherMACBase.cc#L167">вызов</a> “<code>initializeMACAddress()</code>” → “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/linklayer/ethernet/EtherMACBase.cc#L219"><code>EtherMACBase::initializeMACAddress()</code></a>” → “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/linklayer/common/MACAddress.h#L195"><code>MACAddress::generateAutoAddress()</code></a>”.
</p><p><br />
	И так, мы <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/linklayer/common/MACAddress.cc#L143">дошли до места</a>, в котором генерируются уникальные MAC адреса. А сама генерация происходит <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/linklayer/ethernet/EtherMACBase.cc#L167">во время стадии “<code>INITSTAGE_LOCAL</code>”</a>.
</p>
<br /><h4><anchor>gde-esche-mozhno-posmotret-parametry-i-strukturu-moduley</anchor><a href="#gde-esche-mozhno-posmotret-parametry-i-strukturu-moduley" title="Ссылка на раздел"><font color="gray">#</font></a> Где еще можно посмотреть параметры и структуру модулей?</h4>
<p><br />
	Настройки визуализации любого элемента сети можно посмотреть (и настроить) в панели “Properties”:
</p>
<br /><anchor>fig_Properties-palette</anchor><img alt="Properties palette" align="center" height="353" src="https://habrastorage.org/webt/ed/t4/br/edt4br4lqoroipfrz-ss5cneeyg.png#Properties-palette.png"/>
<p><br />
	Либо через контекстное меню → “Properties…”:
</p>
<br /><anchor>fig_Properties-context_menu</anchor><img alt="Properties context menu" align="center" height="454" src="https://habrastorage.org/webt/en/a6/rx/ena6rxhdka9wp3uxq4nmybenkz0.png#Properties-context_menu.png"/>
<p><br />
	А по структуре (иерархии) модуля можно быстро пройтись в панели “Module Hierarchy”:
</p>
<br /><anchor>fig_Module_Hierarchy-palette</anchor><img alt="Module Hierarchy palette" align="center" height="353" src="https://habrastorage.org/webt/0i/ad/kb/0iadkb1cygem_echw2edrb3jxda.png#Module_Hierarchy-palette.png"/>
<br /><h3><anchor>shag-0-posylaem-unicast-probuem-ego-prinyat</anchor><a href="#shag-0-posylaem-unicast-probuem-ego-prinyat" title="Ссылка на раздел"><font color="gray">#</font></a> Шаг 0: посылаем unicast, пробуем его принять</h3>
<p><br />
	Наконец‑то, GUI с конфигами позади, и можно уже что‑нибудь накодить. Для того чтобы описать свою логику отправки и принятия UDP пакетов, нужно внутри INET написать два мини UDP‑приложения: первое будет отправлять пакеты, а второе – принимать их. Эти приложения будем запускать на разных хостах, например, на “host0” запустим приложение, отправляющее пакеты, а на всех остальных хостах – приложение, принимающее пакеты.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> внутренние элементы навигации в этом подразделе отключены, т.е. он линейный (последовательный), и не содержит в себе подразделов.
</p><p><br />
	Как было сказано <a href="#sozdanie-pervogo-proekta">выше</a> в <nobr>OMNeT++</nobr> “Network” (сеть) состоит из “Compound module” (host0), которые, в свою очередь, состоят из “Simple modules” (udpApp). Поэтому, чтобы создать новое UDP‑приложение (udpApp), нужно создать новый “Simple module”…
</p><p><br />
	… И все же придется вернуться в GUI, чтобы посмотреть место, в которое будет подключаться модуль UDP‑приложения. Раскроем “host0” (двойной клик):
</p>
<br /><anchor>fig_host0-StandardHost-udpApp</anchor><img alt="host0 StandardHost udpApp" align="center" height="1181" src="https://habrastorage.org/webt/lg/n9/1b/lgn91bd-u7jkd-6nqlz7kugymsw.png#host0-StandardHost-udpApp.png"/>
<p><br />
	Вот он этот модуль – “udpApp” (точнее вектор модулей “<code>udpApp[numUdpApps]</code>”), на месте которого и будет подключено наше UDP‑приложение.
</p><p><br />
	В том же разделе “<a href="#sozdanie-pervogo-proekta">Создание первого проекта</a>”, мы смотрели код готовых приложений (UDP Application) и примеров (broadcast), а также решили расположить код приложения LLTR рядом с кодом других приложений в INET (раздел “<a href="#struktura-proekta">Структура проекта</a>”). В свете этого, <strong>создадим</strong> директорию “inet/src/inet/applications/<strong>lltrapp</strong>”.
</p><p><br />
	Создадим приложение, отправляющее пакеты (LLTRSuperApp):
</p>
<br /><ol>
	<li>запустим Wizard (панель <nobr>“Project Explorer” &gt;</nobr> <nobr>проект “inet” &gt;</nobr> директория <nobr>“src/inet/applications/<strong>lltrapp</strong>” &gt;</nobr> <nobr>контекстное меню &gt;</nobr> <nobr>“New” &gt;</nobr> “Simple Module”)</li>
	<li>NED файл назовем “<code>LLTRSuperApp.ned</code>”</li>
	<li>В качестве шаблона (template) выберем “A simple module”.</li>
</ol>
<p><br />
	Попробуем сравнить то, что сгенерировал Wizard с готовым приложением “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/udpapp/UDPEchoApp.h">UDPEchoApp</a>”. Начнем с заголовочных файлов.
</p><p><br />
	Первое, что бросается в глаза – это то, что “UDPEchoApp” наследуется от “<code>ApplicationBase</code>”, а Wizard для “LLTRSuperApp” сгенерировал наследование от “<code>cSimpleModule</code>”. Попробуем пройти вверх (<kbd>Ctrl+Клик по классу‑родителю в редакторе кода</kbd>) по иерархии наследования, и посмотреть чем “<code>ApplicationBase</code>” отличается от “<code>cSimpleModule</code>”, и нужен ли он нам? Получится следующая картина: “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/base/ApplicationBase.h#L26"><code>ApplicationBase</code></a>” ← “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/common/lifecycle/OperationalBase.h#L25"><code>OperationalBase</code></a>” ← “<a href="https://omnetpp.org/doc/omnetpp/api/classomnetpp_1_1cSimpleModule.html"><code>cSimpleModule</code></a>” + “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/common/lifecycle/ILifecycle.h#L39-L40"><code><strong>ILifecycle</strong></code></a>”. В комментарии к “<code>ILifecycle</code>” сказано следующее:
</p>
<blockquote cite="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/common/lifecycle/ILifecycle.h#L39-L40">
	Interface to be implemented by modules that want to support failure/recovery, shutdown/restart, suspend/resume, and similar scenarios.
</blockquote>
<p>
	Получается, что если мы хотим моделировать эти сценарии, то должны наследоваться от “<code>ApplicationBase</code>”, если же они нам не нужны, то достаточно наследования от “<code>cSimpleModule</code>”. Эти сценарии нам не пригодятся, поэтому оставляем наследование от “<code>cSimpleModule</code>”.
</p><p><br /><anchor>git-tag-a1_v0-12-0</anchor>
	Осталось еще несколько несоответствий, после их устранения, объединения объявления с определением класса “LLTRSuperApp” (извне он нам не нужен), и создания модуля “LLTRApp” (путем копирования файлов “LLTRSuperApp” и замены имени) получилось <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/tree/a1_v0.12.0/inet/src/inet/applications/lltrapp">это (git tag a1_v0.12.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.11.0...a1_v0.12.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>.
</p>
<br /><spoiler title="Что делает строчка “Define_Module(LLTRSuperApp);” в коде?"><hr />
	<p>
		Вкратце: она регистрирует класс в качестве модуля, чтобы при использовании модуля “LLTRSuperApp” в сети, автоматически создавался экземпляр класса “LLTRSuperApp”.
	</p><p><br />
		Более подробно: “<code>Define_Module()</code>” – это макрос, который за 34 шага (Eclipse → навести указатель на название макроса → навести указатель на всплывающую подсказку; либо <kbd>Ctrl+#</kbd>; <kbd>Ctrl+Shift+3</kbd>) раскрывается в:
	</p>
	<br /><source lang="cpp">static omnetpp::cObject *__factoryfunc_43() {omnetpp::cModule *ret = new LLTRSuperApp; return ret; } \
  static void *__castfunc_43(omnetpp::cObject *obj) {return (void*)dynamic_cast&lt;LLTRSuperApp*&gt;(obj);} \
  namespace { \
    void __onstartup_func_43() {omnetpp::classes.getInstance()-&gt;add(new omnetpp::cObjectFactory(omnetpp::opp_typename(typeid(LLTRSuperApp)), __factoryfunc_43, __castfunc_43, &quot;module&quot;));;} \
    static omnetpp::CodeFragments __onstartup_obj_43(__onstartup_func_43, omnetpp::CodeFragments::STARTUP); \
  };</source>
	<p><br />
		Начну с конца. Конструктор “<code>omnetpp::CodeFragments</code>” (omnetpp-5.0/src/sim/onstartup.cc) добавляет “<code>__onstartup_obj_43</code>” в <a href="https://omnetpp.org/doc/omnetpp/api/onstartup_8h_source.html">односвязный список</a>. Затем, в определенный момент времени вызовется “<code>CodeFragments::executeAll()</code>” (omnetpp-5.0/src/sim/onstartup.cc), который пройдет по всему списку, начиная с “<code>CodeFragments::head</code>”, и вызовет “<code>__onstartup_func_43</code>”. А “<code>__onstartup_func_43()</code>” зарегистрирует новый модуль, и свяжет с ним две функции: “<code>__factoryfunc_43()</code>” – для создания экземпляра класса “LLTRSuperApp”, и “<code>__castfunc_43()</code>”.
	</p>
<hr /></spoiler>
<p><br />
	В <nobr>OMNeT++</nobr> для передачи сообщения от одного модуля к другому (через цепочку):
</p>
<br /><!-- nohighlight --><source lang="bash">Module1[gate$o]--&gt;--[channel]--&gt;--[gate$i]Module2</source>
<p><br />
	используется функция “<a href="https://omnetpp.org/doc/omnetpp/api/csimplemodule_8h_source.html#l00232"><code>send(‹отправляемое сообщение›, ‹“gate”, через который отправить сообщение›)</code></a>” (<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:sending-messages">примеры использования</a> из “Simulation Manual”). После отправки сообщения, его получит модуль на другом конце “channel”. А так как INET построен поверх <nobr>OMNeT++</nobr>, то мы не можем просто так взять “<code>send()</code>” и отправить сообщение на определенный unicast IP и порт.
</p>
<br /><anchor>fig_send-UDP</anchor><img alt="send() UDP" align="center" height="303" src="https://habrastorage.org/webt/ed/4g/dr/ed4gdr8b4djoyeh-1uwvgldppqe.jpeg#send-UDP.jpg"/>
<p><br />
	“<code>send()</code>” попросту не принимает на вход такие аргументы как IP и порт.
</p><p><br />
	Как же сформировать UDP пакет, и отправить его? На <a href="#fig_host0-StandardHost-udpApp">схеме “StandardHost” модуля</a> видно, что все “udpApp” подключаются к модулю “udp”. В <a href="https://omnetpp.org/doc/inet/api-3.4.0/neddoc/index.html?p=inet.transportlayer.udp.UDP.html">документации про модуль “UDP”</a> сказано следующее:
</p>
<blockquote cite="https://omnetpp.org/doc/inet/api-3.4.0/neddoc/index.html?p=inet.transportlayer.udp.UDP.html">
	<p>
		... For sending an UDP packet, the application should attach an UDPControlInfo object to the payload, and send it to UDP. UDP will also attach an UDPControlInfo object to any payload message in sends up to the application.
	</p><p><br />
		For receiving UDP packets, the connected applications should first &quot;bind&quot; to the given UDP port. This can be done by sending an arbitrary message with message kind UDP_C_BIND and an UDPControlInfo attached with srcPort filled in...
	</p><p><br />
		See also: ..., UDPCommandCode
	</p>
</blockquote>
<p><anchor>set-ttl-example_see-context</anchor>
	То есть, для отправки UDP пакета, нужно посылать сообщение в модуль “udp” с просьбой отправить пакет… И для совершения любых других операций нужно отправлять сообщения с просьбами в модуль “udp”.
</p><p><br /><anchor>set-ttl-example</anchor>
	Например, нам надо задать TTL, как это сделать? Как‑то так:
</p>
<br /><ol>
	<li>создать новый “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:sending-and-receiving"><code>cMessage</code></a>”, и указать в качестве “<a href="https://omnetpp.org/doc/omnetpp/manual/#cha:messages">Message kind</a>” значение “<a href="https://omnetpp.org/doc/inet/api-3.4.0/neddoc/index.html?p=src-inet-transportlayer-contract-udp-UDPCommandCode.html"><code>UDP_C_SETOPTION</code></a>” (“UDPCommandCode”);</li>
	<li>в качестве контрольной информации добавить к сообщению “UDPControlInfo” (точнее “UDPSetOptionCommand”, точнее “<code>UDPSetTimeToLiveCommand</code>”) с указанием желаемого значения TTL, и некоторой другой информации;</li>
	<li>и, наконец, отправить получившееся сообщение при помощи “<code>send()</code>”.</li>
</ol>
<p><br />
	И как же понять, что нужно делать именно так? Это “очень просто”:
</p>
<br /><ol>
	<li>находим исходники “udp” модуля – “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.cc">inet/src/inet/transportlayer/udp/UDP.cc</a>”;</li>
	<li>находим функцию, <a href="https://omnetpp.org/doc/omnetpp/api/classomnetpp_1_1cSimpleModule.html">обрабатывающую входящие сообщения</a> (подробнее про обработку сообщений я напишу чуть ниже) – “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.cc#L149"><code>handleMessage()</code></a>”;</li>
	<li>ходим по <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.cc#L165">веткам</a> → “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.cc#L183"><code>processCommandFromApp()</code></a>” → “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.cc#L204"><code>case UDP_C_SETOPTION</code></a>” –[доходим до ужаса, состоящего из “else-if-dynamic_cast”]→ “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.cc#L209"><code>((UDPSetTimeToLiveCommand *)ctrl)-&gt;getTtl()</code></a>” → “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.cc#L836"><code>setTimeToLive()</code></a>”.</li>
</ol>
<p><br />
	Ах, да, чуть не забыл про иерархию наследования (советую обратить внимание на комментарии к коду): “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/udp/UDPControlInfo.msg#L182"><code>UDPSetTimeToLiveCommand</code></a>” ← “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/udp/UDPControlInfo.msg#L170"><code>UDPSetOptionCommand</code></a>” ← “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/udp/UDPControlInfo.msg#L67"><code>UDPControlInfo</code></a>”. Вот только код совсем не похож на <nobr>C++</nobr>, и файл имеет расширение “.msg”.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> Файлы “.msg” – это очень удобная вещь в <nobr>OMNeT++</nobr>, они позволяют в простом виде описать структуру пакета/сообщения. Из этих файлов <nobr>OMNeT++</nobr> создаст “*_m.h” и “*_m.cc” файлы со всей необходимой обвязкой. Подробнее про “.msg” файлы напишу, когда будем создавать свой “.msg” файл.
</p><p><br />
	Если опять взглянуть на документацию (“inet-manual-draft.pdf”; раздел 13.2 “The UDP module”, страница 96), то найдем подтверждение нашим “блужданиям” по коду:
</p>
<blockquote cite="https://omnetpp.org/doc/inet/api-3.4.0/inet-manual-draft.pdf">
	The UDP module can be connected to several applications, and each application can use several sockets to send and receive UDP datagrams. The state of the sockets are stored within the UDP module and the application can configure the socket by sending command messages to the UDP module. These command messages are distinguished by their kind and the type of their control info. The control info identifies the socket and holds the parameters of the command.
</blockquote>
<p>
	Это все отличается от того, как мы привыкли работать с сетью (через сокеты) в прикладных программах внутри <abbr title="Операционной системы">ОС</abbr>. Однако, если прочесть чуть дальше “inet-manual-draft.pdf”; раздел 13.2 “The UDP module”, страница 96):
</p>
<blockquote cite="https://omnetpp.org/doc/inet/api-3.4.0/inet-manual-draft.pdf">
	Applications don’t have to send messages directly to the UDP module, as they can use the UDPSocket utility class, which encapsulates the messaging and provides a socket like interface to applications.
</blockquote>
<p>
	Аллилуйя! Можем работать с сетью привычным способом (“inet-manual-draft.pdf”; раздел 13.3 “UDP sockets”, страница 98)! Именно этим способом работают с сетью стандартные “UDP applications”, например, “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/udpapp/UDPEchoApp.cc#L63">UDPEchoApp</a>”:
</p>
<br /><source lang="cpp">socket.sendTo(pk, srcAddress, srcPort);</source>
<p><br />
	Вернемся к нашим программам, и начнем с “LLTRSuperApp”. Как было написано выше, для работы с UDP сокетами нужно создать экземпляр класса “<code>UDPSocket</code>”, добавим его в наш класс (в виде поля):
</p>
<br /><source lang="cpp">class INET_API LLTRSuperApp: public cSimpleModule
{
       UDPSocket socket;</source>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> почему я везде пишу “экземпляр класса *”, а не “объект класса *” – чтобы <a href="https://ru.stackoverflow.com/a/167521">ни у кого</a> <a href="https://ru.stackoverflow.com/a/2724">не возникало</a> <a href="https://ru.stackoverflow.com/a/519462">путаницы</a>.
</p><p><br />
	Что сделаем далее:
</p>
<br /><ol>
	<li>настроим сокет;</li>
	<li>отправим “пустой” пакет одному из хостов в сети;</li>
	<li>закроем сокет.</li>
</ol>
<p><br />
	В <nobr>OMNeT++</nobr> настройкой чего либо (в данном случае сокета) лучше заниматься во время инициализации модуля. Выше, в разделе “<a href="#a-kto-naznachaet-mac-adresa">А кто назначает MAC адреса?</a>”, упоминался <a href="https://omnetpp.org/doc/omnetpp/api/classomnetpp_1_1cSimpleModule.html">метод “<code>initialize()</code>”</a> – <nobr>OMNeT++</nobr> вызывает его несколько раз для инициализации модуля.
</p><p><br />
	Зачем вызывать “<code>initialize()</code>” несколько раз? Почему одного раза недостаточно для инициализации модуля? Между модулями могут быть циклические зависимости (например, первому модулю, для инициализации, нужны данные из второго модуля, а второй модуль, в свою очередь, ждет пока первый модуль инициализируется, чтобы получить из него нужные данные для своей инициализации – так появляются циклические зависимости), чтобы их обойти, <nobr>OMNeT++</nobr> использует несколько стадий инициализации. Предполагается, что внутри одной стадии, циклических зависимостей не будет. Количество стадий не фиксировано – каждый модуль, переопределяя метод “<code>numInitStages()</code>” <a href="https://omnetpp.org/doc/omnetpp/api/classomnetpp_1_1cSimpleModule.html">задает необходимое ему количество стадий</a>:
</p>
<blockquote cite="https://omnetpp.org/doc/omnetpp/api/classomnetpp_1_1cSimpleModule.html">
	Multi-stage initialization can be achieved by redefining the initialize(int stage) method instead, and also redefining the numInitStages() const method to return the required number of stages.
</blockquote>
<p>
	<font color="#54524F"><b>Note</b>:</font> более подробно про “<code>numInitStages()</code>”, и про то, почему этот метод обязательно должен быть “<a href="https://ru.wikipedia.org/wiki/Чистота_функции?stable=1#Побочные_эффекты_функции">чистой функцией</a>” (<a href="http://alenacpp.blogspot.ru/2005/09/const-2.html">модификатор const</a>), написано в “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:multi-stage-init">Simulation Manual</a>”.
</p><p><br />
	Однако, в INET задано фиксированное число стадий. Все стадии и их описания перечислены в файле “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/common/InitStages.h">inet/src/inet/common/InitStages.h</a>”.
</p><p><br />
	Как выбрать нужную стадию для инициализации каждого из компонентов модуля? Правила простые:
</p>
<br /><ol>
	<li>выбираем наименьшую (по номеру) стадию;</li>
	<li>если для компонента модуля нужны данные из внешних модулей (либо нужны данные других компонент текущего модуля), то все эти данные должны быть готовы (проинициализированы) на предыдущих стадиях (относительно выбранной стадии);</li>
	<li>лучше выбирать стадию исходя из ее предназначения.</li>
</ol>
<p><br />
	Так, например, для приложений, лучше всего использовать стадии:
</p>
<br /><ul>
	<li><em>INITSTAGE_LOCAL</em> – для инициализации всего, что не зависит от других модулей (например, в будущем, на этой стадии мы будем считывать настройки модуля, заданные через “.ini” и “.ned” файлы);</li>
	<li><em>INITSTAGE_APPLICATION_LAYER</em> – для инициализации всего, что зависит от внешних модулей, именно на этой стадии “запускается” приложение;</li>
	<li><em>INITSTAGE_LAST</em> – для вывода надписей в GUI, и для планирования отправки (функция “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:self-messages"><code>scheduleAt()</code></a>”) первых пакетов в сеть.</li>
</ul>
<p><br />
	Наша функция “<code>initialize()</code>” будет выглядеть так:
</p>
<br /><source lang="cpp">void initialize(int stage)
{
       cSimpleModule::initialize(stage);

       switch(stage){
       case <em>INITSTAGE_APPLICATION_LAYER</em>:
             socket.setOutputGate(gate(&quot;<strong>udpOut</strong>&quot;));
             socket.setTimeToLive(1);

             break;
       case <em>INITSTAGE_LAST</em>:
             socket.sendTo(new cPacket(&quot;=Packet name=&quot;), IPv4Address(10,0,1,4), 1100);

             break;
       }
}</source>
<p><br />
	Вначале не забываем про инициализацию “родителей”: “<code>cSimpleModule::initialize(stage);</code>”.
</p><p><br />
	Затем, на стадии <em>INITSTAGE_APPLICATION_LAYER</em>, используя функцию “<code>setOutputGate()</code>”, задаем для сокета “gate”, через который будут отправляться сообщения. Функция принимает один параметр – адрес объекта (класс “cGate”). Адрес можно получить, использую функцию “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:accessing-gates-by-name"><code>gate(‹имя нужного gate›)</code></a>”.
</p><p><br />
	И так, как у нашего модуля пока что нет ни одного “gate”, то пора их добавить (в файл “LLTRSuperApp.ned”):
</p>
<br /><source lang="cpp">simple LLTRSuperApp
{
    parameters:
        @display(&quot;i=block/app&quot;);
    gates:
        input  udpIn  @labels(UDPControlInfo/up);
        output <strong>udpOut</strong> @labels(UDPControlInfo/down);
}</source>
<p><br />
	И, заодно, мы назначили модулю иконку приложения “<code>&quot;i=block/app&quot;</code>”.
</p><p><br />
	Далее, в <em>INITSTAGE_APPLICATION_LAYER</em>, назначаем TTL (“<code>setTimeToLive()</code>”), для всех пакетов, отправленных через этот сокет. Это получилось сделать намного проще, чем <a href="#set-ttl-example_see-context">описывалось ранее</a>, однако <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/udp/UDPSocket.cc#L131">внутри</a> все происходит именно так, как описывалось. В нашей сети нет маршрутизаторов (или любых других промежуточных узлов, уменьшающих TTL), поэтому TTL 1 должно хватить для доставки пакетов на любой хост в сети. Если какой‑либо пакет не дойдет, из‑за достижения TTL нуля, то это будет указывать на ошибку в конфигурировании модели/сети/модулей.
</p><p><br />
	Настало время отправить “пустой” пакет! Пакет отправляется на стадии <em>INITSTAGE_LAST</em>, при помощи функции “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/udp/UDPSocket.cc#L88"><code>sendTo(‹пакет›, ‹IP-адрес назначения›, ‹порт назначения›)</code></a>”. Так как стадия <em>INITSTAGE_LAST</em> идет после стадии <em>INITSTAGE_APPLICATION_LAYER</em>, то мы можем гарантировать, что все приложения уже инициализировались, и могут обрабатывать входящие сообщения. Однако, в реальных программах/модулях лучше не отправлять пакет сразу в <em>INITSTAGE_LAST</em>, а использовать “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:self-messages"><code>scheduleAt()</code></a>”, чтобы запланировать его отправку на время начала симуляции. Но и такой простой вариант тоже работает ：）
</p><p><br />
	Создать “пустой” пакет очень легко: `<code>new <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:msgs:cpacket">cPacket(&quot;‹имя пакета›&quot;)</a></code>`. Важно помнить, что “‹имя пакета›” – это всего лишь имя, которым будет помечен пакет, при отображении в логе Qtenv. Созданный таким способом пакет пуст! Подробнее про cPacket и его отличия от cMessage можно почитать в “<a href="https://omnetpp.org/doc/omnetpp/manual/#cha:messages">Simulation Manual</a>”.
</p><p><br />
	Адрес назначения тоже легко указать – это можно сделать через <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/common/L3Address.h#L63">конструкторы “L3Address”</a>, либо напрямую, через <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/contract/ipv4/IPv4Address.h#L130-L133">конструкторы “IPv4Address”</a>. Выше, в разделе “Назначение IP адресов устройствам в сети”, <a href="#configure-IPv4NetworkConfigurator">настраивался “IPv4NetworkConfigurator”</a> на назначение адресов, начиная с “<a href="#IPv4NetworkConfigurator-config">10.0.1.1</a>”, поэтому указанный IP “<code>IPv4Address(10,0,1,4)</code>” – это адрес одного из 4‑х хостов в сети.
</p><p><br />
	Пакет отправлен, и осталось закрыть сокет. Возможно, в будущем, нам понадобится отправить еще несколько пакетов через этот сокет, поэтому не будем его сразу закрывать, а закроем в методе “<code>finish()</code>”:
</p>
<br /><source lang="cpp">void finish()
{
       socket.close();

       cSimpleModule::finish();
}</source>
<p><br />
	Этот метод вызывается при успешном завершении симуляции модели. Здесь важно заметить, что при запуске симуляции – создаются объекты моделей (вызываются конструкторы), а при завершении симуляции – объекты уничтожаются (вызываются деструкторы). Так чем “<code>finish()</code>” отличается от деструктора? Тем, что “<code>finish()</code>” вызывается только тогда, когда симуляция завершилась без ошибок (причиной завершения симуляции не является ошибка), а деструктор вызывается всегда. Поэтому “<code>finish()</code>” чаще всего используют для вывода собранной статистики за время симуляции, а деструктор для “очистки” объекта. Поэтому логичным было бы расположить “<code>socket.close()</code>” именно в деструкторе, но это очень плохая идея. Если вспомнить, что все методы в “UDPSocket” – это всего лишь “обвертки” для отправки сообщений, и добавить к этому информацию из раздела “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:init-finish:basic-usage">Initialization and Finalization</a>” и раздела “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:init-finish:invocation-order">Invocation Order</a>” в “Simulation Manual”:
</p>
<blockquote cite="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:init-finish:invocation-order"><anchor>close-socket-in-finish_conclusion_see-context</anchor>
	The finish() functions are called when <strong>the event loop has terminated</strong>, and only if it terminated normally.
</blockquote>
<p><anchor>close-socket-in-finish_conclusion</anchor>
	То становится ясно, что закрывать сокет в “<code>finish()</code>”, и тем более в деструкторе, – бесполезно, т.к. “по документации” цикл обработки событий уже будет разрушен.
</p><p><br />
	И так, мы уже:
</p>
<br /><ol>
	<li>[x] настроили сокет;</li>
	<li>[x] отправили “пустой” пакет одному из хостов в сети;</li>
	<li>[x] закрыли сокет.</li>
</ol>
<p><br />
	Похоже, с “LLTRSuperApp” мы уже закончили, и пора переходить к “LLTRApp”.
</p><p><br />
	Что будем делать в “LLTRApp”:
</p>
<br /><ol>
	<li>настроем сокет на прослушивание порта;</li>
	<li>при получении пакета – выведем в лог сообщение с именем пришедшего пакета;</li>
	<li>закроем сокет.</li>
</ol>
<p><br />
	Но перед этим, также как и в “LLTRSuperApp”, добавим экземпляр класса “<code>UDPSocket</code>”:
</p>
<br /><source lang="cpp">class INET_API LLTRApp: public cSimpleModule
{
       UDPSocket socket;</source>
<p><br />
	Привяжем сокет к порту 1100, при помощи функции “<code>bind()</code>”, на стадии <em>INITSTAGE_APPLICATION_LAYER</em>:
</p>
<br /><source lang="cpp">void initialize(int stage)
{
       cSimpleModule::initialize(stage);

       switch(stage){
       case <em>INITSTAGE_APPLICATION_LAYER</em>:
             socket.bind(1100);

             break;
       }
}</source>
<p><br /><anchor>LLTRApp-wo-output-gate</anchor>
	А так как, в “LLTRApp” мы будем только принимать пакеты (отправлять ничего не будем), то отпадает необходимость в указании выходного “gate” функцией “<code>setOutputGate()</code>”. При этом, все входящие пакеты будут автоматически отправлены <a href="#fig_host0-StandardHost-udpApp">модулем “udp”</a> на наш входной “gate”, и мы сможем обработать их в методе “<code>handleMessage()</code>”.
</p><p><br />
	Кстати, про входной и выходной “gate” – в “LLTRSuperApp” мы их добавляли в описание модели (“.ned” файл), пора сделать то же самое и для “LLTRApp” (в файле “LLTRSuperApp.ned”):
</p>
<br /><source lang="cpp">simple LLTRApp
{
    parameters:
        @display(&quot;i=block/app&quot;);
    gates:
        input  udpIn  @labels(UDPControlInfo/up);
        output udpOut @labels(UDPControlInfo/down);
}</source>
<p><br />
	С настройкой сокета закончили. Теперь надо ожидать прибытия пакета, и, при его получении, вывести в лог сообщение с его именем.
</p><p><br />
	Выше я несколько раз упоминал про функцию‑обработчик входящих сообщений, пора познакомится с ней поближе. В <nobr>OMNeT++</nobr>, на самом деле, существует не одна, а целых две функции для обработки сообщений: <a href="https://omnetpp.org/doc/omnetpp/api/classomnetpp_1_1cSimpleModule.html">“<code>handleMessage()</code>” и “<code>activity()</code>”</a>, в пределах одного модуля можно одновременно использовать только одну из них. Посмотрим что написано в документации про “<code>handleMessage()</code>”:
</p>
<blockquote cite="https://omnetpp.org/doc/omnetpp/api/classomnetpp_1_1cSimpleModule.html">
	One has to redefine handleMessage() to contain the internal logic of the module. handleMessage() is called by the simulation kernel when the module receives a message.
</blockquote>
<p>
	И про “<code>activity()</code>”:
</p>
<blockquote cite="https://omnetpp.org/doc/omnetpp/api/classomnetpp_1_1cSimpleModule.html">
	An alternative to handleMessage() is activity(), but activity() is not recommended for serious model development because of scalability and debugging issues. activity() also tends to lead to messy module implementations.
</blockquote>
<p>
	Они явно не рекомендуют использовать “<a href="https://omnetpp.org/doc/omnetpp/api/classomnetpp_1_1cSimpleModule.html#a517a5ef25204490292b84fa5bdd12288"><code>activity()</code></a>”:
</p>
<blockquote cite="https://omnetpp.org/doc/omnetpp/api/classomnetpp_1_1cSimpleModule.html#a517a5ef25204490292b84fa5bdd12288">
	Should be redefined to contain the module activity function.<br />
	For several good reasons, you should prefer handleMessage() to activity().
</blockquote>
<p>
	А также (из “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:handlemessage:application-area">Simulation Manual</a>”):
</p>
<blockquote cite="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:handlemessage:application-area">
	<p>
		handleMessage() is in most cases a better choice than activity():
	</p><p><br />
		- When you expect the module to be used in large simulations, involving several thousand modules. In such cases, the module stacks required by activity() would simply <strong>consume too much memory</strong>.
	</p><p><br />
		- For modules which maintain little or no state information, such as packet sinks, handleMessage() is more convenient to program.
	</p><p><br />
		- Other good candidates are modules with a large state space and many arbitrary state transition possibilities (i.e. where there are many possible subsequent states for any state). Such algorithms are difficult to program with activity(), and better suited for handleMessage() (see rule of thumb below). This is the case for most communication protocols.
	</p>
</blockquote>
<p>
	В свое время, все эти доводы привели к “слепому” использованию “<code>handleMessage()</code>” вместо “<code>activity()</code>”.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> сейчас я думаю иначе – скорее всего, если бы я использовал “<code>activity()</code>”, то создание модели LLTR заняло бы намного меньше времени…
</p><p><br />
	Как происходит обработка событий при использовании “<code>handleMessage()</code>”?:
</p>
<br /><ol>
	<li>пакет приходит;</li>
	<li>в функции “<code>handleMessage()</code>” он обрабатывается;</li>
	<li>функция возвращает управление.</li>
</ol>
<p><br />
	Если нужно сохранить результаты обработки, либо сохранить определенное “состояние”, то надо создавать дополнительные поля в классе для хранения всего этого. С течением времени полей становится все больше и больше, и что самое неприятное – часть из этих полей используется только на небольшом промежутке работы “программы” (для передачи состояния от одного вызова “<code>handleMessage()</code>” к другому). Это усугубляется тем, что все, по сути разные, сообщения приходят через одно место – “<code>handleMessage()</code>”. В реальной программе я бы мог, для каждого типа сообщения, зарегистрировать свой обработчик, но не здесь… В этот момент появляются мысли про создание новых классов, либо про использование <a href="https://habrahabr.ru/post/244573">этого</a>, либо <a href="https://habrahabr.ru/post/244497/#comment_8153525">этого</a>. И код попеременно превращается <a href="https://ru.wikipedia.org/wiki/Спагетти-код?stable=1#Связанные_понятия">то в спагетти, то в лазанью, то в равиоли</a>, и становится более запутанным чем сам INET. И, <a href="https://habrahabr.ru/post/252467/#comment_8319817">наконец</a>, происходит <a href="https://habrahabr.ru/post/187154">откат к более простому</a> первоначальному виду.
</p><p><br />
	Ладно, я забежал слишком далеко вперед, а пока наденем <s>розовые очки</s> <a href="https://ru.wikipedia.org/wiki/We_Happy_Few?stable=1">белую маску и примем Joy pill</a>.
</p><p><br />
	Однажды нелегкая завела меня в “подвал” файла “<a href="https://omnetpp.org/doc/omnetpp/api/csimplemodule_8h_source.html#l00459">omnetpp-5.0/include/omnetpp/csimplemodule.h</a>” (doxygen убирает <a href="https://omnetpp.org/doc/omnetpp/api/classomnetpp_1_1cSimpleModule.html#a228ebdbab08c537d22aa5354c34f6be0">комментарии</a> из кода), а затем в “<a href="https://omnetpp.org/doc/omnetpp/api/ccoroutine_8h_source.html">omnetpp-5.0/include/omnetpp/ccoroutine.h</a>” (<a href="https://omnetpp.org/doc/omnetpp/api/classomnetpp_1_1cCoroutine.html">комментарии</a>), и стало ясно, что “<code>activity()</code>” основаны на <a href="https://en.wikipedia.org/wiki/Fiber_(computer_science)?stable=1">fibers</a><a href="https://www.slideshare.net/sermp/novosib">/</a><a href="https://ru.wikipedia.org/wiki/Сопрограмма?stable=1">сопрограммах</a>.
</p><p><br />
	Как происходит обработка событий при использовании “<code>activity()</code>”?:
</p>
<br /><ol>
	<li>пакет приходит и функция “<code>activity()</code>” “размораживается”;</li>
	<li>функция обрабатывает пакет;</li>
	<li>функция “замораживается”.</li>
</ol>
<p><br />
	Все результаты обработки, и “состояния” можно хранить в локальных переменных функции (ровно также, как и в языках, поддерживающих “синхронно‑асинхронное” программирование “из коробки”, например <a href="https://golang.org">Go</a>). Однако предупреждения по поводу <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:activity:pros-and-cons">повышенного использования памяти</a> были даны не зря:
</p>
<blockquote cite="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:activity:pros-and-cons">
	<p>
		- limited scalability: coroutine stacks can unacceptably <strong>increase the memory requirements</strong> of the simulation program if you have several thousands or ten thousands of simple modules;
	</p><p><br />
		- run-time overhead: switching between coroutines is somewhat slower than a simple function call
	</p><p><br />
		- does not enforce a good programming style: using activity() tends to lead to unreliable, spaghetti code
	</p>
</blockquote>
<p>
	Если не контролировать размер стека, то симуляция “съест” много памяти. Есть несколько практик позволяющих уменьшить используемое место на стеке (все они связаны с использованием <a href="https://ru.wikipedia.org/wiki/Область_видимости?stable=1#Си">области видимости “<code>{}</code>”</a>):
</p>
<br /><ol>
	<li>максимально ограничить время жизни (область видимости) временных переменных, заключая их в “<code>{}</code>”;</li>
	<li>если обработка проходит в несколько стадий, то создать иерархию областей видимости: на верхнем уровне – те переменные, которые используются во всех стадиях, уровень ниже для переменных, нужных для определенной стадии (каждая стадия имеет свою область видимости);</li>
	<li>точки “заморозки/разморозки” лучше располагать в местах наименьшего использования стека, т.е. ближе к верхнему уровню иерархии областей видимости.</li>
</ol>
<p><br />
	В “Simulation Manual” написано еще несколько полезных вещей про “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:handlemessage"><code>handleMessage()</code></a>” и “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:activity"><code>activity()</code></a>”, например, <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:module-ctor">как переключится с “<code>handleMessage()</code>” на “<code>activity()</code>”</a>, но, а мы идем дальше.
</p><p><br />
	Наша функция “<code>handleMessage()</code>”, для вывода в лог имени пришедшего пакета, выглядит так:
</p>
<br /><source lang="cpp">void handleMessage(cMessage *msg)
{
       switch(msg-&gt;getKind()){
       case <em>UDP_I_DATA</em>:{
             EV &lt;&lt; &quot;Arrived: &quot; &lt;&lt; msg-&gt;getName() &lt;&lt; endl;
             delete msg;

       }break;
       case <em>UDP_I_ERROR</em>:{
             EV_WARN &lt;&lt; &quot;Ignoring UDP error report&quot; &lt;&lt; endl;
             delete msg;

       }break;
       default: throw cRuntimeError(&quot;Unrecognized message (%s)%s&quot;, msg-&gt;getClassName(), msg-&gt;getName());
       }
}</source>
<p><br />
	Вначале смотрим на “kind” сообщения. В UDP пакетах, “kind” может иметь только <a href="https://omnetpp.org/doc/inet/api-3.4.0/neddoc/index.html?p=src-inet-transportlayer-contract-udp-UDPStatusInd.html">2 значения</a>:
</p>
<br /><ul>
	<li><a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/udp/UDPControlInfo.msg#L53"><em>UDP_I_DATA</em></a> (0) – пришли данные;</li>
	<li><a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/udp/UDPControlInfo.msg#L54"><em>UDP_I_ERROR</em></a> (1) – <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.ned#L41-L43">пришла ошибка по ICMP</a>, это сообщение создается в методе “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.cc#L465"><code>processICMPError()</code></a>” и “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.cc#L730"><code>sendUpErrorIndication()</code></a>”.</li>
</ul>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> “kind” – это <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:msgs:overview">всего лишь некоторое целое число</a>, которое можно присвоить сообщению. Отрицательные значения зарезервированы под внутренние нужды <nobr>OMNeT++</nobr>, а все положительные (включая 0) можно свободно использовать для любых целей. Обычно его используют для задания типа/вида/предназначения конкретного сообщения.
</p><p><br />
	Для вывода сообщения в лог Qtenv используется поток “<code>EV</code>”, а для получения имени пришедшего пакета – метод “<code>getName()</code>”.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> “<code>EV</code>” – это на самом деле макрос, <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:sim-lib:log-statements">который раскрывается в “<code>EV_INFO</code>”</a>, который опять же является макросом…
</p><p><br />
	В конце (перед выходом из функции “<code>handleMessage()</code>”) нужно обязательно освободить память, удалив пришедшее сообщение (“<code>delete msg</code>”), иначе мы получим утечку памяти.
</p>
<br /><spoiler title="Почему произойдет утечка памяти?"><hr />
	<p>
		Сообщение (пакет) создавался в “LLTRSuperApp” при помощи вызова `<code>new cPacket(&quot;=Packet name=&quot;)</code>` (выделилась память под его хранение). Теперь сообщение пришло в “LLTRApp”, и так как мы не собираемся его перенаправлять в другое место, то следует освободить занимаемую им память (“<code>delete msg</code>”).
	</p><p><br />
		Если этого не делать, то в памяти накопятся куча уже доставленных, обработанных, но не удаленных сообщений/пакетов… Не у всех есть рабочие станции с 128 GiB оперативки для запуска симуляции. Поэтому все, что не нужно, лучше сразу удалять ：）
	</p>
<hr /></spoiler>
<p><br />
	Если “kind” не равен <em>UDP_I_DATA</em> и не равен <em>UDP_I_ERROR</em>, то бросаем исключение “<code>throw cRuntimeError()</code>”. Это может случиться если:
</p>
<br /><ul>
	<li>INET обновится, при этом, в UDP добавят еще несколько “kind”, а наш “<code>handleMessage()</code>” про них не знает;</li>
	<li>придет не UDP пакет/сообщение, у которого значение “kind” будет больше 1, либо меньше 0 (если придет не UDP пакет с “kind” равным 0 или 1, то <strong>исключение не будет сгенерировано</strong>, к сожалению…)</li>
</ul>
<p><br />
	Обратите внимание, что в каждом “<code>case</code>” создается своя область видимости (“<code>{}</code>”) – это нам пригодится в будущем.
</p><p><br />
	С выводом в лог сообщения мы закончили, осталось закрыть сокет. Сделаем это так же, как и в “LLTRSuperApp”:
</p>
<br /><source lang="cpp">void finish()
{
       socket.close();

       cSimpleModule::finish();
}</source>
<p><br /><anchor>git-tag-a1_v0-13-0</anchor>
	Посмотрим, что получилось <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/commit/8eae76045c212f915c3d0c86743945a435ab2f94">(git tag a1_v0.13.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.12.0...a1_v0.13.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>. Собираем INET, <a href="#probnyy-zapusk">запускаем</a>.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> если открыт один из файлов INET (например, “LLTRSuperApp.*” или “LLTRApp.*”), и этот файл находится в фокусе, то для сборки INET достаточно нажать “<kbd>Ctrl+B</kbd>” (<strong>предварительно</strong> воспользовавшись <a href="https://codeyarns.com/2013/09/29/build-project-keyboard-shortcut-in-eclipse-cdt/">этим советом</a>).
</p><p><br />
	И жмем на “Run”:
</p>
<br /><anchor>fig_qtenv-run</anchor><img alt="qtenv: run with full animation (F5)" align="center" height="89" src="https://habrastorage.org/webt/ff/ez/wa/ffezwau7yjdminy8u6ck9sarx-q.png#qtenv-run.png"/>
<p><br />
	Хммм… Ничего не произошло…
</p>
<br /><anchor>fig_qtenv-noApp-noEvents-macOS_style</anchor><img alt="qtenv: no App, no Events (macOS style)" align="center" height="336" src="https://habrastorage.org/webt/x8/rb/ky/x8rbky2i03unyn9mrw8hoqqr2c0.png#qtenv-noApp-noEvents-macOS_style.png"/>
<p><br />
	Так, а как симулятор поймет, что на хостах надо запускать “LLTRSuperApp” и “LLTRApp”, а не, например, “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/udpapp/UDPEchoApp.h">UDPEchoApp</a>”? Мы же нигде не указали, какой конкретный “udpApp” хотим запустить на хостах…<br />
	Посмотрим, из чего сейчас состоит “host0”, и есть ли в нем хоть один “udpApp”:
</p>
<br /><anchor>fig_qtenv-host0-noUdpApp</anchor><img alt="qtenv: host0 – no UdpApp" align="center" height="650" src="https://habrastorage.org/webt/re/p-/ke/rep-keqsfzpx1fh0bvogpwjfh9g.png#qtenv-host0-noUdpApp.png"/>
<p><br />
	Как и предполагалось, “udpApp” отсутствуют, и параметр “<code>numUdpApps</code>” равен 0.<br />
	А как сейчас выглядит схема “host0”? (двойной клик по “host0”):
</p>
<br /><anchor>fig_qtenv-in_host0-noUdpApp</anchor><img alt="qtenv: in host0 – no UdpApp" align="center" height="454" src="https://habrastorage.org/webt/px/wy/dy/pxwydydsaus7okijha8hgdzwoz4.png#qtenv-in_host0-noUdpApp.png"/>
<p><br />
	В нем не только отсутствуют “udpApp”, но и самого модуля “udp” тоже нет. Сравните эту “похудевшую” схему с <a href="#fig_host0-StandardHost-udpApp">изначальной схемой модуля “StandardHost”</a>.
</p><p><br />
	Как привязать “LLTRSuperApp” и “LLTRApp” к хостам? Посмотрим, как это сделано в “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/examples/inet/broadcast/omnetpp.ini#L5">UDPBroadcastNetwork</a>”:
</p>
<br /><source lang="ini">**.client.numUdpApps = 1
**.client.udpApp[0].typename = &quot;UDPBasicApp&quot;</source>
<p><br />
	И, заодно, заглянем в “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/node/inet/StandardHost.ned#L52">StandardHost.ned</a>”:
</p>
<br /><source lang="cpp">int numUdpApps = default(0);  // no of UDP apps. Specify the app types in INI file with udpApp[0..1].typename=&quot;UDPVideoStreamCli&quot; syntax</source>
<p><br />
	Получается, чтобы привязать “udpApp” к хосту – надо задать “<code>numUdpApps</code>” и “<code>udpApp[0].typename</code>”.
</p><p><br />
	А что делать, если надо, например, к “host0” привязать “LLTRSuperApp”, а ко всем остальным хостам – “LLTRApp”? Неужели придется для каждого хоста копипастить практически одинаковую строчку?:
</p>
<br /><source lang="ini">**.host?.numUdpApps = 1
**.host0.udpApp[0].typename = &quot;inet.applications.lltrapp.LLTRSuperApp&quot;
**.host1.udpApp[0].typename = &quot;inet.applications.lltrapp.LLTRApp&quot;
**.host2.udpApp[0].typename = &quot;inet.applications.lltrapp.LLTRApp&quot;
**.host3.udpApp[0].typename = &quot;inet.applications.lltrapp.LLTRApp&quot;</source>
<p><br />
	Что на этот счет сказано в “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:config-sim:precedence-of-entries">Simulation Manual</a>”?:
</p>
<blockquote cite="https://omnetpp.org/doc/omnetpp/manual/#sec:config-sim:precedence-of-entries">
	If you use wildcards, the order of entries is important; if a parameter name matches several wildcard-patterns, the <strong>first matching occurrence</strong> is used. This means that you need to list specific settings first, and more general ones later. Catch-all settings should come last.
</blockquote>
<p>
	Это значит, что мы можем одновременно использовать и хосты с “подстановочными знаками”, и указывать конкретный хост, а <nobr>OMNeT++</nobr> будет использовать первое совпадение параметра с шаблоном. Получится как‑то так:
</p>
<br /><source lang="ini">**.host?.numUdpApps = 1
**.host0.udpApp[0].typename = &quot;inet.applications.lltrapp.LLTRSuperApp&quot;
**.host?.udpApp[0].typename = &quot;inet.applications.lltrapp.LLTRApp&quot;</source>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> Это будет работать, если в сети используются только хосты с “host0” по “host9”, но “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:config-sim:wildcards"><code>host?</code></a>” не будет работать для “host10”, “host11”, и остальных. &lt;sarcasm&gt;В этом случае поможет переход на 16‑ю систему счисления, в которой все будет работать <abbr title="≤">вплоть до</abbr> “hostF” хоста ：）&lt;/sarcasm&gt;
</p><p><br />
	Либо, если сгруппировать по хостам, так:
</p>
<br /><source lang="ini">**.host0.udpApp[0].typename = &quot;inet.applications.lltrapp.LLTRSuperApp&quot;
**.host?.numUdpApps = 1
**.host?.udpApp[0].typename = &quot;inet.applications.lltrapp.LLTRApp&quot;</source>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> так как наш “omnetpp.ini” находится в одном проекте (“LLTR”), а приложения – в другом (“INET”), то при задании “<code>typename</code>” нужно указывать полный путь до приложения в “INET”.
</p><p><br /><anchor>git-tag-a1_v0-14-0</anchor>
	Должно получиться <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.14.0/LLTR/simulations/omnetpp.ini">примерно так (git tag a1_v0.14.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.13.0...a1_v0.14.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>.
</p><p><br />
	Посмотрим, что получилось. В исходном коде изменений не было, поэтому собирать INET необязательно. Просто <a href="#probnyy-zapusk">запускаем</a>, и…
</p>
<br /><anchor>fig_qtenv-host0-IUDPApp_Error</anchor><img alt="Error in module (omnetpp::cModule) Network.host0 (id=5) during network setup: Submodule udpApp: no module type named `inet.applications.lltrapp.LLTRSuperApp' found that implements module interface inet.applications.contract.IUDPApp (not in the loaded NED files?)." align="center" height="120" src="https://habrastorage.org/webt/rk/w7/dd/rkw7ddfmw027_ruw1etzgt-vzha.png#qtenv-host0-IUDPApp_Error.png"/>
<p><br />
	Оказывается “udpApp” должны реализовывать интерфейс “<code>IUDPApp</code>” (“inet-manual-draft.pdf”; раздел 13.4 “UDP applications”, страница 98):
</p>
<blockquote cite="https://omnetpp.org/doc/inet/api-3.4.0/inet-manual-draft.pdf">
	All UDP applications <strong>should be derived from the IUDPApp module interface</strong>, so that the application of StandardHost could be configured without changing its NED file.
</blockquote>
<p>
	Посмотрим, как это выглядит в “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/udpapp/UDPEchoApp.ned#L29">UDPEchoApp.ned</a>”:
</p>
<br /><source lang="cpp">import inet.applications.contract.IUDPApp;

simple UDPEchoApp like IUDPApp
{</source>
<p><br /><anchor>git-tag-a1_v0-15-0</anchor>
	Сделаем то же самое для “LLTRSuperApp” и “LLTRApp” <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/commit/5620a24392cab7a8eb99882051a434f5b7a45035">(git tag a1_v0.15.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.14.0...a1_v0.15.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>.
</p><p><br />
	Еще раз, просто <a href="#probnyy-zapusk">запускаем</a>…
</p>
<br /><anchor>fig_qtenv-host1-setOutputGate_Error</anchor><img alt="Error in module (inet::LLTRApp) Network.host1.udpApp[0] (id=104) during network initialization: UDPSocket: setOutputGate() must be invoked before socket can be used." align="center" height="94" src="https://habrastorage.org/webt/yo/0_/sj/yo0_sjrwnso1lbw0b2avhzhtsgg.png#qtenv-host1-setOutputGate_Error.png"/>
<p><br />
	Опять?..
</p><p><br />
	Текст ошибки просит обратить внимание на “LLTRApp” и сокеты. Я ранее написал:
</p>
<blockquote cite="#LLTRApp-wo-output-gate">
	А так как, в “LLTRApp” мы будем только принимать пакеты (отправлять ничего не будем), то отпадает необходимость в указании выходного “gate” функцией “<code>setOutputGate()</code>”.
</blockquote>
<p>
	Эта мысль и привела к ошибке. “<code>UDPSocket</code>” – это всего лишь обвертка для отправки сообщений в модуль “udp”. Даже при настройке сокета она отправляет управляющие сообщения, и естественно ей надо знать через какой “gate” отправлять эти сообщения. Например, возьмем тот же “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/udp/UDPSocket.cc#L58"><code>bind()</code></a>”, который использовали в “LLTRApp”, что он делает? Он вызывает “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/udp/UDPSocket.cc#L39"><code>sendToUDP()</code></a>”, который использует “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/udp/UDPSocket.h#L76"><code>gateToUdp</code></a>” для управляющих команд, а эта переменная, в свою очередь, задавалась через “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/udp/UDPSocket.h#L110"><code>setOutputGate()</code></a>”. А <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/udp/UDPSocket.cc#L42">вот и та часть кода</a>, которая инициировала вывод сообщения про ошибку. Кстати, если попробуете найти это предупреждение в “inet-manual-draft.pdf”, то в текущей версии ничего не найдете (предупреждения нет)…
</p><p><br /><anchor>git-tag-a1_v0-16-0</anchor>
	Исправим ошибки, добавив вызов “<code>setOutputGate()</code>” в “LLTRApp” <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.16.0/inet/src/inet/applications/lltrapp/LLTRApp.cc">(git tag a1_v0.16.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.15.0...a1_v0.16.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>, соберем INET, и попробуем <a href="#probnyy-zapusk">запустить</a>…
</p><p><br />
	Ура! Ошибок нет!（：если бы они были, я бы вставил скриншот：）
</p><p><br />
	В прошлый “удачный” запуск (когда не было сообщений с ошибками) мы обнаружили отсутствие “udpApp” и модуля “udp”. Так обнаружатся ли отсутствующие модули сейчас, либо они будут склонны продолжать отсутствовать без обнаружения ：）Проверим это:
</p>
<br /><anchor>fig_qtenv-host0-udpApp</anchor><img alt="qtenv: host0 udpApp" align="center" height="675" src="https://habrastorage.org/webt/fv/_n/wv/fv_nwvo8nkonrvqzrabd5fnlaeu.png#qtenv-host0-udpApp.png"/>
<p><br />
	И так, “<code>numUdpApps</code>” стал равен 1 – это очень хорошо; “<code>hasUdp</code>” стал равен “<code>true</code>” – это еще лучше; и, наконец, появился “<code>udpApp[0]</code>” с типом “<code>LLTRSuperApp</code>”, и модуль “<code>udp</code>” (типа “<code>UDP</code>”).
</p><p><br />
	А что стало со схемой “host0”? (двойной клик по “host0”):
</p>
<br /><anchor>fig_qtenv-in_host0-udpApp</anchor><img alt="qtenv: in host0 – udpApp" align="center" height="454" src="https://habrastorage.org/webt/gr/g3/mn/grg3mnxkdsx5bkn8q_dxvxw14rs.png#qtenv-in_host0-udpApp.png"/>
<p><br />
	Появился модуль “<code>udp</code>” и “<code>udpApp[0]</code>”.
</p><p><br />
	Вернемся назад (на уровень выше):
</p>
<br /><anchor>fig_qtenv-in_host0-back-go_to_parent_module</anchor><img alt="qtenv: in host0 – Back | Go to parent module" align="center" height="106" src="https://habrastorage.org/webt/6b/fl/my/6bflmyq6qaxolf5_zpjgrllypaq.png#qtenv-in_host0-back-go_to_parent_module.png"/>
<p><br />
	Запустим симуляцию (run):
</p>
<br /><anchor>fig_qtenv-run--2</anchor><img alt="qtenv: run with full animation (F5)" align="center" height="89" src="https://habrastorage.org/webt/ff/ez/wa/ffezwau7yjdminy8u6ck9sarx-q.png#qtenv-run.png"/>
<p><br />
	И…
</p>
<br /><anchor>fig_qtenv-App-Events-macOS_style</anchor><img alt="qtenv: App Events (macOS style)" align="center" height="301" src="https://habrastorage.org/webt/a3/cv/xr/a3cvxr2htokhxj7hctw9xgfqynm.png#qtenv-App-Events-macOS_style.png"/>
<p><br />
	Все работает, пакет “<code>=Packet name=</code>” прибыл в пункт назначения. Это происходило в точности, как в реальной сети:
</p>
<br /><ol>
	<li>вначале был ARP запрос (“<code>arpREQ</code>”) “А где же хост с IP 10.0.1.4? Какой у него MAC адрес?”;</li>
	<li>затем APR ответ (“<code>arpREPLY</code>”) “Это я, вот мой MAC…”;</li>
	<li>и, в конце, отправился созданный нами пакет “<code>=Packet name=</code>”.</li>
</ol>
<p><br /><anchor>pkt-content-sizes</anchor>
	<font color="#54524F"><b>Note</b>:</font> обратите внимание, что размер содержимого пакета – <nobr>“<strong><code>0 bytes</code></strong>”</nobr>, “<code>UDP</code>” (не поместилось на скриншоте) – <nobr>“<code>8 bytes</code>”</nobr>, “<code>IPv4</code>” – <nobr>“<code>28 bytes</code>”</nobr>, “<code>ETH</code>” – <nobr>“<code>64 bytes</code>”</nobr>, “<code>EtherPhyFrame</code>” – <nobr>“<code>72 bytes</code>”</nobr>.
</p><p><br />
	В логе (нижняя часть скриншота), видно, что когда пакет достиг “<code>Network.host3.udpApp[0]</code>”, “LLTRApp” создал запись в логе “<code>Arrived: =Packet name=</code>” (событие #88).
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> перед снятием скриншота, я отфильтровал (<kbd><strong>Ctrl+H</strong></kbd>) события в логе (оставил только события от “<code>Network.host3.udpApp[0]</code>”):
</p>
<br /><anchor>fig_qtenv-log_messages_filter-host3-udpApp0</anchor><img alt="qtenv: log messages filter – host3 – udpApp0" align="center" height="302" src="https://habrastorage.org/webt/dt/y8/h3/dty8h3f6m8mowjuors0z-dl6jmw.png#qtenv-log_messages_filter-host3-udpApp0.png"/>
<p><br />
	Поздравляю, у нас получилось отправить и принять пакет! Однако, одна вещь на скриншоте продолжает меня смущать. Она находится в строке статуса:
</p>
<br /><!-- nohighlight --><source lang="bash">Msg status: <strong>4 scheduled</strong> / 104 existing / 173 created</source>
<p><br />
	Симуляция завершена, но у нас еще 4 запланированных сообщения. Посмотрим на эти сообщения поближе:
</p>
<br /><anchor>fig_qtenv-finish-scheduled_events-CLOSE-UDPCloseCommand-host0</anchor><img alt="qtenv: finish – scheduled events – CLOSE – UDPCloseCommand – host0" align="center" height="786" src="https://habrastorage.org/webt/ot/fr/pk/otfrpkypk6ycv6vzr9nh2ro-lrm.png#qtenv-finish-scheduled_events-CLOSE-UDPCloseCommand-host0.png"/>
<p><br />
	Здесь мы видим 4 “CLOSE” (“<code>UDPCloseCommand</code>”) сообщения (по одному на каждый хост). Помните, <a href="#close-socket-in-finish_conclusion_see-context">ранее я упоминал</a>, что закрывать сокет в “<code>finish()</code>”, и тем более в деструкторе – бесполезно, т.к.:
</p>
<blockquote cite="#close-socket-in-finish_conclusion">
	“по документации” цикл обработки событий уже будет разрушен.
</blockquote>
<p>
	А то, что произойдет, если все‑таки отправить сообщение после “разрушения” цикла обработки событий, мы увидели – “висящие” сообщения. Они никогда не достигнут пункта назначения, т.к. симуляция уже завершена.
</p><p><br /><anchor>git-tag-a1_v0-17-0</anchor>
	Подправим это. Закомментируем “<code>socket.close();</code>” в “LLTRSuperApp” и “LLTRApp” <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/commit/66207ce3c0522430e2f3502dae35834ba4b1d150">(git tag a1_v0.17.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.16.0...a1_v0.17.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>.
</p><p><br />
	Посмотрим, исчезли ли “CLOSE” сообщения (соберем INET, <a href="#probnyy-zapusk">запустим</a> симулятор, запустим симуляцию (run)):
</p>
<br /><!-- nohighlight --><source lang="bash">Msg status: <strong>0 scheduled</strong> / 100 existing / 169 created</source>
<p><br />
	Все “висящие” сообщения исчезли.
</p><p><br />
	Если вы ранее заглядывали в <a href="https://github.com/inet-framework/inet/tree/v3.4.0/examples/inet">примеры сетей</a>, и в <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/udpapp/UDPSink.ned#L30">“.ned” файлы приложений</a>, то заметили, что часть параметров приложений можно менять прямо в “.ned” и “.ini” файлах (без пересборки INET). В <nobr>OMNeT++</nobr> хорошим тоном является предоставление будущем “пользователям” возможности изменения параметров приложения через “.ned” и “.ini” файлы.
</p><p><br />
	У “LLTRSuperApp” и “LLTRApp” есть один общий параметр – номер порта – отличный кандидат для задания “извне”. Так, что нужно сделать, чтобы “пользователь” мог задавать номер порта? Сделаем по аналогии с “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/udpapp/UDPSink.ned#L34">UDPSink.ned</a>” и “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/udpapp/UDPSink.cc#L43">UDPSink.cc</a>”:
</p>
<br /><ol>
	<li>добавим в “.ned” файлы новый <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-lang:parameters">параметр</a> “<code>int port;</code>”;</li>
	<li>в “.cc” файлах добавим новое поле “<code>int port = -1;</code>” к классу;</li>
	<li><a href="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:parameters">считаем значение параметра</a> в методе “<code>initialize()</code>”:
		<br /><source lang="cpp">case INITSTAGE_LOCAL:
       port = par(&quot;port&quot;);

       break;</source>
	</li>
	<li>заменим все явные задания порта “<code>1100</code>” на переменную “<code>port</code>”.</li>
</ol>
<br /><spoiler title="Почему изначально “port” равен “-1” (“int port = -1;”)?"><hr />
	<p>
		Если ответ в стиле: “потому что в <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/udpapp/UDPSink.h#L38">UDPSink</a> так написано”, не устроит, то добро пожаловать в исходники!
	</p><p><br />
		Причем поведение будет отличаться в зависимости от приложения.
	</p><p><br />
		Для “LLTRApp” (приложение, которое слушает порт): посмотрим цепочку вызова функции “<code>bind()</code>”, т.к. именно в нее передается порт:
	</p>
	<br /><ol>
		<li>“UDPSocket.cc”:“<code>bind()</code>” “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/udp/UDPSocket.cc#L60">-1: ephemeral port</a>”;</li>
		<li>“UDP.cc”:“<code>bind()</code>” “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.cc#L517">-1: ephemeral port</a>”;</li>
		<li>“UDP.cc”:“<code>bind()</code>” “<code><a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.cc#L535">localPort != -1</a></code>”;</li>
		<li>“UDP.cc”:“<code>bind()</code>” “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.cc#L542"><code>createSocket()</code></a>” → “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.cc#L568"><code>localPort == -1 ? getEphemeralPort() : localPort</code></a>” → “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.cc#L618"><code>getEphemeralPort()</code></a>”.</li>
	</ol>
	<p><br />
		Здесь “<code>-1</code>” означает “используй временный порт” (“ephemeral port” – любой свободный порт).
	</p><p><br />
		Для “LLTRSuperApp” (приложение, которое отправляет пакеты) все иначе:
	</p>
	<br /><ol>
		<li>“UDPSocket.cc”:“<code>connect()</code>” “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/udp/UDPSocket.cc#L76">invalid remote port number</a>”;</li>
		<li>“UDPSocket.cc”:“<code>sendTo()</code>” → “UDP.cc”:“<code>processPacketFromApp()</code>” “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.cc#L296"><code>ctrl-&gt;getDestPort() == -1 ? sd-&gt;remotePort : ctrl-&gt;getDestPort()</code></a>”, “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.cc#L297">missing destination address or port when sending over unconnected port</a>”.</li>
	</ol>
	<p><br />
		Здесь “<code>-1</code>” означает либо “попробуй использовать ранее заданный порт”, либо это ошибка.
	</p>
<hr /></spoiler>
<p><br /><anchor>git-tag-a1_v0-18-0</anchor>
	Осталось только задать номер порта через “.ini” файл для всех хостов, и все будет готово <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/commit/0447203820c90f1d65e5284a6335cdaae0f2271f">(git tag a1_v0.18.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.17.0...a1_v0.18.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>.
</p><p><br />
	Сборка INET, <a href="#probnyy-zapusk">запуск</a> симулятора, и запуск симуляции (run), должны пройти успешно.
</p>
<br /><h3><anchor>shag-1-rassylaem-broadcast-i-podschityvaem-kolichestvo-prinyatyh-paketov</anchor><a href="#shag-1-rassylaem-broadcast-i-podschityvaem-kolichestvo-prinyatyh-paketov" title="Ссылка на раздел"><font color="gray">#</font></a> Шаг 1: рассылаем broadcast, и подсчитываем количество принятых пакетов</h3>
<p><br />
	Судя по примеру “<a href="https://github.com/inet-framework/inet/tree/v3.4.0/examples/inet/broadcast">UDPBroadcastNetwork</a>” – это легко. Достаточно в “<code>sendTo()</code>” указать broadcast IP, и все заработает. С <a href="#configure-IPv4NetworkConfigurator">текущими настройками “IPv4<strong>Network</strong>Configurator”</a> для нашей сети из 4‑х хостов broadcast адресом будет “<strong>10.0.1.7</strong>”.
</p><p><br />
	И, чуть не забыл, в том же “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/udpapp/UDPSink.ned#L35">UDPSink.ned</a>” был параметр “<code>receiveBroadcast</code>”:
</p>
<br /><source lang="cpp">bool receiveBroadcast = default(false); // if true, makes the socket receive broadcast packets</source>
<p><br />
	Он используется в <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/udpapp/UDPSink.cc#L98">этом месте “UDPSink.cc”</a>:
</p>
<br /><source lang="cpp">bool receiveBroadcast = par(&quot;receiveBroadcast&quot;);
if (receiveBroadcast)
    socket.setBroadcast(true);</source>
<p><br />
	Также аналогичный параметр используется и в <a href="https://github.com/inet-framework/inet/tree/v3.4.0/src/inet/applications/udpapp">других “UDP*App”</a>, например в “UDPBasicApp”: “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/udpapp/UDPBasicApp.ned#L58">.ned</a>”, “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/udpapp/UDPBasicApp.cc#L89">.cc</a>”.
</p><p><br />
	Значит, в принимающий broadcast пакеты модуль (“LLTRApp”), нужно добавить вызов “<code>setBroadcast(true)</code>”.
</p>
<br /><spoiler title="Где происходит проверка на broadcast? Что делает “setBroadcast(true)”? И немного про “UDPBroadcastNetwork”."><hr />
	<ol>
		<li>Начнем с “UDPSocket.cc”:“<code>setBroadcast()</code>” в нем используется “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/udp/UDPSocket.cc#L124"><code>UDPSetBroadcastCommand</code></a>”.</li>
		<li>Продолжим в “UDP.cc”:“<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.cc#L213"><code>processCommandFromApp()</code></a>” → “<code>setBroadcast()</code>”-“<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.cc#L848"><code>sd-&gt;isBroadcast = broadcast</code></a>”.</li>
		<li>Найдем места использования “<code>isBroadcast</code>” в коде (в Eclipse: <nobr>контекстное меню &gt;</nobr> <nobr>References &gt;</nobr> Project; либо сразу: <nobr>контекстное меню &gt;</nobr> Open Call Hierarchy) ← “<code>findSocketsForMcastBcastPacket()</code>”-“<strong><code><a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.cc#L687">if (sd-&gt;isBroadcast)</a></code></strong>” ← “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.cc#L393"><code>processUDPPacket()</code></a>”.</li>
	</ol>
	<p><br />
		То есть “<code>setBroadcast()</code>” влияет только на входящие пакеты, т.к. именно “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.cc#L157"><code>processUDPPacket()</code></a>” обрабатывает входящие пакеты.
	</p><p><br />
		Если вспомнить пример (“UDPBroadcastNetwork”), в котором приложение “UDPBasicApp” отправляет broadcast пакеты, а “UDPSink” – принимает, то либо в “.ini”, либо в “.ned” файле параметр “<code>receiveBroadcast</code>” должен устанавливаться в “<code>true</code>” для всех “UDPSink”. Но этого нет ни в “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/examples/inet/broadcast/omnetpp.ini">omnetpp.ini</a>”, нет и в “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/examples/inet/broadcast/UDPBroadcastNetwork.ned">UDPBroadcastNetwork.ned</a>”. Так, как же оно работает, или оно работает неправильно?..
	</p><p><br />
		К тому же в “UDPBroadcastNetwork” используется <a href="https://github.com/inet-framework/inet/blob/v3.4.0/examples/inet/broadcast/omnetpp.ini#L6">directed broadcast адрес</a> и <a href="https://github.com/inet-framework/inet/blob/v3.4.0/examples/inet/broadcast/UDPBroadcastNetwork.ned#L49">роутер</a>, значит на роутере по умолчанию включен <a href="https://web.archive.org/web/20171105192635/http://www.brocade.com/content/html/en/configuration-guide/FI_08030_L3/GUID-591F51DA-9AC6-4F57-983E-E77BAA3D4F34.html">directed broadcasts forwarding</a>? Однако, на реальном оборудовании, по умолчанию <a href="https://networkengineering.stackexchange.com/questions/2876/directed-and-limited-broadcast-confusion">directed broadcasts</a> forwarding обычно <a href="https://tools.ietf.org/search/rfc2644">выключен</a>…
	</p>
<hr /></spoiler>
<p><br /><anchor>git-tag-a1_v0-19-0</anchor>
	В итоге, должно получиться <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/commit/0fef1f527be69d8646f7134e3fba952f8cf62f24">примерно так (git tag a1_v0.19.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.18.0...a1_v0.19.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>.
</p><p><br />
	Посмотрим на то, как выглядит broadcast в симуляторе (собираем INET, <a href="#probnyy-zapusk">запускаем</a> симулятор, запускаем симуляцию (run)):
</p>
<br /><anchor>fig_qtenv-App-Events-broadcast_10_0_1_7</anchor><img alt="qtenv: App Events broadcast 10.0.1.7" align="center" height="412" src="https://habrastorage.org/webt/ed/_i/qk/ed_iqktg-nkmkce7i90dabdq2ns.png#qtenv-App-Events-broadcast_10_0_1_7.png"/>
<p><br /><anchor>fig_That-Detective-is-the-right-question-Program-terminated--2</anchor><a href="#fig_That-Detective-is-the-right-question-Program-terminated"><img alt="That, Detective, is the right question…" align="right" width="249" height="111" src="https://habrastorage.org/webt/zo/c8/q4/zoc8q45hirh8gh2dfk4jnm40wyy.jpeg#That-Detective-is-the-right-question-Program-terminated.jpg"/></a>
	Вот он – broadcast, только рассылался не наш (“<code>=Broadcast Packet=</code>”) пакет, а “<code>arpREQ</code>”. “host0” стал искать хост с IP “10.0.1.7” в сети. Похоже, он воспринял “10.0.1.7” как unicast адрес. Почему так произошло?..
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> в INET у класса “IPv4Address” есть метод “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/contract/ipv4/IPv4Address.h#L301"><code>makeBroadcastAddress()</code></a>”.
</p>
<br /><h4><anchor>ups</anchor><a href="#ups" title="Ссылка на раздел"><font color="gray">#</font></a> Упс…</h4>
<p><br />
	Попробуем воспользоваться “<code>[1]</code>” записью из “<a href="#fig_IPv4NetworkConfigurator-qtenv-host0-grouped-routingTable-routes"><code>host0.<strong>routingTable</strong>.routes</code></a>”:
</p>
<br /><!-- nohighlight --><source lang="bash">[0] = dest:10.0.1.0  gw:*  mask:255.255.255.248  metric:0  if:eth0(10.0.1.1)  DIRECT MANUAL
[1] = dest:10.0.1.0  gw:*  mask:255.255.255.0    metric:20 if:eth0(10.0.1.1)  DIRECT IFACENETMASK
[2] = dest:127.0.0.0 gw:*  mask:255.0.0.0        metric:1  if:lo0(127.0.0.1)  DIRECT IFACENETMASK</source>
<p><br />
	И укажем, в качестве direct broadcast адреса – “<strong>10.0.1.255</strong>”:
</p>
<br /><source lang="cpp">socket.sendTo(new cPacket(&quot;=Broadcast Packet=&quot;), IPv4Address(<strong>10,0,1,255</strong>), port);</source>
<p><br />
	Если и сейчас не увидим рассылки “<code>=Broadcast Packet=</code>”, то останется только использовать адрес “255.255.255.255”. Пальцы крестиком, поехали (собираем INET, <a href="#probnyy-zapusk">запускаем</a> симулятор, запускаем симуляцию (run)):
</p>
<br /><anchor>fig_qtenv-App-Events-broadcast_10_0_1_255_and_255_255_255_255</anchor><img alt="qtenv: App Events broadcast 10.0.1.255 and 255.255.255.255" align="center" height="412" src="https://habrastorage.org/webt/ft/fy/gm/ftfygmwx8ymwliapavfuee6dile.png#qtenv-App-Events-broadcast_10_0_1_255_and_255_255_255_255.png"/>
<p><br />
	Теперь вообще пакетов нет… Остался “<strong>255.255.255.255</strong>”, и, как помнится, <a href="#IPv4Address-ALLONES_ADDRESS">ранее в коде</a> мы находили константу с этим адресом – “<strong><code>IPv4Address::ALLONES_ADDRESS</code></strong>”. В общем, перейдем на limited broadcast:
</p>
<br /><source lang="cpp">socket.sendTo(new cPacket(&quot;=Broadcast Packet=&quot;), <strong>IPv4Address::ALLONES_ADDRESS</strong>, port);</source>
<p><br />
	Собираем INET, <a href="#probnyy-zapusk">запускаем</a> симулятор, запускаем симуляцию (run)):
</p>
<br /><anchor>fig_qtenv-App-Events-broadcast_10_0_1_255_and_255_255_255_255--2</anchor><img alt="qtenv: App Events broadcast 10.0.1.255 and 255.255.255.255" align="center" height="412" src="https://habrastorage.org/webt/ft/fy/gm/ftfygmwx8ymwliapavfuee6dile.png#qtenv-App-Events-broadcast_10_0_1_255_and_255_255_255_255.png"/>
<p><br />
	Лог в точности совпал с предыдущим логом – пакет не выходит за приделы “host0”…
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> так как логи полностью совпали, я вставил один и тот же скриншот（： надо экономить трафик ：）
</p>
<br /><h4><anchor>mozgovoy-shturm</anchor><a href="#mozgovoy-shturm" title="Ссылка на раздел"><font color="gray">#</font></a> Мозговой штурм</h4>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> изначально это был небольшой note, но он разросся до целого раздела…
</p><p><br />
	Я не сразу нашел как отправить broadcast пакет в INET. Вначале еще раз прочитал главу про UDP в “inet-manual-draft.pdf” (глава 13 “The UDP Model”; страница 95), что только навело на ложный путь. В разделе 13.2.1 “Sending UDP datagrams” (страница 96) говорилось, что, перед отправкой broadcast сообщения, нужно сконфигурировать сокет:
</p>
<blockquote cite="https://omnetpp.org/doc/inet/api-3.4.0/inet-manual-draft.pdf">
	Before sending broadcast messages, the socket must be configured for broadcasting. This is done by sending an message to the UDP module. The message kind is UDP_C_SETOPTION and its control info (an UDPSetBroadcastCommand) tells if the broadcast is enabled.
</blockquote>
<p>
	То есть использовать функцию “<code>setBroadcast()</code>”, но, как мы уже выяснили, она влияет только на получение broadcast пакета. Естественно, когда я ее “на всякий случай” добавил в “LLTRSuperApp” – это не помогло. Причем, в разделе 13.2.2 “Receiving UDP datagrams” (страница 97), где “<code>setBroadcast()</code>” действительно нужен, ограничились фразой:
</p>
<blockquote cite="https://omnetpp.org/doc/inet/api-3.4.0/inet-manual-draft.pdf">
	The socket receives the broadcast packets only if it is configured for broadcast.
</blockquote>
<p>
	К тому же в предыдущем разделе (13.2.1 “Sending UDP datagrams”; страница 96) присутствует еще более запутывающий note:
</p>
<blockquote cite="https://omnetpp.org/doc/inet/api-3.4.0/inet-manual-draft.pdf">
	NOTE: The UDP module supports only <strong>local</strong> broadcasts (using the special 255.255.255.255 address). Packages that are broadcasted to a remote subnet are handled as undeliverable messages.
</blockquote>
<p>
	<font color="#54524F"><b>Note</b>:</font> Этот фрагмент запутывает вдвойне. В INET есть функция “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/ipv4/IIPv4RoutingTable.h#L102"><code>is<strong>Loca</strong>lBroadcastAddress()</code></a>”, которая работает <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/ipv4/IPv4RoutingTable.cc#L367">так</a>, и функция “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/contract/ipv4/IPv4Address.h#L220"><code>is<strong>Limited</strong>BroadcastAddress()</code></a>”, которая сравнивает адрес с “255.255.255.255”. Так может они имели в виду “<strong>limited</strong> broadcasts”, а не “<strong>local</strong> broadcasts”?
</p><p><br />
	Опять же, это примечание больше касается принимающей стороны. На отправляющей стороне directed broadcast пакеты должны спокойно отправляться <!--изначально вместо "должны спокойно отправляться" было написано: "спокойно отправляются", но т.к. выше (в #ups) они не "отправились спокойно", то этот вариант приводил к противоречию при чтении, я заменил на текущий вариант, намекая на то, что нужно "поигать" с примером UDPBroadcastNetwork--> (<em>в одной подсети</em>), и <a href="https://github.com/inet-framework/inet/tree/v3.4.0/examples/inet/broadcast">пример “UDPBroadcastNetwork”</a> работает (<em>между подсетями</em>; хотя он и не работает, как должен, выше я про это упоминал). А вот принимающая сторона <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/udp/UDP.cc#L345">из‑за этой строчки</a> обрабатывает пакет, не как directed broadcast, а как unicast пакет. Положительная сторона этого: можно “<code>setBroadcast(true)</code>” выкинуть, либо вообще заменить на “<code>setBroadcast(false)</code>”, и все будет работать! Отрицательная сторона: работать может не всегда. Оно будет точно работать (сокет “получит” пакет), если сокет создавался без привязки к адресу/интерфейсу, а вот если его привязали…
</p><p><br />
	Это объясняет, почему в названии присутствует “draft” (“inet-manual-<strong>draft</strong>.pdf”) – намек, на то, что лучше смотрите на код (“ищите ответы в коде, а не в словах”). На самом деле в “inet-manual-draft.pdf” был ответ на вопрос, но он был в другой главе/разделе (надо было просто искать слово “broadcast” по всему документу)…
</p><p><br />
	Далее, в <nobr>OMNeT++</nobr> “Simulation Manual”, нашел раздел “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:broadcasts-and-retransmissions">Broadcasts and Retransmissions</a>”, но в нем просто объясняется, как сделать широковещательную рассылку на уровне <nobr>OMNeT++</nobr>, а мы работаем на уровне выше (INET). Где‑то внутри модулей INET все так и происходит, но пока эта информация оказалась бесполезной (можно найти все использования “<code>dup()</code>” в INET, но разбор результатов поиска займет слишком много времени, т.к. “<code>dup()</code>” используется не только для broadcast но и для retransmission; пока будим считать, что это был запасной вариант).
</p><p><br />
	Далее последовал Stack Overflow: “<a href="http://stackoverflow.com/questions/30576237/send-the-same-message-to-several-hosts-broadcast-in-ethernet-lan">Send the same message to several hosts (Broadcast in Ethernet LAN)</a>”. Но там использовался <a href="https://github.com/inet-framework/inet/tree/v3.4.0/examples/ethernet/lans">Ethernet LAN</a> и “<a href="http://stackoverflow.com/questions/14454548/how-to-use-etherhost-in-omnet/14633831#14633831">EtherHost</a>”, что не подходило для “StandardHost”. Однако <a href="http://stackoverflow.com/a/30578105">помеченный ответ</a>, содержит упоминание IP уровня. Может кто‑нибудь дополнит <a href="http://stackoverflow.com/a/30578105">этот ответ</a> описанным ниже решением…
</p><p><br />
	Далее была <a href="https://web.archive.org/web/20130508160705/https://omnetpp.org/listarchive/msg12364.php">переписка “INETMANET: how send Broadcast IP packet”</a>. Хотя она и была связанна с <a href="https://habrahabr.ru/post/197860">MANET</a>, но, возможно, именно она натолкнула на решение.
</p><p><br />
	Я уже не помню, как нашел решение, но это могло бы быть так…
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> в этот момент наступает ощущение, что проходишь обряд посвящения в элитный закрытый клуб (клубы при “Оксфорде”, “Гарварде”, …)
</p>
<br /><h4><anchor>pobeda-razuma-nad-instinktom</anchor><a href="#pobeda-razuma-nad-instinktom" title="Ссылка на раздел"><font color="gray">#</font></a> Победа разума над инстинктом</h4>
<p><br />
	Запустим (run) симуляцию заново, но теперь заглянем внутрь модуля “host0”, и воспользуемся режимом пошаговой симуляции:
</p>
<br /><anchor>fig_qtenv-in_host0-run_until_next_event_in_this_module_btn-broadcast_255_255_255_255</anchor><img alt="qtenv: in host0 – run until next event in this module btn – broadcast 255.255.255.255" align="center" height="462" src="https://habrastorage.org/webt/uw/b_/eh/uwb_ehwail6qhsjxsf7d9kczjqs.png#qtenv-in_host0-run_until_next_event_in_this_module_btn-broadcast_255_255_255_255.png"/>
<p><br />
	Лог:
</p>
<br /><anchor>fig_qtenv-in_host0-log-broadcast_255_255_255_255</anchor><img alt="qtenv: in host0 – log – broadcast 255.255.255.255" align="center" height="265" src="https://habrastorage.org/webt/kl/ds/wy/kldswyhbh-kpvlu0ouqtudopmoy.png#qtenv-in_host0-log-broadcast_255_255_255_255.png"/>
<p><br />
	По сути, этот лог ничего нового не сказал – “<code>=Broadcast Packet=</code>” отправляется в “networkLayer” (событие #20) и в нем исчезает. Точнее, последнее событие (#21) связано с модулем “<code>networkLayer.<strong>ip</strong></code>”. Надо спуститься еще глубже:
</p>
<br /><anchor>fig_qtenv-in_host0-in_networkLayer-ip_drop_forceBroadcast-broadcast_255_255_255_255</anchor><img alt="qtenv: in host0 – in networkLayer – ip drop forceBroadcast – broadcast 255.255.255.255" align="center" height="484" src="https://habrastorage.org/webt/i3/je/cc/i3jeccq7uvbmzuv42sl-v2g71x0.png#qtenv-in_host0-in_networkLayer-ip_drop_forceBroadcast-broadcast_255_255_255_255.png"/>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> можно пересобрать сеть (Qtenv <nobr>меню &gt;</nobr> <nobr>Simulate &gt;</nobr> Rebuild Network), и в пошаговом режиме посмотреть, что происходит на этом уровне.
</p><p><br />
	Здесь, на схеме появилось сообщение “<code>DROP: 1</code>” (рядом с “ip” модулем). Заглянем в параметры (слева) этого модуля (“<code>ip (IPv4)</code>”). Здесь привлекают внимание две записи:
</p>
<br /><ul>
	<li>это “<code>numDropped</code>”, равный 1 – скорее всего именно “ip” дропнул наш пакет, и теперь гордо сообщает об этом;</li>
	<li>и “<code>forceBroadcast</code>”, равный “<code>false</code>” – возможно именно он препятствовал прохождению broadcast пакетов.</li>
</ul>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> если сейчас, через “omnetpp.ini” файл, изменить “<code>forceBroadcast</code>” на “<code>true</code>”, то все заработает, но…
</p><p><br />
	Поищем параметр “<code>forceBroadcast</code>” в коде модуля “ip”:
</p>
<br /><ul>
	<li>“<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/ipv4/IPv4.ned#L97">IPv4.ned</a>”;</li>
	<li>“<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/ipv4/IPv4.cc#L75">IPv4.cc</a>” – установка значения переменной “<code>forceBroadcast</code>”.</li>
</ul>
<p><br />
	Переменная “<code>forceBroadcast</code>” используется только в методе “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/ipv4/IPv4.cc#L489"><code>routeLocalBroadcastPacket()</code></a>”:
</p>
<br /><source lang="cpp">void IPv4::routeLocalBroadcastPacket(IPv4Datagram *datagram, const InterfaceEntry *destIE)
{
    if (<strong>destIE</strong> != nullptr) {
        fragmentPostRouting(datagram, <i><strong>destIE</strong></i>, IPv4Address::ALLONES_ADDRESS);
    } else if (<strong>forceBroadcast</strong>) {
        // forward to each interface including loopback
        for (int i = 0; i &lt; ift-&gt;getNumInterfaces(); i++) {
            const InterfaceEntry *ie = ift-&gt;getInterface(i);
            fragmentPostRouting(datagram-&gt;dup(), <i><strong>ie</strong></i>, IPv4Address::ALLONES_ADDRESS);
        }
        delete datagram;
    } else {
        <strong>numDropped</strong>++;
        delete datagram;
    }
}</source>
<p><br />
	То есть, если установить “<code>forceBroadcast</code>” в “<code>true</code>”, то broadcast пакет пройдет, но его разошлют сразу на все интерфейсы! Нам этого не надо, поэтому смотрим условие выше (“<code>destIE != nullptr</code>”). То есть, если при вызове “<code>routeLocalBroadcastPacket()</code>” указать “<code>destIE</code>”, то пакет отправится только на один интерфейс – на указанный в “<code>destIE</code>”.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> и “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/ipv4/IPv4.cc#L498"><code>numDropped</code></a>” здесь же.
</p><p><br />
	Похоже, по крайне мере, в последних двух (“10.0.1.255” и “255.255.255.255”) попытках отправить broadcast пакет, “<code>destIE</code>” был равен нулю. Так, как же изменить “<code>destIE</code>” на нужный интерфейс? Можно подняться по иерархии вызовов вверх (“<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/ipv4/IPv4.cc#L389"><code>datagramLocalOut()</code></a>” ← “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/ipv4/IPv4.cc#L329"><code>handlePacketFromHL()</code></a>”), и понять, что в нашем случае “<code>destIE</code>” задается на <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/ipv4/IPv4.cc#L321">этой строчке</a>, но и так уже ясно, что раз “<code>destIE</code>” не устанавливается автоматически в нужное значение (да и как это будет возможно при “255.255.255.255”), то это надо делать вручную через конфигурирование UDP сокета.
</p><p><br />
	Заглянем в файл “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/udp/UDPSocket.cc">UDPSocket.cc</a>”, и посмотрим, как можно задать конкретный интерфейс для отправки пакета. Мы, для отправки пакета, использовали функцию “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/udp/UDPSocket.cc#L88"><code>sendTo()</code></a>”, у которой, оказывается, есть <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/udp/UDPSocket.h#L236">четвертый опциональный аргумент</a> – “<code>SendOptions *options</code>”. Через “options” можно задать “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/udp/UDPSocket.cc#L96"><code>srcAddr</code></a>” и “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/udp/UDPSocket.cc#L97"><code>interfaceId</code></a>” – это именно то, что нам и нужно сделать.
</p><p><br />
	Осталось решить одну проблему – как из своего приложения получить доступ к информации про IP текущего хоста (на котором “запущено” приложение), и к информации про его интерфейсы?<br />
	Начну с интерфейсов.
</p><p><br />
	При просмотре <a href="#fig_qtenv-in_host0-udpApp">внутренней схемы “host0”</a> и <a href="#fig_qtenv-host0-udpApp">его параметров</a>, в ней был модуль “interfaceTable”, возможно именно он хранит список интерфейсов. Посмотрим:
</p>
<br /><anchor>fig_qtenv-host0-interfaceTable</anchor><img alt="qtenv: host0 interfaceTable" align="center" height="415" src="https://habrastorage.org/webt/ky/7e/ck/ky7eckyznfr81qsnc2astc3pcmk.png#qtenv-host0-interfaceTable.png"/>
<p><br />
	Осталось понять, как добраться до этого модуля, и вытащить из него информацию про интерфейсы. Я каким‑то образом нашел 3 способа, как добраться до этого модуля (последствия мозгового штурма?). Вначале я использовал “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/common/L3AddressResolver.cc#L453" title="Like interfaceTableOf(), but doesn't throw error if not found."><code><strong>find</strong>InterfaceTableOf()</code></a>”:
</p>
<br /><source lang="cpp">IInterfaceTable *inet_ift = L3AddressResolver().findInterfaceTableOf(getParentModule());</source>
<p><br />
	Затем, я посмотрел на его реализацию, на реализацию “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/common/L3AddressResolver.cc#L423" title="The function tries to look up the IInterfaceTable module as submodule &quot;interfaceTable&quot; or &quot;networkLayer.interfaceTable&quot; within the host/router module. Throws an error if not found."><code>interfaceTableOf()</code></a>”, и написал так:
</p>
<br /><source lang="cpp">IInterfaceTable *inet_ift = check_and_cast&lt;IInterfaceTable*&gt;(getParentModule()-&gt;getModuleByPath(&quot;.interfaceTable&quot;));</source>
<p><br />
	И, в определенный момент, просматривая код других UDP приложений (“<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/udpapp/UDPBasicBurst.cc#L130">UDPBasicBurst.cc</a>”), я написал так:
</p>
<br /><source lang="cpp">IInterfaceTable *inet_ift = getModuleFromPar&lt;IInterfaceTable&gt;(par(&quot;interfaceTableModule&quot;), this);</source>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> возможно вы уже заметили, просматривая “инспектор объектов” Qtenv, что у каждого модуля внутри хоста есть параметр “<code>interfaceTableModule</code>”, и <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/node/inet/NodeBase.ned#L65">кто‑то</a> прописывает в нем полный путь до модуля “interfaceTable” текущего хоста.
</p><p><br /><anchor>git-tag-a1_v0-20-0</anchor>
	После добавления в модуль “LLTRSuperApp” нового параметра, прописывания недостающих “<code>#include</code>”, создания “<code>UDPSocket::SendOptions</code>” с сохранением в нем информации о нужном интерфейсе, и использования расширенного варианта “<code>sendTo()</code>”, код станет выглядеть <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/commit/dbd654f10d74da5e8fe9e1ac8bd212092687b0e5">примерно так (git tag a1_v0.20.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.19.0...a1_v0.20.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>.
</p><p><br />
	Собираем и смотрим лог (собираем INET, <a href="#probnyy-zapusk">запускаем</a> симулятор, запускаем симуляцию (run)):
</p>
<br /><anchor>fig_qtenv-App-Events-broadcast_255_255_255_255_fixed</anchor><img alt="qtenv: App Events – broadcast 255.255.255.255 fixed" align="center" height="412" src="https://habrastorage.org/webt/mr/5w/jd/mr5wjdrhwoouf0guiqvd6-qcvok.png#qtenv-App-Events-broadcast_255_255_255_255_fixed.png"/>
<p><br />
	Наконец‑то! Broadcast пакеты успешно покинули хост, и были приняты в “LLTRApp”! А что в этот момент происходило внутри “host0”?:
</p>
<br /><anchor>fig_qtenv-in_host0-log-broadcast_255_255_255_255_fixed</anchor><img alt="qtenv: in host0 – log – broadcast 255.255.255.255 fixed" align="center" height="455" src="https://habrastorage.org/webt/7g/-d/gh/7g-dghp-l-wwy46jedhkrgpwcja.png#qtenv-in_host0-log-broadcast_255_255_255_255_fixed.png"/>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> формат лога немного изменился (стал чище), ниже я покажу, как это сделать.
</p><p><br />
	В <a href="#fig_qtenv-in_host0-log-broadcast_255_255_255_255">прошлый раз</a> все закончилось на событии #21, и само событие (#21) выглядело иначе…
</p><p><br />
	И, возвращаясь немного назад, как я уже упоминал (в “разросшемся” note) в “inet-manual-draft.pdf” был ответ на вопрос (раздел 11.2.3 “Routing, and interfacing with lower layers”, страница 70):
</p>
<blockquote cite="https://omnetpp.org/doc/inet/api-3.4.0/inet-manual-draft.pdf">
	<p>
		If the destination is the <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/ipv4/IPv4.cc#L388">limited broadcast address, or a local broadcast address</a>, then it will be broadcasted on one or more interface. If the higher layer specified am outgoing interface (<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/networklayer/ipv4/IPv4.cc#L321">interfaceId in the control info</a>), then it will be broadcasted on that interface only. Otherwise if the <strong>forceBroadcast</strong> module parameter is true, then it will broadcasted on all interfaces including the loopback interface.
	</p><p><br />
		The default value of the <strong>forceBroadcast</strong> is false.
	</p>
</blockquote>
<p>
	Раздел 11.2.4 “Parameters”, страница 72:
</p>
<blockquote cite="https://omnetpp.org/doc/inet/api-3.4.0/inet-manual-draft.pdf">
	<strong>forceBroadcast</strong> if true, then link-local broadcast datagrams are sent out through each interface, if the higher layer did not specify the outgoing interface.
</blockquote>
<p>
	И раздел 11.2.5 “Statistics”, страница 72:
</p>
<blockquote cite="https://omnetpp.org/doc/inet/api-3.4.0/inet-manual-draft.pdf">
	<strong>numDropped</strong> number of dropped packets. Either because there is no any interface, the interface is not specified and no <strong>forceBroadcast</strong>, or received from the network but IP forwarding disabled.
</blockquote>
<p>
	<font color="#54524F"><b>Note</b>:</font> если вы используете “UDPBasicBurst”, и полагаетесь на документацию (раздел 13.4.6 “UDPBasicBurst”, страница 100):
</p>
<blockquote cite="https://omnetpp.org/doc/inet/api-3.4.0/inet-manual-draft.pdf">
	You can use the &quot;Broadcast&quot; string as address for sending broadcast messages.
</blockquote>
<p>
	То знайте – это не сработает. <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/udpapp/UDPBasicBurst.cc#L133">Исходники</a> – в них нигде не задается конкретный интерфейс, и не форсируется broadcast на IP уровне (это придется делать самому).
</p>
<br /><h4><anchor>delete-msg</anchor><a href="#delete-msg" title="Ссылка на раздел"><font color="gray">#</font></a> delete msg;</h4>
<p><br />
	А что будет, если забыть удалить пакет на принимающей стороне? Проверим это! В “LLTRApp” закомментируем строчки “<code>delete msg;</code>”, и посмотрим на лог (собираем INET, <a href="#probnyy-zapusk">запускаем</a> симулятор, запускаем симуляцию (run)):
</p>
<br /><anchor>fig_qtenv-App-Events-broadcast_255_255_255_255_fixed-no_delete_msg</anchor><img alt="qtenv: App Events – broadcast 255.255.255.255 fixed – no delete msg" align="center" height="412" src="https://habrastorage.org/webt/xu/uk/qi/xuukqicoh8ksff4jpdt1hatl_wi.png#qtenv-App-Events-broadcast_255_255_255_255_fixed-no_delete_msg.png"/>
<p><br />
	Ничего… Лог в точности такой же, как и в <a href="#fig_qtenv-App-Events-broadcast_255_255_255_255_fixed">предыдущем запуске</a>. Но <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:init-finish:basic-usage">документация уверяла</a>, что <nobr>OMNeT++</nobr> будет следить за утечками памяти:
</p>
<blockquote cite="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:init-finish:basic-usage">
	<nobr>OMNeT++</nobr> prints the list of unreleased objects at the end of the simulation. When a simulation model dumps &quot;undisposed object ...&quot; messages, this indicates that the corresponding module destructors should be fixed.
</blockquote>
<p>
	Симуляция закончилась, но никаких сообщений “undisposed object ...” не было. В документации ошибка?
</p><p><br />
	Все в порядке, мы просто не <i><strong>там</strong></i> и не в то <i><strong>время</strong></i> смотрели. Не закрывая Qtenv, вернемся в Eclipse (<nobr>OMNeT++</nobr> IDE), внизу должна быть открыта панель “Console” (<i><strong>там</strong></i>). Сейчас она должна содержать примерно такой текст:
</p>
<br /><!-- nohighlight --><source lang="bash">...
Setting up Qtenv...
Loading NED files from ../src:  0
Loading NED files from .:  1
Loading NED files from ../../inet/examples:  162
Loading NED files from ../../inet/src:  563
Loading NED files from ../../inet/tutorials:  5</source>
<p><br />
	Здесь тоже никаких “undisposed object ...” сообщений нет, но это только пока… Вернемся в Qtenv, и пересоберем сеть (меню <nobr>Simulate &gt;</nobr> Rebuild Network) (<i><strong>время</strong></i>). Теперь посмотрим, изменилось ли содержимое “Console”?:
</p>
<br /><!-- nohighlight --><source lang="bash">...
Setting up Qtenv...
Loading NED files from ../src:  0
Loading NED files from .:  1
Loading NED files from ../../inet/examples:  162
Loading NED files from ../../inet/src:  563
Loading NED files from ../../inet/tutorials:  5
undisposed object: (omnetpp::cPacket) Network.host1.udpApp.=Broadcast Packet= -- check module destructor
undisposed object: (omnetpp::cPacket) Network.host2.udpApp.=Broadcast Packet= -- check module destructor
undisposed object: (omnetpp::cPacket) Network.host3.udpApp.=Broadcast Packet= -- check module destructor</source>
<p><br />
	Сообщения “undisposed object ...” появились. Как видите, в них указывается последнее местонахождение неосвобожденного объекта.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> помните, чтобы увидеть список “утечки памяти” нужно не только запустить симуляцию, но и после ее завершения – пересобрать сеть, и смотреть в “Console” (<nobr>OMNeT++</nobr> IDE).
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> после экспериментов не забудьте раскомментировать “<code>delete msg;</code>”, либо откатиться на <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.20.0/inet/src/inet/applications/lltrapp/LLTRApp.cc#L40-L55">(git tag a1_v0.20.0)</a>.
</p>
<br /><h4><anchor>nastroyka-gui-qtenv</anchor><a href="#nastroyka-gui-qtenv" title="Ссылка на раздел"><font color="gray">#</font></a> Настройка GUI Qtenv</h4>
<p><br />
	Мы уже продолжительное время используем Qtenv, поэтому настало время настроить его под себя.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> ниже я приведу настройки, которые оказались удобными для меня, и для снятия скриншотов (для этой статьи).
</p><p><br />
	Вначале, надо сказать, что все настройки Qtenv хранятся в домашней директории пользователя, в файле “.qtenvrc” (Windows):
</p>
<br /><source lang="dos">%USERPROFILE%\.qtenvrc</source>
<p><br />
	А Tkenv – хранит в файле “.tkenvrc” (Windows):
</p>
<br /><source lang="dos">%HOMEDRIVE%%HOMEPATH%\.tkenvrc</source>
<p><br />
	Перейдем к настройкам:
</p>
<br /><anchor>fig_qtenv-preferences-buttons</anchor><img alt="qtenv: preferences buttons" align="center" height="305" src="https://habrastorage.org/webt/ot/zv/d4/otzvd45riixelkg4pmglbyj7qvi.png#qtenv-preferences-buttons.png"/>
<p><br />
	Все настройки с небольшими комментариями (а также отключение отображения таймлинии – она редко нужна, и когда не нужна – отвлекает):
</p>
<br /><anchor>fig_qtenv-preferences</anchor><a href="https://habrastorage.org/webt/3u/xm/4a/3uxm4a69lwhudk8gmy126urlx3k.png#qtenv-preferences.png"><img alt="qtenv: preferences" align="center" height="331" src="https://habrastorage.org/webt/3u/xm/4a/3uxm4a69lwhudk8gmy126urlx3k.png#qtenv-preferences.png"/></a>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> Если в Tkenv у объектов в canvas отсутствуют надписи, то в <nobr>Fonts &gt;</nobr> Canvas нужно выбрать векторный шрифт. Надписи отсутствовали из‑за попытки использовать растровый шрифт (например, “MS Sans Serif”).
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> После применения настроек и запуска симуляции (run) в логе будут только события (синие), без детализации (черные), после перезапуска Qtenv детализация вернется.
</p><p><br />
	Также, о настройках написано в “omnetpp-5.0/doc/UserGuide.pdf” (раздел 7.7. “The Preferences Dialog”).
</p>
<br /><h3><anchor>shag-2-detalizaciya-protokola</anchor><a href="#shag-2-detalizaciya-protokola" title="Ссылка на раздел"><font color="gray">#</font></a> Шаг 2: детализация протокола</h3>
<p><br />
	В начале статьи я описал набросок протокола. Настало время его уточнить, чтобы двигаться дальше.
</p><p><br />
	Начнем с синхронизации:
</p>
<blockquote cite="#need-to-sync-all-hosts">
	Основа LLTR – это итерации сбора статистики на множестве хостов во время сканирования сети. Итераций в LLTR много <nobr>( &gt;1)</nobr>, поэтому первое, что нужно включить в протокол – <em>управление</em> запуском и остановкой каждой итерации. Если учесть, что хостов тоже много <nobr>( &gt;1)</nobr>, то <em>управление</em> будет заключаться в том, чтобы определенным способом сообщать всем хостам время начала итерации и время окончания итерации. То есть синхронизировать все хосты.
</blockquote>
<p>
	Первое, что приходит на ум – перед первой (нулевой) итерацией, используя протоколы синхронизации времени – синхронизировать время на всех хостах. Добавим к этому единую точку отсчета (на синхронизированных часах) – время начала первой итерации, которая вкупе с длительностью итерации, позволит каждому из хостов определять точный (+/-) момент начала и окончания каждой итерации. Похоже, это будет работать, если сделать все правильно…, а если сделать неправильно, то получится отличная сцена для комедии:
</p>
<br /><anchor>fig_taxi_4-sync_time</anchor><img alt="Taxi 4:  Жебер: Сверим часы, Генерал: — 16:20, Жебер: — 12:05, созвонимся через два часа!, Генерал: o_O" title="Можно было просто сказать “созвонимся через два часа”" align="center" height="329" src="https://habrastorage.org/webt/h-/cd/zm/h-cdzmvtioda3h2cx5u1kmxdobc.jpeg#taxi_4-sync_time.jpg"/>
<p><br />
	Собираемые данные (для определения снижения скорости / потери пакетов):
</p>
<blockquote cite="#need-to-process-data-at-the-end">
	И последнее. По <em>завершению</em> всех итераций, всю собранную статистику со всех хостов нужно отправить на один хост для обработки. Этот хост проанализирует собранную статистику, и построит топологию сети.
</blockquote>
<p>
	Опять же, первое, что приходит на ум – на хостах, записываем время прихода каждого пакета. По этим данным можно построить гистограмму, можно анализировать задержку между получением пакетов, …
</p>
<br /><spoiler title="Либо…"><hr />
	<p>
		Либо, broadcast src хост последовательно нумерует все пакеты, а на остальных хостах записываются номера пришедших пакетов.
	</p>
<hr /></spoiler>
<p><br />
	Но это все слишком усложняет реализацию. Для синхронизации хостов нужно будет полностью реализовать протокол для синхронизации времени. К тому же – это дополнительный шаг – мы не сможем начать сканирование сети пока не синхронизируем время на всех хостах. А если во время этого процесса пропадут пакеты… таймауты, ретрансмиты…
</p><p><br />
	Тоже самое и с хранением времени всех пришедших пакетов с последующей отправкой этих данных на один хост для обработки. Слишком много данных придется хранить и передавать по сети, а затем, все эти данные должен обработать один хост…
</p><p><br />
	Есть ли более простой, надежный и элегантный способ реализовать задуманное?
</p><p><br />
	С отправкой данных все достаточно просто. Каждый из хостов мог бы независимо произвести предварительную обработку своих данных (свернуть их; local-reduce; <a href="https://ru.wikipedia.org/wiki/MapReduce?stable=1">map</a>) перед отправкой их на центральный хост (<a href="https://ru.wikipedia.org/wiki/MapReduce?stable=1">reduce</a>) – это уменьшит количество передаваемых данных и ускорит расчет.
</p><p><br />
	А вот с синхронизацией все интереснее.
</p>
<br /><h4><anchor>protokol-versiya-v_basic_global-wave</anchor><a href="#protokol-versiya-v_basic_global-wave" title="Ссылка на раздел"><font color="gray">#</font></a> Протокол, версия v.Basic.GlobalWave</h4>
<p><br />
	Если посмотреть внимательней, то у нас уже есть то, что позволит всем хостам работать синхронно.
</p><p><br />
	Что нам нужно? Нужно определенным способом сообщать всем хостам момент начала итерации и момент окончания итерации.
</p><p><br />
	А кто заполняет своими пакетами всю сеть (вещает свои пакеты на всю сеть) на каждой итерации? Это broadcast src хост (LLTRSuperApp).
</p><p><br />
	⇒ Достаточно поместить, в каждый broadcast пакет, номер текущей итерации, и все хосты смогут определить:
</p>
<br /><ul>
	<li>номер текущей итерации;</li>
	<li>момент окончания предыдущей и начало следующей итерации – по увеличению номера текущей итерации в очередном принятом пакете;</li>
	<li>текущий unicast src и unicast dst хост – исходя из номера итерации.</li>
</ul>
<p><br />
	Причем, последний пункт позволяет нам закрыть еще один раздел протокола:
</p>
<blockquote cite="#need-to-select-unicast-src-dst">
	В каждой итерации есть свой unicast src хост и unicast dst хост, поэтому следующее, что нужно включить – способ <em>назначения</em> для каждой итерации unicast src и dst. То есть в каждой итерации один из хостов должен “осознавать” себя unicast src хостом, цель которого посылать трафик на unicast dst хост.
</blockquote>
<p>
	У этого решения есть и недостаток – изначально предполагалось, что broadcast src и unicast src хост стартуют (начинают отправлять пакеты) одновременно. Сейчас же unicast src хост будет стартовать с задержкой относительно broadcast src хоста.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> Вообще‑то нам не важно стартуют ли broadcast src и unicast src хост одновременно или нет, важно другое – одновременно ли их первые пакеты в итерации достигают unicast dst хоста. Допустим также вариант, когда пакеты от unicast src начинают приходить первыми, но тогда и последний пакет unicast src должен прийти не ранее последнего пакета broadcast src. То есть временной диапазон принятия unicast src пакетов на unicast dst хосте должен покрывать соответствующий временной диапазон принятия broadcast src пакетов.
</p><p><br />
	Также хосты могут (и будут) иметь разное расстояние (время передачи пакета) до broadcast src хоста, это приведет к тому, что время начала и окончания итерации у каждого хоста будет свое, т.е. будет отличаться.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> это не хорошо и не плохо, это просто нужно будет учитывать в будущем.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> Представьте космос, звезды, и наблюдение за ними… (время распространения сигнала)
</p><p><br /><anchor>protokol-versiya-v_basic_global-wave--unicast-src-dst</anchor>
	На текущий момент, реализация протокола unicast src/dst хостов (LLTRApp) должна выполнить следующие действия:
</p>
<br /><ol>
	<li>В начале: “разогреть” (заполнить) ARP‑таблицы в хостах и MAC‑таблицы в свитчах. Зачем это нужно – описано ниже. Как это реализовать: все хосты начинают одновременно, каждый из хостов последовательно отправляет пустой UDP пакет на <a href="https://en.wikipedia.org/wiki/Discard_Protocol?stable=1">discard порт 9</a> на все остальные хосты (включая broadcast src хост).</li>
	<li>Слушать порт, на который будут приходить broadcast пакеты от broadcast src хоста, и по содержимому приходящих пакетов – определять номер текущей итерации.</li>
	<li>Если началась новая итерация, и в ней текущей хост является unicast src хостом, то запустить отправку <strong>m</strong> пакетов на unicast dst хост.</li>
	<li>Собирать статистику по пакетам в текущей итерации: подсчитывать количество принятых broadcast пакетов от broadcast src хоста.</li>
	<li>В конце: ожидать входящего TCP подключения, и передать по нему собранную статистику по каждой итерации.</li>
</ol>
<p><br />
	Зачем нужен 1‑й шаг: посмотрите логи предыдущих симуляций – вначале эти таблицы пусты, и хосты вынуждены использовать ARP запросы для определения MAC‑адреса других хостов. То же самое касается и свитчей. А теперь представьте, что во время 3‑го шага, вместо отправки наших пакетов, отправляется ARP‑запрос… Через какое время он достигнет unicast dst хоста? И достигнет ли его вообще?
</p><p><br /><anchor>protokol-versiya-v_basic_global-wave--broadcast-src-must</anchor>
	Реализация протокола broadcast src хоста (LLTRSuperApp) должна:
</p>
<br /><ol>
	<li>В начале: дождаться завершения первого шага unicast src/dst хостов (LLTRApp).</li>
	<li>Посылать <strong>m</strong> broadcast пакетов в каждой итерации, и в каждый пакет записывать номер текущей итерации.</li>
	<li>После каждой итерации делать паузу. Пауза нужна для опустошения очередей пакетов в свитчах. Если не дождаться опустошения очередей, то текущая итерация будет влиять на следующую итерацию, и исказит ее статистику.</li>
	<li>В конце: оповестить unicast src/dst хосты о завершении последней итерации, и последовательно подключаясь по TCP к каждому unicast src/dst хосту, загрузить статистику.</li>
</ol>
<p><br />
	Количество пакетов (<strong>m</strong>) выбирается исходя из:
</p>
<br /><ul>
	<li>их должно быть достаточно, чтобы “залить” (заполнить) всю подсеть (в данном случае под подсетью понимается unicast src/dst хосты, broadcast src хост, и промежуточное оборудование, соединяющее их – свитчи + кабели);</li>
	<li>их должно быть достаточно, чтобы они смогли потеряться (потеря пакетов будет происходить при одновременном “вливании” свитчем broadcast и unicast пакетов в один и тот же порт, с последующим переполнением очереди пакетов этого порта, т.е. количества пакетов должно быть достаточно для переполнения очереди);</li>
	<li>их должно быть достаточно, чтобы на собранных данных (статистике), падения скорости (потеря пакетов) были хорошо различимы, для алгоритма, который будет выявлять эти самые падения скорости;</li>
	<li>их должно быть минимальное количество, чтобы минимизировать время сканирования сети, и минимизировать негативное воздействие сканирования на сеть.</li>
</ul>
<p><br />
	Про количество итераций уже было сказано в <a href="https://habr.com/post/414799/#lltr-basic">предыдущей статье</a>.
</p><p><br />
	Для передачи статистики, в модели, мы могли бы использовать UDP вместо TCP, и это даже работало бы, но в реальном приложении я бы предпочел использовать протокол с гарантией (проверкой) доставки данных, поэтому и в модели лучше использовать соответствующий протокол.
</p><p><br />
	Здесь есть еще несколько нюансов, мы с ними столкнемся, когда будем создавать модель, и смотреть на результаты симуляции ；）В общем, скучать не придется.
</p>
<br /><h3><anchor>shag-3-rasshiryaem-model-tcpudp-app</anchor><a href="#shag-3-rasshiryaem-model-tcpudp-app" title="Ссылка на раздел"><font color="gray">#</font></a> Шаг 3: расширяем модель (TCP+UDP app…)</h3>
<p><br />
	Мы уже посмотрели, как в INET нужно работать с UDP, но для полноценной модели нужен еще и TCP. Посмотрим на примеры работы с TCP, и попробуем добавить в “LLTRSuperApp” и “LLTRApp” передачу данных по TCP.
</p><p><br />
	Примеры:
</p>
<br /><ul>
	<li>самое простое приложение из “<a href="https://github.com/inet-framework/inet/tree/v3.4.0/src/inet/applications/tcpapp">tcpapp</a>” – это “TCPSinkApp” (<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/tcpapp/TCPSinkApp.h">h</a>, <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/tcpapp/TCPSinkApp.cc">cc</a>, <a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/tcpapp/TCPSinkApp.ned">ned</a>);</li>
	<li>примеры использования “<code>TCPSocket</code>” в “inet-manual-draft.pdf” (глава 14.5 “TCP socket”; страница 121).</li>
</ul>
<p><br />
	Как видно из примеров, в “LLTRSuperApp.cc” достаточно дописать:
</p>
<br /><source lang="cpp">//...
#include &quot;inet/transportlayer/contract/tcp/TCPSocket.h&quot;

namespace inet {
class INET_API LLTRApp: public cSimpleModule, <strong>public TCPSocket::CallbackInterface</strong>
{
       //...
       int gateTcpId;
       TCPSocket socketTcp;
       //...
       void initialize(int stage)
       {
             //...
             switch(stage){
             case INITSTAGE_LOCAL:
                    //...
                    gateTcpId = gateBaseId(&quot;tcpIn&quot;);
                    //...
                    break;
             case INITSTAGE_APPLICATION_LAYER:
                    //...
                    socketTcp.setOutputGate(gate(&quot;tcpOut&quot;));
                    socketTcp.setDataTransferMode(TCP_TRANSFER_BYTECOUNT);
                    socketTcp.setCallbackObject(this);
                    //...
                    break;
             case INITSTAGE_LAST:
                    //...
                    socketTcp.connect(IPv4Address(10,0,1,2), port+1);
                    //...
                    break;
             }
       }

       void handleMessage(cMessage *msg)
       {
             if(msg-&gt;arrivedOn(gateTcpId) &amp;&amp; socketTcp.belongsToSocket(msg)) socketTcp.processMessage(msg);
             else delete msg;
       }

       void socketDataArrived(int, void*, cPacket *msg, bool)
       {
             socketTcp.close();

             EV &lt;&lt; &quot;Arrived (TCP): &quot; &lt;&lt; msg-&gt;getName() &lt;&lt; endl;

             delete msg;
       }

       void socketPeerClosed(int, void*)
       {
             socketTcp.close();
       }
       //...
};
//...
}</source>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> Чтобы определить предназначен ли пакет для определенного сокета, обычно используется метод “<code>belongsToSocket()</code>”, но он медленный (внутри неоднократно используется “<code>dynamic_cast</code>”). Поэтому вначале лучше проверить, что пришел именно TCP пакет. Самый быстрый способ это сделать – это посмотреть через какой “gate” пришел пакет. Все UDP пакеты приходят через свой “<code>udpIn</code>” “gate”, а TCP будут приходить через “<code>tcpIn</code>”. Для того чтобы проверить факт прихода пакета через “<code>tcpIn</code>”, используют метод “<code>arrivedOn()</code>”, он очень быстрый – внутри всего лишь проверяется равенство двух целочисленных переменных.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> если в модуле создается только один TCP сокет, то “<code>belongsToSocket()</code>” проверку можно отбросить, оставив только “<code>arrivedOn()</code>”.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> разный номер порта для TCP (“<code>port+1</code>”) и UDP – мне помогал быстро ориентироваться в логе симуляции, в следующих версиях номера портов (TCP и UDP) будут совпадать.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> я бы не хотел останавливаться на деталях реализации TCP в INET, при том, что это описано в доках, а как воспринимать доки я думаю вы уже поняли (читая исходники ；）, однако хочу немного пояснить картину: “<code>setCallbackObject(this)</code>” напрямую связан с появлением множественного наследования “<code>, public TCPSocket::CallbackInterface</code>”, и с появлением новых методов “<code>socketDataArrived()</code>” и “<code>socketPeerClosed()</code>”, которые вызываются внутри “<code>processMessage()</code>”.
</p><p><br />
	В “LLTRSuperApp.ned” допишем:
</p>
<br /><source lang="cpp">//...
import inet.applications.contract.ITCPApp;

simple LLTRSuperApp like IUDPApp, <strong>ITCPApp</strong>
{
   //...
   gates:
        //...
        input  tcpIn  @labels(TCPCommand/up);
        output tcpOut @labels(TCPCommand/down);
   //...
}</source>
<p><br />
	В “LLTRApp.cc”:
</p>
<br /><source lang="cpp">//...
#include &quot;inet/transportlayer/contract/tcp/TCPSocket.h&quot;

namespace inet {
class INET_API LLTRApp: public cSimpleModule, <strong>public TCPSocket::CallbackInterface</strong>
{
       //...
       int gateTcpId;
       TCPSocket socketTcp;
       //...
       void initialize(int stage)
       {
             //...
             switch(stage){
             case INITSTAGE_LOCAL:
                    //...
                    gateTcpId = gateBaseId(&quot;tcpIn&quot;);
                    //...
                    break;
             case INITSTAGE_APPLICATION_LAYER:
                    //...
                    socketTcp.setOutputGate(gate(&quot;tcpOut&quot;));
                    socketTcp.setDataTransferMode(TCP_TRANSFER_BYTECOUNT);
                    socketTcp.setCallbackObject(this);
                    socketTcp.bind(port+1);
                    socketTcp.listenOnce();
                    //...
                    break;
             }
       }

       void handleMessage(cMessage *msg)
       {
             if(msg-&gt;arrivedOn(gateTcpId)){
                    socketTcp.processMessage(msg);
                    return;
             }
             //...
       }

       void socketEstablished(int, void*)
       {
             socketTcp.send(new cPacket(&quot;=TCP Packet=&quot;));
       }

       void socketDataArrived(int, void*, cPacket*, bool)
       {

       }

       void socketPeerClosed(int, void*)
       {
             socketTcp.close();
             socketTcp.renewSocket();
             socketTcp.bind(port+1);
       }
       //...
};
//...
}</source>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> Мы используем самый простой (без создания нового сокета для каждого нового соединения; “non-forking”) режим прослушивания TCP порта – “одноразовый сокет” (метод “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/tcp/TCPSocket.h#L292-L298"><code>listenOnce()</code></a>”). Для принятия новых соединений, после закрытия текущего соединения, нужно вызвать методы “<code>renewSocket()</code>” и “<code>bind()</code>”.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> Метод “<code>socketDataArrived()</code>” (<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/tcp/TCPSocket.h#L139">чистая виртуальная функция “<code>=0</code>”</a>) пустой, т.к. мы не ожидаем входящих данных, и в нем отсутствует “<code>delete msg</code>”, чтобы, если все‑таки что‑то придет, <nobr>OMNeT++</nobr> сообщил об “утечке пакетов”. Однако, можно было здесь же вывести сообщение о проблеме и удалить пакет.
</p><p><br />
	В “LLTRApp.ned”:
</p>
<br /><source lang="cpp">//...
import inet.applications.contract.ITCPApp;

simple LLTRApp like IUDPApp, <strong>ITCPApp</strong>
{
   //...
   gates:
        //...
        input  tcpIn  @labels(TCPCommand/up);
        output tcpOut @labels(TCPCommand/down);
   //...
}</source>
<p><br />
	Поясню, что “LLTRSuperApp” и “LLTRApp” должны будут сделать:
</p>
<br /><ol>
	<li>“LLTRSuperApp” устанавливает соединение с “LLTRApp”;</li>
	<li>“LLTRApp” отправляет в ответ пакет “<code>=TCP Packet=</code>”;</li>
	<li>“LLTRSuperApp” закрывает соединение, и выводит имя полученного пакета;</li>
	<li>“LLTRApp” “обновляет” (“<code>renewSocket()</code>”) свой сокет.</li>
</ol>
<p><br />
	Осталось прописать приложения в хостах (связать “gate” c приложением). Для этого добавим в “omnetpp.ini” строчки:
</p>
<br /><source lang="ini">[General]
//...
**.host0.tcpApp[0].typename = &quot;inet.applications.lltrapp.LLTRSuperApp&quot;
//...
**.host?.numTcpApps = 1
**.host?.tcpApp[0].typename = &quot;inet.applications.lltrapp.LLTRApp&quot;
**.host?.tcpApp[0].port = 1100</source>
<p><br /><anchor>git-tag-a1_v0-21-0</anchor>
	Должно получиться <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/commit/50e4596f90a570aaf468a489f004cc40b816c0b7">примерно так (git tag a1_v0.21.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.20.0...a1_v0.21.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>.
</p><p><br />
	Соберем, запустим, и… (как уже поняли, я бы не стал описывать это, если бы здесь не было интересного момента с ошибкой ；）
</p>
<br /><anchor>fig_qtenv-host0-TCP_Error</anchor><img alt="Error in module (inet::LLTRSuperApp) Network.host0.tcpApp[0] (id=74) during network initialization: send()/sendDelayed(): gate `udpOut' not connected." align="center" height="94" src="https://habrastorage.org/webt/rs/bg/nv/rsbgnvywxfyll1jt39colle9t2w.png#qtenv-host0-TCP_Error.png"/>
<p><br />
	Заглянем внутрь “host0”, и посмотрим, почему “<code>udpOut</code>” не подключен:
</p>
<br /><anchor>fig_qtenv-in_host0-double_app</anchor><img alt="qtenv: in host0 – double app" align="center" height="454" src="https://habrastorage.org/webt/em/g0/st/emg0stpshdwk-usfwjr4020265c.png#qtenv-in_host0-double_app.png"/>
<p><br />
	Сюрприз, появилось два “LLTRSuperApp”: один подключен к “udp” модулю, а другой к “tcp”, именно поэтому появилась ошибка – у “tcp” попросту нет “<code>udpOut</code>”. Но нам важно не это, а то, что теперь в каждом хосте стало по два экземпляра приложения, а нам нужен только один экземпляр в каждом хосте.
</p><p><br />
	Собственно это уже было ясно при редактировании “omnetpp.ini” – мы указали “<code>inet.applications.lltrapp.LLTR*App</code>” в нескольких точках подключения, вот он и создал их несколько…
</p><p><br />
	Похоже, используя “StandardHost” не удастся объединить в одном приложении работу с UDP, и с TCP. Нам ничего не остается, как сделать свой “StandardHost”, и, заодно, выкинуть все лишние части.
</p>
<br /><anchor>fig_Fast_Furious_8-nothing_extra</anchor><img alt="The Fast and the Furious 8 – nothing extra" align="center" height="240" src="https://habrastorage.org/webt/8k/hc/rf/8khcrfiwpztad1qgtx_0o0argru.jpeg#Fast_Furious_8-nothing_extra.jpg"/>
<br /><h4><anchor>simpleudptcphost-i-itcpudpapp</anchor><a href="#simpleudptcphost-i-itcpudpapp" title="Ссылка на раздел"><font color="gray">#</font></a> SimpleUdpTcpHost и ITcpUdpApp</h4>
<p><br /><anchor>git-tag-a1_v0-22-0</anchor>
	Создадим “SimpleUdpTcpHost” на основе “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/node/inet/StandardHost.ned">StandardHost</a>”, и “ITcpUdpApp” объединяющий “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/contract/IUDPApp.ned">IUDPApp</a>” с “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/contract/ITCPApp.ned">ITCPApp</a>”. Получилось <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/commit/f24375a14ef0ce741fb1d6dc76b412efa8aec87f">так (git tag a1_v0.22.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.21.0...a1_v0.22.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>.
</p>
<br /><anchor>fig_SimpleUdpTcpHost</anchor><img alt="SimpleUdpTcpHost" align="center" height="547" src="https://habrastorage.org/webt/mp/cb/sr/mpcbsrsqt00a9314mthbhozkm8e.png#SimpleUdpTcpHost.png"/>
<p><br /><anchor>git-tag-a1_v0-23-0</anchor>
	Осталось перевести модель на использование нового хоста и интерфейса. Получилось <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/commit/dc4d28f4142c1c8c0c2f691aaf8e377b366a77fa">так (git tag a1_v0.23.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.22.0...a1_v0.23.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>.
</p><p><br />
	Попробуем собрать и запустить… Ошибок нет. Запускаем симуляцию (run):
</p>
<br /><anchor>fig_qtenv-App-Events-tcp-zero_size</anchor><img alt="qtenv: App Events – tcp – zero size" align="center" height="599" src="https://habrastorage.org/webt/up/si/-c/upsi-csbvs0sns22749_gxds7j0.png#qtenv-App-Events-tcp-zero_size.png"/>
<p><br />
	Соединение установилось, но пакет “<code>=TCP Packet=</code>” не дошел до “LLTRSuperApp”, и “LLTRSuperApp”, соответственно, не вывел надпись “<code>Arrived (TCP): =TCP Packet=</code>”.
</p><p><br /><anchor>git-tag-a1_v0-24-0</anchor>
	Пакет “<code>=TCP Packet=</code>” виден в событии #155. Детализация события намекает нам, что модуль “tcp” не хочет отправлять данные нулевого размера в режиме “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/contract/tcp/TCPCommand.msg#L122"><code>TCP_TRANSFER_BYTECOUNT</code></a>”. Попробуем задать размер пакета, используя метод “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:messages:cpacket-basic-usage"><code>setByteLength()</code></a>”. Должно получиться <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.24.0/inet/src/inet/applications/lltrapp/LLTRApp.cc#L77">примерно так (git tag a1_v0.24.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.23.0...a1_v0.24.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>.
</p><p><br />
	Собираем, запускаем, запускаем симуляцию (run) (лог отфильтрован и показан только фрагмент):
</p>
<br /><anchor>fig_qtenv-App-Events-tcp-1byte_size</anchor><img alt="qtenv: App Events – tcp – 1 byte size" align="center" height="435" src="https://habrastorage.org/webt/kz/vx/oj/kzvxojuhljpxqzbmyfaww_enroe.png#qtenv-App-Events-tcp-1byte_size.png"/>
<p><br />
	Теперь “tcp” отправил “<code>=TCP Packet=</code>”, но его имя изменилось на “<code>tcpseg(l=1)</code>”. А по прибытии в “LLTRSuperApp” он стал называться просто “<code>data</code>” – “<code>Arrived (TCP): data</code>”.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> опционально, в “omnetpp.ini” можно прописать настройки для TCP стека:
</p>
<br /><source lang="ini">**.tcp.delayedAcksEnabled = true
**.tcp.increasedIWEnabled = true
**.tcp.sackSupport = true
**.tcp.windowScalingSupport = true
**.tcp.timestampSupport = true</source>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> также можно задать “<a href="https://habrahabr.ru/post/168407/#comment_5834315">TCP congestion control algorithm</a>”, указав “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/transportlayer/tcp/flavours/README"><code>tcpAlgorithmClass</code></a>” (доступно <a href="https://github.com/inet-framework/inet/tree/v3.4.0/src/inet/transportlayer/tcp/flavours">несколько алгоритмов</a> на выбор).
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> Если не закрывать сокет “<code>socketTcp.close()</code>” в методе “<code>socketPeerClosed()</code>” (в “LLTRApp”), то симуляция завершится быстрее (на 240 <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:discrete-event-simulation">моделируемых секунд</a> быстрее – это длительность <abbr title="2 × Maximum Segment Lifetime">2MSL</abbr>), но ни один из сокетов не перейдет в состояние “CLOSED”. Последнее состояние для сокета в “LLTRSuperApp” будет “FIN_WAIT_2”, а для “LLTRApp” – “CLOSE_WAIT”. <a href="https://raw.githubusercontent.com/inet-framework/inet/v3.4.0/src/inet/transportlayer/tcp/tcpstate.png">Картинка‑напоминатель про состояния TCP</a>.
</p>
<br /><h4><anchor>pomeschaem-hosty-v-vektor</anchor><a href="#pomeschaem-hosty-v-vektor" title="Ссылка на раздел"><font color="gray">#</font></a> Помещаем хосты в вектор</h4>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> в этот момент мне пришла идея поместить все хосты в вектор… я был столь наивен… <strong>Не делайте этого</strong>!
</p><p><br />
	Чем нам это поможет? Сейчас мы для соединения с “host1” используем его IP‑адрес “10.0.1.2”. Однако, все адреса распределяются автоматически, и не факт, что “host1” всегда будет иметь адрес “10.0.1.2”. Например, если сейчас в “package.ned” переподключить один из хостов (“host3”) к другому свитчу, то хосты поменяют свои IP‑адреса. Поэтому нужно обращаться к хосту не по IP‑адресу, а по его имени.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> используя имя хоста, можно получить его точный IP‑адрес:
</p>
<br /><source lang="cpp">const L3Address getIPByHostPath(const char *path)
{
       IInterfaceTable *inet_ift = dynamic_cast&lt;IInterfaceTable*&gt;(
            getModuleByPath(path)-&gt;getSubmodule(&quot;interfaceTable&quot;));

       return inet_ift-&gt;getInterfaceById( inet_ift-&gt;getBiggestInterfaceId() )
                      -&gt;getNetworkAddress();
}</source>
<p><br />
	Так чем же нам поможет помещение хостов в вектор? Можно будет использовать метод “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:walking-up-and-down-module-hierarchy"><code>getSubmodule()</code></a>” для обращения к хостам. Например, чтобы получить “host1” (новое полное имя – “<code>&quot;host[1]&quot;</code>”, сокращенное – “<code>&quot;host&quot;</code>”) достаточно написать:
</p>
<br /><source lang="cpp">getSimulation()-&gt;getSystemModule()-&gt;getSubmodule(&quot;host&quot;, 1);</source>
<p><br />
	Этим же способом можно легко перебрать все хосты в цикле:
</p>
<br /><source lang="cpp">cModule *sysModule = getSimulation()-&gt;getSystemModule();
for(std::ptrdiff_t i=0; i&lt;length; i++){  //length – vector size (number of hosts)
       cModule *host = sysModule-&gt;getSubmodule(&quot;host&quot;, i);
       // do something...
}</source>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> без использования вектора, на каждой итерации пришлось бы создавать строки (“<code>&quot;host0&quot;</code>”, “<code>&quot;host1&quot;</code>”, “<code>&quot;host2&quot;</code>”, …, “<code>&quot;host121&quot;</code>”).
</p><p><br />
	Как же поместить хосты в вектор?
</p><p><br />
	В “<nobr>OMNeT++</nobr> – Simulation Manual” есть <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-lang:parameter-assignments">пример создания вектора из 100 хостов</a>:
</p>
<br /><source lang="cpp">network Network
{
    submodules:
        host[100]: Host {
            ping.timeToLive = default(3);
            ping.destAddress = default(0);
        }
        ...
}</source>
<p><br />
	Отлично, мы можем сразу же задать общие параметры для всех хостов в векторе!
</p><p><br />
	А как задать индивидуальные параметры для конкретного хоста в векторе? Мы размещали каждый хост в определенной точке на холсте, и хотели бы сохранить это расположение. В <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-lang:parameter-assignments">том же разделе</a> “<nobr>OMNeT++</nobr> - Simulation Manual” есть пример как сделать это:
</p>
<br /><source lang="cpp">network Network
{
    parameters:
        host[*].ping.timeToLive = default(3);
        host[0..49].ping.destAddress = default(50);
        host[50..].ping.destAddress = default(0);

    submodules:
        host[100]: Host;
        ...
}</source>
<p><br />
	Все просто. Однако расположение хоста задается через запись “<code>@display(&quot;p=149,269&quot;);</code>”, и ни один из этих попыток задать “<code>@display</code>” (<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:graphics:display-strings">display string</a>) не сработает:
</p>
<br /><source lang="cpp">host[0].@display = &quot;p=149,269&quot;;
host[0].display = &quot;p=149,269&quot;;
host[0].@display(&quot;p=149,269&quot;);
host[0]@display(&quot;p=149,269&quot;);
host[0]{ @display(&quot;p=149,269&quot;); }
host[0] = { @display(&quot;p=149,269&quot;); }
host[0] = @display(&quot;p=149,269&quot;);
...</source>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> через “инспектор объектов” (grouped mode) Qtenv можно посмотреть где находится display string, а где остальные параметры.
</p><p><br />
	Список дальнейших действий:
</p>
<br /><ol>
	<li>Мы не можем задать “<code>@display</code>”, но мы можем использовать <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:graphics:displaystring-parameter-substitution">parameter substitution</a> (<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:graphics:submodule-positioning">альтернатива</a> для расположения: в строку, в столбец, в сетку, по кругу).</li>
	<li>Мы не можем добавлять новые параметры в модуль, но можем <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ned-lang:compound-modules">создать новый тип</a> (“<code>types:</code>”), расширяющий (“<code>extends</code>”) существующий модуль.</li>
	<li>Осталось переписать конфиги на использование новых хостов, и стереть создание старых хостов.</li>
</ol>
<p><br />
	В итоге получилось так (ветка <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/tree/hosts-in-vector/LLTR/simulations">hosts-in-vector</a>, коммт “<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/commit/f479cf4feff4c66a6547bd537151bbe44c9aeb4d">Put hosts in vector</a>”).
</p><p><br />
	При этом сеть, в визуальном редакторе <nobr>OMNeT++</nobr>, превратилась в это:
</p>
<br /><anchor>fig_hosts_in_vector-omnetpp_ide</anchor><img alt="hosts in vector – OMNeT++ IDE" align="center" height="451" src="https://habrastorage.org/webt/2b/pz/ag/2bpzagphgajvsgyb_kr--fmi8cq.png#hosts_in_vector-omnetpp_ide.png"/>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> в симуляторе все выглядит нормально.
</p><p><br />
	Мы потеряли возможность задавать местоположение хостов через визуальный редактор, но хотя бы теперь мы можем взять адрес вектора и быстро получить адрес на объект нужного хоста.
</p><p><br />
	Кстати, а при помощи какой функции можно получить адрес вектора или итератор по вектору?<br />
	Ответ: <strong>такой функции нет</strong>, как нет и вектора – сейчас (<nobr>OMNeT++</nobr> v5.0) это всего лишь <strong>иллюзия</strong>!
</p><p><br />
	А метод “<a href="https://omnetpp.org/doc/omnetpp/api/classomnetpp_1_1cModule.html#affd762a971a066ee031c98c709369ba8"><code>getSubmodule()</code></a>” работает так (из файла “omnetpp-5.0/src/sim/cmodule.cc”):
</p>
<br /><source lang="cpp">cModule *cModule::getSubmodule(const char *name, int index) const
{
    for (SubmoduleIterator it(this); !it.end(); ++it) {
        cModule *submodule = *it;
        if (submodule-&gt;isName(name) &amp;&amp; ((index == -1 &amp;&amp; !submodule-&gt;isVector()) || submodule-&gt;getIndex() == index))
            return submodule;
    }

    return nullptr;
}</source>
<p><br />
	То есть, он полностью перебирает все подмодули текущего модуля, в поисках совпадения по имени и “<code>isVector()</code>”…
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> однажды мне пришла идея поместить все хосты в вектор… я был столь наивен…<strong> Не делайте этого</strong>!
</p>
<br /><h3><anchor>shag-4-realizaciya-protokola-versiya-v_basic_global-wave</anchor><a href="#shag-4-realizaciya-protokola-versiya-v_basic_global-wave" title="Ссылка на раздел"><font color="gray">#</font></a> Шаг 4: реализация протокола (версия v.Basic.GlobalWave)</h3>
<p><br />
	Вначале сделаем имена у хостов более удобными для дальнейшего использования. Как было сказано в разделе “<a href="#pomeschaem-hosty-v-vektor">Помещаем хосты в вектор</a>”, надежнее будет перейти, при обращении к хостам, от обращения по IP‑адресу к обращению по имени хоста (“<code>&quot;host#&quot;</code>”). Чуть ниже я буду использовать несколько формул для расчета номера “<code>#</code>” unicast src/dst хоста. В этих формулах предполагается, что индексация “<code>#</code>” unicast src/dst хостов начинается с “<code>0</code>”. На данный момент номер “<code>0</code>” занят под broadcast src хост, поэтому переименуем его в “<code>hostS</code>” (“<code>S</code>” – “LLTR<strong>Super</strong>App”), а все остальные хосты (unicast src/dst) переиндексируем, начиная с “<code>0</code>”:
</p>
<br /><ul>
	<li>“<code>host1</code>” → “<code>host0</code>”;</li>
	<li>“<code>host2</code>” → “<code>host1</code>”;</li>
	<li>“<code>host3</code>” → “<code>host2</code>”.</li>
</ul>
<p><br />
	Также нужно подправить имена хостов в “omnetpp.ini” файле.
</p><p><br />
	Теперь займемся соответствием последнего октета IP‑адреса номеру хоста. Забегая вперед, скажу, что бывали случаи, когда, при просмотре лога симуляции, обращаешь внимание не на номер хоста, а на последний октет IP‑адреса. Например, видишь адрес “10.0.1.<strong>2</strong>”, и думаешь про “host<strong>2</strong>”, а на самом деле это “host<strong>1</strong>” (до переименования/переиндексации). Чтобы при просмотре лога у вас не возникало путаницы, сделаем так, чтобы у “host0” был адрес “10.0.1.0”, у “host1” – “10.0.1.1”, и т.д. (файл “config.xml” для “IPv4NetworkConfigurator”):
</p>
<br /><source lang="xml">&lt;config&gt;
   &lt;interface hosts='*.hostS' address='10.0.0.88' netmask='255.255.254.0'/&gt;
   &lt;interface hosts='*.host0' address='10.0.1.0'  netmask='255.255.254.0'/&gt;
   &lt;interface hosts='*'       address='10.0.1.x'  netmask='255.255.254.0'/&gt;
&lt;/config&gt;</source>
<p><br />
	Что мы сделали:
</p>
<br /><ul>
	<li>уменьшили маску /24 до /23, т.к. адрес “10.0.1.0” при маске /24 – это <a href="https://ru.wikipedia.org/wiki/IP-адрес?stable=1#Сравнение">адрес сети</a>;</li>
	<li>отделили адрес “hostS” (“10.0.<strong>0</strong>.88”) от адресов остальных хостов (“10.0.<strong>1</strong>.*”), и дали ему заметный (в логе) номер (“10.0.0.<strong>88</strong>”).</li>
</ul>
<p><br />
	Теперь адреса хостов стали следующими:
</p>
<br /><ul>
	<li>“hostS” – “10.0.0.88”;</li>
	<li>“host0” – “10.0.1.0”;</li>
	<li>“host1” – “10.0.1.1”;</li>
	<li>“host2” – “10.0.1.2”.</li>
</ul>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> для быстрого просмотра IP‑адресов, я закомментировал “<code>#**.interfaceTable.displayAddresses = false</code>” в “omnetpp.ini”.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> Если изменить адрес хоста “<code>*.host0</code>” на “10.0.1.11”, то остальные хосты (“<code>*</code>”; “<code>10.0.1.x</code>”) получат адреса, начиная с “10.0.1.12”, т.е. при использовании “<code>x</code>” просматривается <em>последний назначенный адрес</em> в этом диапазоне, и выбирается следующий не назначенный адрес после <em>него</em>. Можете посмотреть, что будет, в следующих ситуациях (“<code>*.host0</code>”-“<code>*</code>”): “<code>10.0.0.254</code>”-“<code>10.0.x.x</code>”, “<code>10.0.1.254</code>”-“<code>10.0.1.x</code>” (упс) и “<code>10.0.0.87</code>”-“<code>10.0.x.x</code>”.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> это соответствие будет соблюдаться для хостов “host0” – “host255”, и по понятным причинам, с “host256” работать уже не будет.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> это соответствие очень легко сломать, достаточно подключить хосты к другим свитчам.
</p><p><br /><anchor>git-tag-a1_v0-25-0</anchor>
	Должно получиться <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/commit/7b421f788cb956ad7941fea752e8b895ab6cb829">примерно так (git tag a1_v0.25.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.24.0...a1_v0.25.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>.
</p><p><br /><anchor>git-tag-a1_v0-26-0</anchor>
	Теперь допишем все остальное… <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/tree/a1_v0.26.0">(git tag a1_v0.26.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.25.0...a1_v0.26.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>
</p>
<br /><anchor>fig_how-to-draw-an-owl</anchor><img alt="How to draw an Owl" align="center" height="522" src="https://habrastorage.org/webt/aq/qb/cu/aqqbcud2n_w0vywbivhkmkipmfq.png#how-to-draw-an-owl.png"/>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> Если описывать реализацию модели LLTR такими же мелкими шажками, какими было описано все предыдущее, то эту статью придется издавать в виде нескольких книжных томов. Поэтому я остановлюсь только на нескольких интересных моментах, важных для понимания устройства и структуры модели.
</p><p><br />
	Лучше начать с “LLTRSuperApp” – он проще, и в нем хорошо видны шаги из <a href="#protokol-versiya-v_basic_global-wave--broadcast-src-must">описания протокола</a>:
</p>
<br /><ol>
	<li>[<strong>INIT</strong>] В начале: дождаться завершения первого шага unicast src/dst хостов (LLTRApp) [<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L120">строка 120</a>].</li>
	<li>[<strong>PROBING</strong>] Посылать <strong>m</strong> [<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L135">строка 135</a>] broadcast пакетов в каждой итерации, и в каждый пакет записывать номер текущей итерации [<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L130">строка 130</a>].</li>
	<li>[<strong>PROBING</strong>] После каждой итерации делать паузу [<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L142">строка 142</a>]…</li>
	<li>[<strong>COLLECT</strong>] В конце: оповестить unicast src/dst хосты о завершении последней итерации [<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L151-L168">строка 151</a>], и последовательно [<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L186">строка 186</a>] подключаясь по TCP [<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L175">строка 175</a>] к каждому unicast src/dst хосту, загрузить статистику [<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L183">строка 183</a>].</li>
</ol>
<p><br />
	Сокращенный вариант <em>потока выполнения программы</em> выглядит так:
</p>
<br /><ul>
	<li>…</li>
	<li>→ <code>initialize(INITSTAGE_LAST)</code> → <code>handleMessage(evFill)</code> → <code>handleFill(INIT)</code> →</li>
	<li>двойной цикл “for” <b>{</b> → <code>handleMessage(evFill)</code> → <code>handleFill(PROBING)</code> → <b>}</b><br />
		(аналог: <code>for(<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L32" title="строка 32">uint32</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L117" title="строка 117">iN=0</a>; <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L140" title="строка 140">iN&lt;combHosts</a>; <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L140" title="строка 140">iN++</a>) for(<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L33" title="строка 33">int</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L118" title="строка 118">pktN=0</a>; <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L135" title="строка 135">pktN&lt;300</a>; <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L135" title="строка 135">pktN++</a>) {...}</code>)</li>
	<li>разделение на 2 <em>потока</em>:
		<ol>
			<li>цикл “for” <b>{</b> → <code>handleMessage(evFill)</code> → <code>handleFill(COLLECT)</code> → <b>}</b><br />
				(аналог: <code>for(<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L33" title="строка 33">int</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L144" title="строка 144">pktN=0</a>; <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L164" title="строка 164">pktN&lt;30</a>; <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L164" title="строка 164">pktN++</a>) {...}</code>)</li>
			<li>:
				<ul>
					<li>→ <code>handleMessage(evStat)</code> →</li>
					<li>цикл “for” <b>{</b> → <code>handleStat()</code> ⤳...⤳ <code>handleMessage(socketStat)</code> → <code>socketDataArrived()</code> → <b>}</b><br />
						(аналог: <code>for(<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L34" title="строка 34">uint32</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L145" title="строка 145">hostN=0</a>; <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L186" title="строка 186">hostN&lt;numHosts</a>; <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L186" title="строка 186">hostN++</a>) {...}</code>)</li>
				</ul>
			</li>
		</ol>
	</li>
	<li>… <code>finish()</code> …</li>
</ul>
<br /><h4><anchor>cikly-s-zaderzhkoy-settimeout--self-messages</anchor><a href="#cikly-s-zaderzhkoy-settimeout--self-messages" title="Ссылка на раздел"><font color="gray">#</font></a> Циклы “с задержкой”: setTimeout() + Self-Messages</h4>
<p><br />
	Если вы периодически пишите на чистом JavaScript, то наверняка уже заметили “<strong><code><a href="http://javascript.ru/settimeout">setTimeout()</a></code></strong>” – с его помощью все “зацикливается”.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> В чистом <nobr>OMNeT++</nobr> “<code>setTimeout()</code>” отсутствует, вместо него используется функция “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:scheduling"><code>scheduleAt()</code></a>”. Разница: “<code>scheduleAt()</code>” принимает абсолютное время, а “<code>setTimeout()</code>” – относительное время. Для “LLTRSuperApp” <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L210-L214" title="строка 210">“<code>setTimeout()</code>” реализован так</a>.
</p><p><br />
	Для создания циклов “с задержкой” также нужны “Event's” (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L29-L30">строки 29,30</a>) – эти сообщения называются “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:simple-modules:self-messages"><strong>Self-Messages</strong></a>”. По сути – это обычные сообщения, <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:msgs:self-messages">которые модуль отправляет сам себе</a> (именно это и происходит при использовании “<code>setTimeout()</code>”).
</p><p><br />
	“Self-Messages” так же, как и другие сообщения в <nobr>OMNeT++</nobr> поступают на обработку в “<code>handleMessage()</code>”, и чтобы отличить их от других сообщений используется метод “<code>isSelfMessage()</code>” (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L103">строка 103</a>).
</p>
<br /><h4><anchor>esche-odin-sposob-sozdaniya-cikla-for</anchor><a href="#esche-odin-sposob-sozdaniya-cikla-for" title="Ссылка на раздел"><font color="gray">#</font></a> Еще один способ создания цикла “for”</h4>
<p><br />
	Цикл получается путем <strong>взаимодействия с другим модулем</strong> (хостом). Так, например, организован цикл “получения статистики с хостов” <b>{</b> → <code>handleStat()</code> ⤳...⤳ <code>handleMessage(socketStat)</code> → <code>socketDataArrived()</code> → <b>}</b> – в нем не используется “<code>setTimeout()</code>”.
</p><p><br />
	Этот цикл начинается в <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L145">(строке 145)</a>, где устанавливается начальное значение счетчика, затем через строки <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L148">(148)</a> (единственное место, в котором используется “<code>setTimeout()</code>”, и используется только для создания задержки) и <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L105">(105)</a> попадает в “<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L173-L176"><code>handleStat()</code></a>”, после чего ждет получения данных от другого хоста. При получении данных, через “<code>handleMessage()</code>” (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L108">строка 108</a>) попадает в “<code>socketDataArrived()</code>”, где счетчик инкрементируется, и проверяется условие выхода (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L186">строка 186</a>).
</p>
<br /><h4><anchor>fayly-msg</anchor><a href="#fayly-msg" title="Ссылка на раздел"><font color="gray">#</font></a> Файлы “.msg”</h4>
<p><br />
	Ранее я упоминал шаги (<strong>INIT</strong>, <strong>PROBING</strong>, <strong>COLLECT</strong>; тип “<code>LLTRStep</code>”), которые используются в “<code>handleFill()</code>”:
</p>
<br /><source lang="cpp">switch(step){
case INIT:
case PROBING:
case COLLECT:
default:
}</source>
<p><br />
	и задаются при отправке пакета на другой хост (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L129">строка 129</a>). IDE подскажет, что они объявлены в “FillPayload_m.h”, но на самом деле этот файл (вместе с “FillPayload_m.cc”) был автоматически сгенерирован из “FillPayload.msg”.
</p><p><br />
	Файлы “<strong>.msg</strong>” (“message definitions”), по сути, представляют собой декларативное описание содержимого пакетов. А всю необходимую “императивную обвязку” <nobr>OMNeT++</nobr> добавит сам во время создания “*_m.cc” и “*_m.h” файлов (они генерируются автоматически, перед компиляцией проекта). В “<nobr>OMNeT++</nobr> - Simulation Manual” <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:graphics:submdule-text-and-tooltip">целая глава</a> отведена только под создание “<strong>.msg</strong>” файлов. Я использовал только базовые возможности “message definitions”, а список всех возможностей <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:msg-defs:summary">приведен в конце той главы</a>.
</p>
<br /><h4><anchor>znachenie-parametra-packetlength-v-ned-i-ini-faylah</anchor><a href="#znachenie-parametra-packetlength-v-ned-i-ini-faylah" title="Ссылка на раздел"><font color="gray">#</font></a> Значение параметра “packetLength” в “.ned” и “.ini” файлах</h4>
<p><br />
	Ранее мы не указывали размер UDP пакета (указывали только для TCP), теперь же, для корректной симуляции, нужно его указать, используя метод “<code>setByteLength()</code>” (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L131">строка 131</a>). Размер пакета задается через параметр “<code>packetLength</code>” (“.ned” файл) в “.ini” файле (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/LLTR/simulations/omnetpp.ini#L22">строка 22</a>).
</p><p><br />
	Опять же <a href="#pkt-content-sizes">ранее, я показывал</a> размер “ETH” (Ethernet II кадр) для “пустого” UDP пакета:
</p>
<blockquote cite="#pkt-content-sizes">
	<font color="#54524F"><b>Note</b>:</font> обратите внимание, что размер содержимого пакета – <nobr>“<strong><code>0 bytes</code></strong>”</nobr>, “<code>UDP</code>” (не поместилось на скриншоте) – <nobr>“<code>8 bytes</code>”</nobr>, “<code>IPv4</code>” – <nobr>“<code>28 bytes</code>”</nobr>, “<code>ETH</code>” – <nobr>“<code>64 bytes</code>”</nobr>, “<code>EtherPhyFrame</code>” – <nobr>“<code>72 bytes</code>”</nobr>.
</blockquote>
<p>
	И, если мы хотим полностью заполнить кадр (увеличить размер “ETH” до максимально возможного значения – <nobr>1518 байт</nobr>; <a href="https://ru.wikipedia.org/wiki/Maximum_transmission_unit?stable=1" title="Maximum Transmission Unit">MTU</a>), то следует установить “<code>packetLength</code>” в значение “<strong><code>1472B</code></strong>”. При этом размеры будут следующими:
</p>
<br /><ul>
	<li>содержимое пакета – <nobr>1472 байт</nobr>;</li>
	<li>UDP – <nobr>1480 байт</nobr>;</li>
	<li>IPv4 – <nobr>1500 байт</nobr>;</li>
	<li>Ethernet II – <nobr>1518 байт</nobr>;</li>
	<li>“EtherPhyFrame” – <nobr>1526 байт</nobr>.</li>
</ul>
<p><br />
	Если разбить на заголовки, то получим:
</p>
<br /><!-- nohighlight --><source lang="bash">1472 + 8:UDP + 20:IPv4 + 18:ETH + 8:EtherPhyFrame</source>
<p><br />
	Все в точности совпадает с тем, что описано в “inet-manual-draft.pdf” (раздел 5.5.1 “Frame types”; страница 27). Но что такое “EtherPhyFrame”? Это синхрослово/<a href="https://habrahabr.ru/post/227729">преамбула</a> + “<a href="https://en.wikipedia.org/wiki/Ethernet_frame?stable=1#Ethernet_packet_–_physical_layer">start frame delimiter</a>” (<a href="https://en.wikipedia.org/wiki/Ethernet_frame?stable=1#Structure">структура заголовков в целом</a>).
</p><p><br />
	Однако, при моделировании я уже успел поварьировать значения задержки между передачей пакетов, и размер пакетов, для достижения приемлемой плотности трафика. Поэтому в “.ini” файле вы не найдете значения “<code>1472B</code>”, вместо него там будет стоять “<strong><code>1446B</code></strong>”. Что, по сути, приводит размер “EtherPhyFrame” <nobr>(1526 байт)</nobr> к размеру IPv4 <nobr>(1500 байт)</nobr>, т.е., в этой версии модели, размер “EtherPhyFrame” составляет <nobr>1500 байт</nobr>.
</p>
<br /><h4><anchor>magicheskie-chisla</anchor><a href="#magicheskie-chisla" title="Ссылка на раздел"><font color="gray">#</font></a> Магические числа</h4>
<p><br />
	Раз уже заговорили про плотность трафика, то продолжим. В <a href="https://habr.com/post/414799/#lltr-basic">предыдущей статье</a> было сказано:
</p>
<blockquote cite="https://habr.com/post/414799/#lltr-basic">
	Что касается скорости broadcast и unicast, то broadcast трафик можно держать в диапазоне <nobr>75%&thinsp;-&thinsp;100%</nobr> от “<a href="https://en.wikipedia.org/wiki/Bit_rate?stable=1#Information_rate">чистой скорости передачи данных</a>” (net bitrate; поиск по “Ethernet 100Base-TX”), а unicast в диапазоне <nobr>80%&thinsp;-&thinsp;100%</nobr>.
</blockquote>
<p>
	Теперь мы можем <a href="https://ru.wikipedia.org/wiki/Maximum_transmission_unit?stable=1#Зависимость_скорости_от_MTU">рассчитать</a> задержку между отправками broadcast пакетов (период отправки пакетов).
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> “чистая скорость передачи данных” (<a href="https://en.wikipedia.org/wiki/Bit_rate?stable=1#Information_rate"><em>net bitrate</em></a>), “пропускная способность” (<a href="https://en.wikipedia.org/wiki/Ethernet_frame?stable=1#Maximum_throughput"><em>throughput</em></a>), “утилизация/использование канала” (<a href="https://en.wikipedia.org/wiki/Throughput?stable=1#Channel_utilization_and_efficiency"><em>channel utilization</em></a>) – означают разные вещи.
</p><p><br />
	В нашей модели сети используется соединения с <em>net bitrate</em> <nobr>100 Мбит/с</nobr> (Fast Ethernet), для которых <a href="https://en.wikipedia.org/wiki/Interpacket_gap?stable=1">межкадровый интервал равен (<nobr>96 [бит] ∕ 100&thinsp;000&thinsp;000 [бит/с] =</nobr> <nobr>0.96 мкс;</nobr> <nobr>96 [бит] ∕ 8 [бит/байт] =</nobr> <nobr>12 байт</nobr>)</a>. Поэтому добавим к размеру “EtherPhyFrame” <nobr>(1500 байт)</nobr> еще <nobr>12 байт</nobr>, и получим итоговый размер одной отправки данных, равный <nobr><strong>1512 байт</strong></nobr>.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> Обычно, при вычислении утилизации канала, размер межкадрового интервала не включается в размер самого кадра (что логично), но нам понадобится смотреть на них (воспринимать их) как на единое целое. Поэтому мы и добавили размер межкадрового интервала к размеру самого кадра. Это, к тому же, позволит использовать более наглядное значение процентов утилизации канала, например, <a href="https://en.wikipedia.org/wiki/Throughput?oldid=788344794#Channel_utilization_and_efficiency">здесь получили 99.22%</a> утилизации канала, у нас же будет 100%.
</p><p><br />
	Поехали:
</p>
<br /><ul>
	<li>период отправки пакетов для <strong>100%</strong> утилизации канала (по сути, в этом случае задержка, между концом одного кадра, и началом другого кадра, будет равна нулю):<br />
		<nobr>1512 [байт] ∕</nobr> <nobr>( 1.0 [%] × 100&thinsp;000&thinsp;000 [бит/с] ∕ 8 [бит/байт] )</nobr> <nobr>× 1&thinsp;000&thinsp;000 [мкс] =</nobr><br />
		<nobr>1512 [байт] ×</nobr> <nobr>( 1.0 [1/%] × 0.08 [мкс/байт] ) =</nobr> <nobr><strong>120.96 мкс</strong>;</nobr></li>
	<li><strong>80%</strong>: 1512 [байт] × ( 1.25 [1/%] × 0.08 [мкс/байт] ) = <strong>151.2 мкс</strong>;</li>
	<li><strong>75%</strong>: 1512 [байт] × ( 1.33 [1/%] × 0.08 [мкс/байт] ) = <strong>161.28 мкс</strong>.</li>
</ul>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> все в точности, как в <a href="https://books.google.ru/books?id=L3Leb1RcwJAC&lpg=PA310&ots=2-MIezJw3i&dq=IEEE%20802.3%2014880&pg=PA310#v=onepage&q=IEEE%20802.3%2014880&f=false">этом расчете для <nobr>10 Мбит/с</nobr></a> из книги “Networking Explained, Second Edition”.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> На самом деле утилизация канала – это не тот параметр, на который мы сейчас должны обращать внимание. Есть более важный параметр. Поясню: например, мы решили использовать 95% от <em>net bitrate</em> что сделает <strong>зазор</strong> между двумя кадрами (в размер кадра включен межкадровый интервал) равным <nobr>605 бит</nobr> или <nobr><strong>75.625 байт</strong></nobr> ( <nobr>⌈ 1512 [байт] ×</nobr> <nobr>(1−0.95) [%] ×</nobr> <nobr>8 [бит/байт] ⌉ ∕</nobr> <nobr>8 [бит/байт] =</nobr> <nobr>⌈ 604.8 [бит] ⌉ ∕</nobr> <nobr>8 [бит/байт] =</nobr> <nobr>605 [бит] ∕</nobr> <nobr>8 [бит/байт] =</nobr> <nobr>75.625 байт</nobr> ). Если взять минимальный размер “EtherPhyFrame” <nobr>(72 байта)</nobr>, и добавить к нему размер межкадрового интервала, то получим <strong>минимально необходимое</strong> “пространство” для отправки кадра – <nobr><strong>84 байта</strong></nobr>. Получается, что созданного нами зазора не достаточно для отправки другими участниками сети своих данных (даже минимального размера; <strong>без накопления</strong> кадров в очереди/буфере промежуточного сетевого оборудования). Теперь можно посчитать <strong>верхний предел</strong> утилизации канала (<em>для нашего случая</em>): <nobr>⌊ 1512 [байт] ∕</nobr> <nobr>( 1512 [байт] + 84 [байта] ) ⌋</nobr> <nobr>= <strong>94%</strong></nobr> <nobr>(<strong>128.68 мкс</strong>)</nobr>.
</p><p><br />
	Просматривая код, возможно, вы уже заметили “магическое число” <strong>136</strong>. Для тех, кто лучше запоминает/оперирует с числами, чем со словами, на ранних этапах разработки лучше всего будет оставить короткие, уникальные и часто используемые константы именно в виде чисел. И так, знакомьтесь <strong>136</strong> – используемый в “LLTRSuperApp” период отправки broadcast пакетов (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L136">строка 136</a> <strong>：）</strong>
</p>
<br /><source lang="cpp">setTimeout(evFill, step, SimTime(136,SIMTIME_US));</source>
<p><br />
	И производные от нее:
</p>
<br /><source lang="cpp">setTimeout(evFill, PROBING, SimTime(136*10,SIMTIME_US));</source>
<source lang="cpp">setTimeout(evFill, step, SimTime(136*100,SIMTIME_US));      //before x10 (136*10)</source>
<source lang="cpp">setTimeout(evFill, COLLECT, SimTime(136*110,SIMTIME_US));</source>
<source lang="cpp">setTimeout(evStat, 0,       SimTime(136*120,SIMTIME_US));</source>
<source lang="cpp">setTimeout(evFill, step, SimTime(136*5,SIMTIME_US));</source>
<p><br />
	Я перебрал несколько значений (запуская симуляции), и <strong>136</strong> меня полностью устроило: во‑первых, оно лежит в диапазоне <nobr>[151.2 (80%)&thinsp;..&thinsp;128.68 (94%)]</nobr>, и может использоваться как в “LLTRSuperApp”, так и в “LLTRApp”; во‑вторых, … а это уже сами далее увидите.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> чтобы быстро менять значения подобных констант во всех точках использования, можно использовать многое: от специальных плагинов для IDE, до записи в виде обычной константы с именем в формате “<code>_#</code>” (а в комментарии описать его сущность), например “<code>_136</code>” (если понадобится временно заменить значение, то просто меняем значение, если установить новое постоянное значение, то через refactoring-tools меняем и имя).
</p><p><br />
	Такое “имя” намного проще использовать, чем, например, “<code>timeToSend112PercentOfFrameIncludeInterPacketGap</code>” или “<code>frameIntervalFor89PercentChannelUtilization</code>”. Другое имя “<code>baseDelay</code>” – уже короче, но все же больше, чем 3 цифры числа, и к тому же оно отвечает на меньшее количество вопросов (например, базовая задержка чего?), чем первые два варианта. Так что, на раннем этапе создания модели, творческие ресурсы лучше расходовать на что‑нибудь другое (структура модели, схемы, графики, перебор вариантов, поиск элегантного решения, …).
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> Можно уменьшить негативное влияние сканирования на сеть путем изменения баланса в (‹частота отправки кадров›×‹размер кадра›) в сторону значительного уменьшения размера кадра (увеличения уровня гранулярности) для broadcast трафика. Я не моделировал эту ситуацию, поэтому приведу лишь результаты мысленного эксперимента. Это приведет к тому, что промежуточное сетевое оборудование сможет чаще вставлять, в промежутки между кадрами broadcast трафика, кадры других хостов в сети (хостов, не участвующих в сканировании). Это может по‑разному сказаться на точности собираемой статистики: отрицательно, из‑за сопутствующего не уменьшения (относительно обычной работы сети) объема трафика с других хостов в сети; положительно, из‑за уменьшения задержек в сети, и предотвращения лавинообразного увеличения размера окна у TCP (на некоторых алгоритмах контроля перегрузки; bufferbloat) до появления первых недошедших пакетов.
</p>
<br /><h4><anchor>posledovatelnosti-chisel</anchor><a href="#posledovatelnosti-chisel" title="Ссылка на раздел"><font color="gray">#</font></a> Последовательности чисел</h4>
<p><br />
	Раз уже заговорили про числа, то продолжим. В <a href="https://habr.com/post/414799/#lltr-basic">предыдущей статье</a> было сказано (дежавю?):
</p>
<blockquote cite="https://habr.com/post/414799/#lltr-basic">
	Количество комбинаций, которые нужно проверить, можно посчитать по формуле <nobr>n×<strong>(n−1)</strong></nobr> {каждому (n) нужно “поздороваться” со всеми остальными <nobr><strong>(n−1)</strong></nobr>, даже если с ним ранее они уже здоровались}, где n – количество всех хостов минус один (broadcast хост).
</blockquote>
<p>
	В коде это вычисляется на <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L71">строке 71</a>:
</p>
<br /><source lang="cpp">numHosts = getHostsCount(getParentModule()-&gt;getComponentType()) - 1;      //&quot;host*&quot; without &quot;hostS&quot; (-1)
combHosts = <strong>(numHosts-1)</strong>*(numHosts);</source>
<p><br />
	Как в <nobr>OMNeT++</nobr>/INET посчитать количество “наших” хостов (“host*”: “hostS”, “host0”, “host1”, …)? Самый быстрый способ это сделать (функция “<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRUtils.cc#L10-L19"><code>getHostsCount()</code></a>”):
</p>
<br /><source lang="cpp">const uint32 getHostsCount(cComponentType const *const hostType)
{
       uint32 counter = 0;

       for(cModule::SubmoduleIterator i(getSimulation()-&gt;getSystemModule()); !i.end(); i++){
             if((*i)-&gt;getComponentType() == hostType) counter++;
       }

       return counter;
}</source>
<p><br />
	Так как для “своих” хостов мы создали “SimpleUdpTcpHost”, то нам достаточно подсчитать количество модулей в сети с таким типом, что и делает функция “<code>getHostsCount()</code>”.
</p>
<br /><spoiler title="Более быстрый способ"><hr />
	<p>
		<font color="#54524F"><b>Note</b>:</font> <i>всегда найдется еще более быстрый способ</i>. <abbr title="Universal Serial Bus">USB</abbr>: Full Speed, High Speed, SuperSpeed, SuperSpeed+, …
	</p><p><br />
		Нужно создать одну общую (для “LLTRSuperApp” и “LLTRApp”) переменную (статическую либо глобальную, внутри класса либо вне его). Начальное значение переменной должно быть 0. Затем, на стадии <em>INITSTAGE_LOCAL</em>, каждый “LLTRApp” инкрементирует эту переменную. На следующих стадиях каждый “*App” может читать эту переменную (<code>numHosts</code>).
	</p><p><br />
		И главное: в деструкторе “LLTRSuperApp” необходимо обнулять эту переменную.
	</p>
<hr /></spoiler>
<p><br />
	В какой последовательности будем здороваться с хостами? В самом простом способе, цепочка номеров хостов зациклена (после “последнего” хоста идет нулевой хост; перед нулевым хостом стоит “последний” хост), и каждый unicast src хост последовательно выбирает следующие за собой хосты (в качестве unicast dst хоста), пока не дойдет до самого себя. Выглядит это так (числами обозначены номера хостов):
</p>
<br /><!-- nohighlight --><source lang="bash">  s   d
  r   s
  c   t
┬
⁞ 0
⁞ ├─˃ 1
⁞ └─˃ 2
⁞ 1
⁞ ├─˃ 2
⁞ └─˃ 0
⁞ 2
⁞ ├─˃ 0
⁞ └─˃ 1
˅t</source>
<p><br />
	А для просмотра реализации, уже пора перейти к коду “<strong>LLTRApp</strong>”, т.к. в <a href="#protokol-versiya-v_basic_global-wave">v.Basic.GlobalWave</a> именно unicast src делает этот выбор, а broadcast src всего лишь сообщает им текущий шаг и номер итерации.
</p><p><br />
	Зная текущий номер итерации можно вычислить номер unicast src хоста, и номер unicast dst хоста (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRApp.cc#L146-L147">строки 146,147</a>; я немного изменил форматирование, чтобы связь была более явной):
</p>
<br /><source lang="cpp">int uSrcHostId =               iteration/<strong>(numHosts-1)</strong>;
int uDstHostId = (uSrcHostId + iteration%<strong>(numHosts-1) </strong>+ 1)%numHosts;</source>
<p><br />
	Хост может сравнить “<code>uSrcHostId</code>” со своим номером (“<code>thisHostId</code>”), и понять, что в текущей итерации он – unicast src хост (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRApp.cc#L149">строка 149</a>):
</p>
<br /><source lang="cpp">if(uSrcHostId == thisHostId) {</source>
<br /><h4><anchor>utility</anchor><a href="#utility" title="Ссылка на раздел"><font color="gray">#</font></a> Утилиты</h4>
<p><br />
	Но как хост (“LLTRApp”) определяет свой номер? Через свое имя (“<code>&quot;host#&quot;</code>”; <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRApp.cc#L64">строка 64</a>):
</p>
<br /><source lang="cpp">thisHostId = atoi(&amp;getParentModule()-&gt;getName()[4]);</source>
<p><br />
	т.к. ранее мы отказались от “<a href="#pomeschaem-hosty-v-vektor">размещения хостов в векторе</a>”.
</p><p><br />
	А как выглядит обратный процесс: получить имя хоста, зная его номер, либо получить его IP‑адрес? Для этого создан отдельный класс “<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRUtils.h#L19-L21"><code>HostPath_defSuperHost_</code></a>”, при помощи которого очень удобно размещать на стеке строку “<code>&quot;hostS\0\0\0\0\0\0\0\0\0&quot;</code>”, и работать с ней. Один из примеров использования (заполняем ARP‑таблицу хостов и MAC‑таблицу в свитчах – <a href="#protokol-versiya-v_basic_global-wave--unicast-src-dst">1‑й шаг для “LLTRApp” в описании v.Basic.GlobalWave</a>; <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRApp.cc#L95-L100">строка 95</a>):
</p>
<br /><source lang="cpp">case INITSTAGE_LAST:{
       //послать ARP-запросы всем родным хостам, т.к. дальше пакеты пройдут с трудом
       HostPath_defSuperHost_ path;
       socketTrickle.sendTo(new cPacket(&quot;To ARP&quot;), path.GetIp(), 9);
       for(int i=0; i&lt;numHosts; i++) socketTrickle.sendTo(new cPacket(&quot;To ARP&quot;), path(i), 9);
}break;</source>
<p><br />
	Вначале посылаем пакет на “hostS”, затем на остальные хосты.
</p><p><br />
	Еще один пример (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRApp.cc#L150">строка 150</a>):
</p>
<br /><source lang="cpp">destHost = HostPath_defSuperHost_(uDstHostId).GetIp();</source>
<p><br />
	Получаем IP‑адрес хоста с номером “<code>uDstHostId</code>”.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> “<code>_defSuperHost_</code>” всегда напомнит, что в исходной строке находится “<code>&quot;hostS&quot;</code>”.
</p>
<br /><h4><anchor>obrabotka-smeny-tekuschego-shagaiteracii</anchor><a href="#obrabotka-smeny-tekuschego-shagaiteracii" title="Ссылка на раздел"><font color="gray">#</font></a> Обработка смены текущего шага/итерации</h4>
<p><br />
	Дошли до самого интересного. “LLTRApp” узнает о текущем шаге и текущей итерации из пакетов, рассылаемых “LLTRSuperApp”, но как быть в ситуациях, когда:
</p>
<br /><ol>
	<li>один из пакетов текущей итерации/шага “затерялся”, началась новая итерация/шаг и ее пакеты уже дошли до “LLTRApp”, а затем приходит “потерянный” пакет…</li>
	<li>кто‑то сторонний разошлет пакеты с номером итерации, превышающем (или равным) “<code>combHosts</code>”…</li>
</ol>
<p><br />
	И еще вопросы:
</p>
<br /><ol>
	<li>Как определить, что началась новая итерация/шаг?</li>
	<li>Стоит ли подсчитывать пакеты, предназначенные для предыдущих итераций (предполагается, что уже началась новая итерация)?
		<ul>
			<li>Если стоит, то куда их отнести: к итерации указанной в пакете, либо к текущей итерации?</li>
		</ul>
	</li>
	<li>Если уже началась новая итерация, но предыдущий unicast src хост еще не завершил отправку трафика на unicast dst хост?</li>
</ol>
<p><br />
	Ответы на все вопросы в коде (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRApp.cc#L120-L166">строка 120</a>):
</p>
<br /><source lang="cpp">LLTRStep step;
uint32_t  iteration;
{
       FillPayload* fill = check_and_cast&lt;FillPayload*&gt;(msg);
       step       = fill-&gt;getStep();
       iteration  = fill-&gt;getIterationNumber();
}
delete msg;

if(iteration &gt;= combHosts) iteration=0; //anti buffer overflow

if(step &lt; this-&gt;step) break;
if(step &gt; this-&gt;step) this-&gt;step = step;

switch(step){
case PROBING:{
       /*if(iteration+1 == iN)*/countFill[iN]++;      //calc only LLTRSuperApp fill (LLTRApp trickle always have step==0)
       if(iteration+1 &lt;= iN) break;
       if(iteration+1 &gt;  iN) iN = iteration+1;

       cancelEvent(evTrickle);    //stop transfer
       //...
}break;
case COLLECT:{
       cancelEvent(evTrickle);    //stop transfer
}break;
}</source>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> просматривая эти строчки кода, представьте, что через них может проходить 8.3 миллионов пакетов каждую секунду…
</p><p><br />
	А теперь обратим внимание на размер вектора (“<strong><code>countFill</code></strong>”), хранящего количество принятых broadcast пакетов (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRApp.cc#L71">строка 71</a>):
</p>
<br /><source lang="cpp">countFill.resize(1 + combHosts);</source>
<p><br />
	И на то, что в коде выше, постоянно к итерации добавлялся “<code>1</code>” (“<code>iteration+1</code>”). “<strong><code>iN</code></strong>” в “<strong>LLTRApp</strong>” всегда (кроме самого начала) на один больше текущего номера итерации. Следовательно, в “<code>countFill</code>” количество посчитанных пакетов за нулевою итерацию следует смотреть не в нулевом элементе “<code>countFill</code>”, а в первом.
</p><p><br />
	Если этого не сделать, то мы не сможем запустить нулевую итерацию. Поэтому, в нулевом элементе вектора “<code>countFill</code>”, по завершению сканирования, всегда будет значение “<code>1</code>” – посчитан пакет, который переключил “<code>iN</code>” с “<code>0</code>” на “<code>1</code>”, и запустил “нулевую итерацию”.
</p><p><br />
	В дальнейшем, мы не будем обращать внимание на нулевой элемент “<code>countFill</code>”.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> Альтернатива – использовать знаковый тип для хранения/передачи номера итерации, тогда начальное значение “<code>iN</code>” можно было сделать равным “<code>-1</code>”, убрать “<code>+1</code>” в нужных местах, и переписать подсчет пакетов, т.к. “<code>countFill[-1]++;</code>” – это явно не есть хорошо. Однако, если в текущем варианте мы “жертвуем” только одним значением “<code>iN</code>” из 2<sup>32</sup> возможных, то в альтернативном варианте, придется “жертвовать” уже половину (2<sup>31</sup>) из всех возможных значений (2<sup>32</sup>).
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> <strong>если</strong> очень хочется привязать поля классов “LLTRSuperApp” и “LLTRApp” к конкретным шагам, дать им более конкретные названия, и, одновременно, сократить количество памяти, занимаемое полями этих классов, <strong>то</strong> можно все поля, специфичные для конкретного шага, поместить в union (<a href="https://habrahabr.ru/post/244573">так</a> и <a href="https://habrahabr.ru/post/244497/#comment_8153525">так</a>).
</p>
<br /><h4><anchor>dlya-otladki-v-simulyatore-qtenvtkenv</anchor><a href="#dlya-otladki-v-simulyatore-qtenvtkenv" title="Ссылка на раздел"><font color="gray">#</font></a> Для отладки в симуляторе (Qtenv/Tkenv)</h4>
<p><br />
	Хорошо было бы во время симуляции наблюдать за параметрами “<code>step</code>”, “<code>iN</code>” и количеством посчитанных пакетов (“<code>countFill</code>”) на каждом хосте (“LLTRApp”):
</p>
<br /><anchor>fig_qtenv-host0-watch</anchor><img alt="qtenv: host0 watch" align="center" height="457" src="https://habrastorage.org/webt/em/t6/f1/emt6f1eellbhkb6mp4-edamnm_c.png#qtenv-host0-watch.png"/>
<p><br />
	В <nobr>OMNeT++</nobr> это сделать легко – при помощи макроса “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:sim-lib:basic-watches"><code>WATCH()</code></a>” и <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:sim-lib:stl-watches">“<code>WATCH_*()</code>” макросов для просмотра “массивов”</a> (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRApp.cc#L73-L75">строка 73</a>):
</p>
<br /><source lang="cpp">WATCH(step);
WATCH(iN);
WATCH_VECTOR(countFill);</source>
<p><br />
	Еще было бы здорово, во время симуляции, на карте сети сразу же видеть какой из хостов сейчас считает себя unicast src хостом, а какой – unicast dst хостом. В <nobr>OMNeT++</nobr> это можно сделать при помощи “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:graphics:submodule-status-icon">Status Icon</a>”.
</p><p><br />
	Unicast src хост:
</p>
<br /><anchor>fig_qtenv-unicast_src_host</anchor><img alt="qtenv: unicast src host" align="center" height="43" src="https://habrastorage.org/webt/t1/0m/sf/t10msfhdljxky1iyffgprn3rngs.png#qtenv-unicast_src_host.png"/>
<p><br />
	<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRApp.cc#L155">(Строка 155)</a>:
</p>
<br /><source lang="cpp">parentDispStr.setTagArg(&quot;i2&quot;, 0, &quot;status/up&quot;);</source>
<p><br />
	Unicast dst хост:
</p>
<br /><anchor>fig_qtenv-unicast_dst_host</anchor><img alt="qtenv: unicast dst host" align="center" height="43" src="https://habrastorage.org/webt/s8/6a/di/s86adibec4daxljx9zrkbqnfbri.png#qtenv-unicast_dst_host.png"/>
<p><br />
	<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRApp.cc#L160">(Строка 160)</a>:
</p>
<br /><source lang="cpp">parentDispStr.setTagArg(&quot;i2&quot;, 0, &quot;status/down&quot;);</source>
<p><br />
	Если стандартных иконок не достаточно, то всегда <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:graphics:image-path">можно использовать свои иконки</a>.
</p>
<br /><h4><anchor>bag-s-finish-i-logom-v-qtenv</anchor><a href="#bag-s-finish-i-logom-v-qtenv" title="Ссылка на раздел"><font color="gray">#</font></a> Баг с finish() и логом в Qtenv</h4>
<p><br />
	В то время, когда это все создавалось, последней версией <nobr>OMNeT++</nobr> была 5.0 beta1 (5.0b1), именно ее я и использовал. В ней еще не было Qtenv, был только Tkenv.
</p><p><br />
	Я чему я клоню? Посмотрите на то, как сейчас выглядит метод “<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L216-L256"><code>finish()</code></a>” у “LLTRSuperApp”, и сравните с тем, как он выглядел в те времена:
</p>
<br /><source lang="cpp">void finish()
{
       cancelEvent(trafEvnt);
       cancelEvent(statEvnt);
       socketTraf.close();

       for(int j=0;j&lt;hostsCombs;j++){
             EV &lt;&lt; &quot;{&quot; &lt;&lt; trafCount[0*hostsCombs + j];

             for(int i=1;i&lt;hostsCount;i++) EV &lt;&lt; &quot;,&quot; &lt;&lt; trafCount[i*hostsCombs + j];

             EV &lt;&lt; &quot;},&quot; &lt;&lt; endl;
       }

       cSimpleModule::finish();
}</source>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> в то время и переменные назывались по другому.
</p><p><br />
	Перед написанием этой статьи, я обновился до последней версии <nobr>OMNeT++</nobr> (релиз 5.0), в которой уже появился Qtenv – он мне сразу понравился, т.к. был заметно быстрее Tkenv. Но…
</p><p><br />
	До этого момента я уже успел познакомиться с одним из багов лога Qtenv – неверный расчет границ текста, копируемого в буфер обмена. Теперь к нему добавился еще один баг: Qtenv не заносил в лог записи, которые были созданы после завершения симуляции (в данном случае – во время вызова “<code>finish()</code>” у всех модулей).
</p><p><br />
	Раньше, с функционирующим выводом в лог (в “<code>finish()</code>”), было очень удобно работать: после завершения симуляции, в последних строчках лога, сразу же были видны ее результаты. Результаты из лога можно было легко скопировать, и использовать для последующей обработки.
</p><p><br />
	Теперь же пришлось сделать несколько “костылей”, пока Qtenv не доделают. Мне они не очень подходят, но зато, при помощи них, я смогу показать, какие еще существуют способы вывода результатов симуляции из <nobr>OMNeT++</nobr>.
</p><p><br />
	Самый простой “костыль”: после того, как “LLTRSuperApp” завершит загрузку статистики со всех “LLTRApp” – сразу же вывести ее в лог (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L190-L202">строка 190</a>). Минус этого “костыля” – после этой записи, в логе будут еще множество записей, и по окончании симуляции придется прокручивать (искать) лог до записи с результатами. Это придется делать каждый раз! Чуть позже покажу, как это выглядит.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> Только что замерил разницу в скорости release и beta версии 5.0: в версии 5.0b был только Tkenv и скорость его run была в 1.4 раза быстрее чем <strong>run</strong> в Tkenv/Qtenv release версии 5.0 (при одинаковых настройках). Зато теперь есть Qtenv и его <strong>fast</strong> выставленный в настройках на 17ms очень хорош. Не хватает еще одной кнопки – промежуточной между <strong>run</strong> и <strong>fast</strong>(500ms)).
</p>
<br /><h4><anchor>vyvod-rezultatov-simulyacii-v-fayl-s-pomoschyu-coutvector</anchor><a href="#vyvod-rezultatov-simulyacii-v-fayl-s-pomoschyu-coutvector" title="Ссылка на раздел"><font color="gray">#</font></a> Вывод результатов симуляции в файл с помощью “cOutVector”</h4>
<p><br />
	В <nobr>OMNeT++</nobr> есть несколько средств по накоплению данных во время симуляции, вывода их в файл, и последующего анализа. Все они описаны в главе “<a href="https://omnetpp.org/doc/omnetpp/manual/#cha:ana-sim">12 Result Recording and Analysis</a>” и разделе “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:sim-lib:result-recording">7.9 Recording Simulation Results</a>”.
</p><p><br />
	Мне из этого всего был нужен только вывод двумерного массива в файл. Однако, этого он делать не умеет – он может выводить либо скалярные (одиночные) значение, либо одномерные массивы. Поэтому двумерный (либо n‑мерные) массив выводятся через несколько одномерных (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L246-L252">строка 246</a> LLTRSuperApp).
</p><p><br />
	Здесь есть еще несколько нюансов:
</p>
<br /><ol>
	<li>в файл попадет не только наши данные, но и данные других модулей, которые захотели что‑то сохранить;</li>
	<li>в файлах (“simulations/results/*.sca”, “simulations/results/*.vec”) все данные хранятся в специальном формате, и их так просто из него не скопируешь.</li>
</ol>
<p><br />
	Первая проблема решается просто – в “.ini” файле отключим сбор статистики для всего (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/LLTR/simulations/omnetpp.ini#L24-L28">строка 24</a>), кроме “LLTRSuperApp” (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/LLTR/simulations/omnetpp.ini#L17">строка 17</a>).
</p><p><br />
	Вторая проблема решается при помощи “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:ana-sim:scavetool">scavetool</a>”, который переведет данные из внутреннего формата в “csv” (также, поддерживаются и другие форматы; запускать из директории “simulations/results/”):
</p>
<br /><source lang="bash">scavetool vector -F csv -O count.csv *-0.vec</source>
<p><br />
	А теперь сравним вывод данных в лог, с выводом в файл + scavetool. Плюсы вывода в лог я уже приводил, добавлю лишь то, что при выводе в лог я сам могу форматировать данные нужным образом, например, представив их в виде двухмерного массива для C. Вывод в файл, в данном случае, неудобен из‑за необходимости в дополнительных действиях, и не совсем подходящего формата вывода данных (даже после scavetool), но он хорошо подойдет для потоковых (автоматизированных) симуляций без GUI (“<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:run-sim:cmdenv">Cmdenv</a>”).
</p>
<br /><h4><anchor>vyvod-rezultatov-simulyacii-na-kartu-seti</anchor><a href="#vyvod-rezultatov-simulyacii-na-kartu-seti" title="Ссылка на раздел"><font color="gray">#</font></a> Вывод результатов симуляции на карту сети</h4>
<p><br />
	Точнее, результаты появятся рядом с хостом “hostS”. Для этого используем “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:graphics:submdule-text-and-tooltip">Text and Tooltip</a>” (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L239-L244">строка 239</a>).
</p><p><br />
	Ниже покажу, как это выглядит.
</p><p><br />
	Плюсы:
</p>
<br /><ul>
	<li>по завершению симуляции – результаты сразу же видны на экране.</li>
</ul>
<p><br />
	Минусы:
</p>
<br /><ul>
	<li>не все результаты смогут поместиться на экран;</li>
	<li>результаты нельзя скопировать в буфер обмена.</li>
</ul>
<br /><h4><anchor>zapusk</anchor><a href="#zapusk" title="Ссылка на раздел"><font color="gray">#</font></a> Запуск</h4>
<br /><spoiler title="Тем временем, в реальности…"><hr />
	<p>
		Как уже упомянул в разделе “<a href="#bag-s-finish-i-logom-v-qtenv">Баг с finish() и логом в Qtenv</a>”, в реальности, переменные имели другое название (без общего стиля наименования), шаги и итерации были названы по‑другому:
	</p>
	<br /><!-- nohighlight --><source lang="bash">Реальность --&gt; Статья
---------------------
state      --&gt; step
stepN      --&gt; iN
stepSubN   --&gt; pktN</source>
	<p><br />
		И поля класса “<code>LLTRSuperApp</code>” выглядели так:
	</p>
	<br /><source lang="cpp">/* save state in &quot;global&quot; variables is practical to slow down &amp;&amp; bugging your code */

cMessage *trafEvnt = nullptr;
cMessage *statEvnt = nullptr;

uint32    stepN = 0;
int    stepSubN = 0;
uint32    hostN = 1;

int  trafPort = -1;
long packetLength = 0;

UDPSocket::SendOptions udpSendOpt;
int gateTcpId; //socketStat

TCPSocket socketStat;
UDPSocket socketTraf;

std::vector&lt;int&gt; trafCount;       //[hostsCount][hostsCombs]
uint32 hostsCount;  //without SuperHost
uint32 hostsCombs;  //(hostsCount-1)*(hostsCount)

/*=================================================================================*/</source>
	<p><br />
		Да и сам класс “<code>LLTRSuperApp</code>” назывался по‑другому.
	</p><p><br />
		Но код с этими переменными выглядел более сбалансированным (оптимальная длина названия переменной у большей части переменных) (“LLTRApp”):
	</p>
	<br /><source lang="cpp">if(step &gt;= hostsCombs) step=0;    //anti buffer overflow

if(state &lt; this-&gt;state) break;
if(state &gt; this-&gt;state) this-&gt;state = state;

switch(state){
case PROBING:{
       /*if(step+1 == stepN)*/trafCount[stepN]++;     //calc only SuperClient traf (Client traf always have state==0)
       if(step+1 &lt;= stepN) break;
       if(step+1 &gt;  stepN) stepN = step+1;

       cancelEvent(trafEvnt);     //stop transfer

       if(step/(hostsCount-1) == hostId-1) {
             char path[] = &quot;host0000000000&quot;;
             itoa10(((hostId-1) + (step%(hostsCount-1)+1))%hostsCount + 1, &amp;path[4]);

             destC = getIPByHostPath(path);</source>
	<p><br />
		Новые названия лучше отражают суть, а со старыми – код смотрелся лучше.
	</p><p><br />
		… И не было никакого “<code>LLTRUtils</code>” c “<code>HostPath_defSuperHost_</code>” (он появился позже) – все дублировалось для возможности быстрого внесения изменений, специфичных для LLTRSuperApp, или для LLTRApp.
	</p><p><br />
		А “<code>HostPath_defSuperHost_</code>” создавался таким, чтобы компилятор генерировал в точности такой же код, каким он был сейчас. За исключением того, что строку “<code>&quot;host0000000000&quot;</code>” я сразу заменил на “<code>&quot;host0\0\0\0\0\0\0\0\0\0&quot;</code>”.
	</p><p><br />
		Также не было разделения на “hostS” и “host#” – все хосты именовались в формате “<code>host#</code>”. В точности как было до раздела “<a href="#shag-4-realizaciya-protokola-versiya-v_basic_global-wave">Шаг 4: реализация протокола (версия v.Basic.GlobalWave)</a>”. Что приводило к множеству “<code>+1</code>” и “<code>-1</code>” в коде.
	</p>
<hr /></spoiler>
<p><br />
	Собираем, запускаем, запускаем симуляцию (run, или можете попробовать более скоростной режим – fast):
</p>
<br /><anchor>fig_qtenv-fast</anchor><img alt="Run faster: no animation and rare inspector updates (F6)" align="center" height="55" src="https://habrastorage.org/webt/hc/jm/-q/hcjm-qftjn4u_emy4mcag8x-5ny.png#qtenv-fast.png"/>
<p><br />
	Результаты симуляции:
</p>
<br /><anchor>fig_qtenv-sim_results-network-big_queue</anchor><img alt="qtenv: sim results – network – …" align="center" height="416" src="https://habrastorage.org/webt/sc/zo/rp/sczorpvt53ikp0fvkwdbaiof7qc.png#qtenv-sim_results-network-big_queue.png"/>
<p><br />
	Странно, до хостов дошли все пакеты, кроме последней итерации (не дошел 1 пакет)… А что в логе?:
</p>
<br /><anchor>fig_qtenv-sim_results-log-big_queue</anchor><img alt="qtenv: sim results – log – …" align="center" height="302" src="https://habrastorage.org/webt/jn/nm/4o/jnnm4o4-snjszco-fe6ayqczeik.png#qtenv-sim_results-log-big_queue.png"/>
<p><br />
	То же самое… А что в статистике самих хостов?:
</p>
<br /><anchor>fig_qtenv-sim_results-open_details_for-big_queue</anchor><img alt="qtenv: sim results – open details for – …" align="center" height="178" src="https://habrastorage.org/webt/rn/sn/ye/rnsnyehi7c2tcg8wzumweygxstm.png#qtenv-sim_results-open_details_for-big_queue.png"/>
<p><br />
	И такая картина в каждом хосте… А если запустить “Tkenv” (<nobr>Run &gt;</nobr> Run Configurations…):
</p>
<br /><anchor>fig_run_configurations-tkenv</anchor><img alt="run configurations – tkenv" align="center" height="540" src="https://habrastorage.org/webt/da/rz/oz/darzozqahrcodhx8-ejqt_htgo8.png#run_configurations-tkenv.png"/>
<br /><anchor>fig_tkenv-sim_results-log-big_queue</anchor><img alt="tkenv: sim results – log – …" align="center" height="322" src="https://habrastorage.org/webt/bt/gv/pq/btgvpqgkdkvujmlhrtoaxgbvst0.png#tkenv-sim_results-log-big_queue.png"/>
<p><br />
	Все также, за исключением того, что “<a href="#bag-s-finish-i-logom-v-qtenv"><code>finish()</code></a>” нормально сработал, и запуск в режиме fast был не совсем “fast”.
</p><p><br />
	Так в чем же дело? Почему все 300 (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L135">строка 135</a> LLTRSuperApp) посланных пакетов дошли до каждого “LLTRApp”?
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> на самом деле в коде ошибки нет, и я покажу как исправить ситуацию, не меняя ни строчки в коде.
</p><p><br />
	Вначале предлагаю посмотреть, почему в последней итерации каждый из “LLTRApp” получил только 299 пакетов, вместо 300? <a href="#obrabotka-smeny-tekuschego-shagaiteracii">Ранее я упоминал</a>, что:
</p>
<blockquote cite="#obrabotka-smeny-tekuschego-shagaiteracii">
	Поэтому, в нулевом элементе вектора “<code>countFill</code>”, по завершению сканирования, всегда будет значение “<code>1</code>” – посчитан пакет, который переключил “<code>iN</code>” с “<code>0</code>” на “<code>1</code>”, и запустил “нулевую итерацию”.
</blockquote>
<p>
	В каждой <em>новой итерации</em> расходуется ровно один пакет для переключения на эту <em>новую итерацию</em>. Этот один пакет попадает в предыдущую итерацию (относительно <em>новой итерации</em>). Чтобы увидеть истинную картину, то надо произвести простую операцию:
</p>
<br /><!-- nohighlight --><source lang="bash">[0]  [1]   [2]   [3]   [4]   [5]   [6]     [0]  [1]   [2]   [3]   [4]   [5]   [6]
 ┌─1─┐ ┌─1─┐ ┌─1─┐ ┌─1─┐ ┌─1─┐ ┌─1─┐
 │   ˅ │   ˅ │   ˅ │   ˅ │   ˅ │   ˅
 1   300   300   300   300   300   299  =   0   300   300   300   300   300   300  </source>
<p><br />
	Что немного не соответствует “бритве Оккама”, исправим:
</p>
<br /><!-- nohighlight --><source lang="bash">[0]  [1]   [2]   [3]   [4]   [5]   [6]     [0]  [1]   [2]   [3]   [4]   [5]   [6]
 ┌────────────────1─────────────────┐
 │                                  ˅
 1   300   300   300   300   300   299  =   0   300   300   300   300   300   300  </source>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> В будущем, при построении топологии сети, мы будем рассматривать каждую итерацию независимо от других итераций. Следовательно, набор [299 299 299] для нас будет аналогичен [300 300 300], [1 1 1], и даже с [0 0 0] разницы никакой не будет. Следовательно (на самом деле нет, не хватает примеров: [199 299 299]→[200 300 300], [2 3 3]→[3 4 4], [0 1 1]→[1 2 2]), данное исправление излишне.
</p><p><br />
	Вернемся к тому, что у нас ничего не работает. И почему сразу несколько хостов считают себя unicast dst хостами?:
</p>
<br /><anchor>fig_qtenv-multiple_unicast_dst-big_queue</anchor><img alt="qtenv: multiple unicast dst – …" align="center" height="416" src="https://habrastorage.org/webt/43/oh/a2/43oha2iidfsjkq4tvtdgj39qe5w.png#qtenv-multiple_unicast_dst-big_queue.png"/>
<p><br />
	И почему, если закомментировать (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.26.0/inet/src/inet/applications/lltrapp/LLTRApp.cc#L98">строку 98</a> LLTRApp) (ARP для “hostS”), то “LLTRSuperApp” уже не сможет собрать статистику с хостов?
</p><p><br />
	Можно долго искать ошибку там, где ее нет (в коде). Поэтому сразу же вспомним, а за счет чего должны были происходить потери пакетов? Подсказка в разделе “<a href="#protokol-versiya-v_basic_global-wave">Протокол, версия v.Basic.GlobalWave</a>”:
</p>
<blockquote cite="#protokol-versiya-v_basic_global-wave">
	• их должно быть достаточно, чтобы они смогли потеряться (потеря пакетов будет происходить при одновременном “вливании” свитчем broadcast и unicast пакетов в один и тот же порт, с последующим переполнением очереди пакетов этого порта, т.е. количества пакетов должно быть достаточно для переполнения очереди);
</blockquote>
<p>
	Очевидно, что мы “вливаем” недостаточное количество пакетов, но даже этого количества пакетов хватило, чтобы сети “стало плохо” (ARP). Поэтому:
</p>
<br /><ol>
	<li>посмотрим на текущий размер очереди;</li>
	<li>уменьшим его.</li>
</ol>
<p><br />
	Читать подробности поиска “а где же в EtherSwitch находится очередь пакетов” – скучно, поэтому сразу покажу путь к параметру, определяющему ее размер (<code>Network.switch0.eth[2].mac.txQueueLimit</code>):
</p>
<br /><anchor>fig_qtenv-mac-queue</anchor><img alt="qtenv: mac queue" align="center" height="265" src="https://habrastorage.org/webt/gj/ut/w3/gjutw3x1ku50m4hwgwxqw0vxzdm.png#qtenv-mac-queue.png"/>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> Буфер, вместимостью 10000 пакетов <nobr>=-O</nobr>. Привет bufferbloat (<a href="https://habrahabr.ru/post/317548">Wi-Fi на Linux станет быстрее</a>, <a href="https://ru.wikipedia.org/wiki/Излишняя_сетевая_буферизация?stable=1#Обнаружение_проблемы">приглашение на ланч</a>, <a href="http://mirrors.bufferbloat.net/Talks/BellLabs01192011/110126140926_BufferBloat12.pdf">Dark Buffers in the Internet</a> (тесты, начиная с 22 слайда), <a href="https://habrahabr.ru/post/194274/#comment_6781158">FQ_CoDel и FQ (FairQueue)</a>, <a href="http://snapon.lab.bufferbloat.net/~d/Presos/Cambridge_The_State_of_the_art_in_congestion_control.pdf">sch_fq</a> (страница 37)).
</p><p><br />
	Да, чуть не забыл, если попробуете переопределить его значение через “.ini” файл, то у вас ничего не получится, и все из‑за этой строчки в “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/linklayer/ethernet/EthernetInterface.ned#L72">EthernetInterface.ned</a>”:
</p>
<br /><source lang="cpp">txQueueLimit = (queueType == &quot;&quot; ? 10000 : 1); // queue sends one packet at a time</source>
<p><br />
	Посмотрим на “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/linklayer/ethernet/EthernetInterface.ned#L39"><code>queueType</code></a>”:
</p>
<br /><source lang="cpp">string queueType = default(&quot;&quot;); // ~DropTailQueue, or a Diffserv queue; set to &quot;&quot; for use of an internal queue</source>
<p><br />
	То есть, управлять размером внутренней очереди не получится. Однако, можно создать внешнюю очередь, указав ее тип. При выборе типа очереди, нужно учитывать, что в обычных неуправляемых свитчах:
</p>
<br /><ul>
	<li>буферы пакетов (очереди) имеют фиксированный размер;</li>
	<li>используется самый простой алгоритм отброса (drop) пакетов: если буфер переполнен, то все поступающие пакеты будут отброшены (drop).</li>
</ul>
<p><br />
	Если нужно сделать что‑то сложнее этого, то с выбором нужных компонентов поможет глава 15 “Differentiated Services” (“inet-manual-draft.pdf”, страница 129; страница 131):
</p>
<blockquote cite="https://omnetpp.org/doc/inet/api-3.4.0/inet-manual-draft.pdf">
	<ul>
		<li><strong>queue</strong>: container of packets, accessed as FIFO</li>
		<li><strong>dropper</strong>: attached to one or more queue, it can limit the queue length below some threshold by selectively dropping packets</li>
		<li><strong>scheduler</strong>: decide which packet is transmitted first, when more packets are available on their inputs</li>
		<li><strong>classifier</strong>: classify the received packets according to their content (e.g. source/destination, address and port, protocol, dscp field of IP datagrams) and forward them to the corresponding output gate.</li>
		<li><strong>meter</strong>: classify the received packets according to the temporal characteristic of their traffic stream</li>
		<li><strong>marker</strong>: marks packets by setting their fields to control their further processing</li>
	</ul>
</blockquote>
<p>
	Нам подходит очередь “<code>DropTailQueue</code>”, вот часть из ее описания (“inet-manual-draft.pdf”, страница 132):
</p>
<blockquote cite="https://omnetpp.org/doc/inet/api-3.4.0/inet-manual-draft.pdf">
	Its capacity can be specified by the <strong>frameCapacity</strong> parameter. When the number of stored packet reached the capacity of the queue, further packets are dropped.
</blockquote>
<p>
	Возможно значение по умолчанию для “<code>frameCapacity</code>” нас устроит, посмотрим чему оно равно (“<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/common/queue/DropTailQueue.ned#L28">DropTailQueue.ned</a>”):
</p>
<br /><source lang="cpp">int frameCapacity = default(100);</source>
<p><br />
	100 в несколько раз меньше “вливаемых” 600 пакетов (2×300), поэтому оно должно подойти нам.
</p><p><br />
	Осталось добавить в “omnetpp.ini” строчку:
</p>
<br /><source lang="ini">**.switch*.eth[*].queueType = &quot;DropTailQueue&quot;</source>
<p><br />
	И, на всякий случай, зафиксируем вместимость очереди (“<code>eth[*].<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/linklayer/ethernet/EthernetInterface.ned#L64">queue</a>.<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/linklayer/ethernet/EtherQoSQueue.ned#L47">dataQueue</a>.frameCapacity</code>”):
</p>
<br /><source lang="ini">**.switch*.eth[*].queue.dataQueue.frameCapacity = 100</source>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> применяем только для “<code>switch*</code>”, чтобы уменьшить “<strong>overhead</strong>” на хостах (“inet-manual-draft.pdf”, глава 3 “Node Architecture”, страница 7):
</p>
<blockquote cite="https://omnetpp.org/doc/inet/api-3.4.0/inet-manual-draft.pdf">
	Most MACs also have an internal queue to allow operation without an external queue module, the advantage being smaller <strong>overhead</strong>.
</blockquote>
<p><anchor>git-tag-a1_v0-27-0</anchor>
	В итоге, должно получиться <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.27.0/LLTR/simulations/omnetpp.ini#L9-L10">примерно так (git tag a1_v0.27.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.26.0...a1_v0.27.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>.
</p><p><br />
	Запускаем, запускаем симуляцию (fast):
</p>
<br /><anchor>fig_qtenv-sim_results-network</anchor><img alt="qtenv: sim results – network" align="center" height="416" src="https://habrastorage.org/webt/7h/yc/yw/7hycywjv1wydpxoosabhbhy9hla.png#qtenv-sim_results-network.png"/>
<p><br />
	Победа! Собранная статистика настолько чистая, что, достаточно просто посмотреть на нее, чтобы определить, где какой хост находится.
</p>
<br /><spoiler title="Анимация нулевой итерации на примере жучков (899 KiB; фрагмент из КДПВ – картинки для привлечения внимания):"><hr />
	<anchor>fig_zero-iteration</anchor><img alt="zero iteration" align="center" height="330" src="https://habrastorage.org/webt/mr/e-/pv/mre-pvz0m-rpnmxuhj32gje8qfi.gif#zero-iteration.gif"/>
	<p><br />
		#жучки-пакетики #bag-animation
	</p>
<hr /></spoiler>
<p><br />
	Однако, обратите внимание на разное количество пакетов 214 и 164. Во всех итерациях, в которых “host0” был unicast dst хостом, он получал больше broadcast пакетов (214), чем получали остальные хосты в роли “unicast dst хоста”.
</p><p><br />
	Для наглядности, к каждой итерации я добавил подпись “кто кому передает” (<code>‹# unicast src хоста› -&gt; ‹# unicast dst хоста›</code>):
</p>
<br /><!-- nohighlight --><source lang="bash">300 164 164   0 -&gt; 1
300 164 164   0 -&gt; 2
300 300 164   1 -&gt; 2
214 300 300   1 -&gt; 0
214 300 300   2 -&gt; 0
299 163 299   2 -&gt; 1</source>
<p><br />
	Я ожидал, что, во всех итерациях, значения счетчиков пакетов у unicast dst хостов будут примерно одинаковыми, т.е. лежать в окрестности одного числа (в данном случае – в окрестности числа 164). Но появился еще один фактор, который я пока не учел…
</p><p><br /><anchor>unclear-factor</anchor>
	<font color="#54524F"><b>Note</b>:</font> я “приоткрою” этот фактор чуть ниже, и окончательно раскрою его в одной из следующих статей, а пока оставим все как есть – он нам абсолютно не мешает.
</p><p><br />
	Выше я уже упоминал, что в симуляторе режим запуска <strong>run</strong> – слишком медленный, а <strong>fast</strong> – слишком быстрый, поэтому, чтобы детальнее просмотреть каждую итерацию, и при этом не ждать 126 минут (21 [минуту на нулевую <nobr>итерацию] ×</nobr> 6 [итераций]), предлагаю запустить симуляцию со следующими настройками:
</p>
<br /><ul>
	<li>В настройках (<nobr>Preferences &gt;</nobr> General: “Display update frequency for Fast Run (ms)”) задать <code>17</code> <nobr>( 1&thinsp;000 [ms] ∕ 60 [fps] )</nobr> (значение по умолчанию: <code>500</code>).</li>
	<li>В фильтре лога оставить записи только от “LLTRSuperApp” и “LLTRApp”, т.е. от “<code>**.host*.app[*]</code>”. Самый быстрый способ сделать это – вначале выключить все (отключить “Network”), а затем включить нужное.</li>
</ul>
<br /><anchor>fig_qtenv-fast_run_17ms-log_filter_app</anchor><img alt="qtenv: fast run 17ms – log filter app" align="center" height="295" src="https://habrastorage.org/webt/3s/bz/9f/3sbz9fbcgxauill--1wwval18-4.png#qtenv-fast_run_17ms-log_filter_app.png"/>
<p><br />
	Запускаем (fast) симуляцию, и наблюдаем за инспектором сети (картой сети).
</p><p><br />
	Возможно, в логе вы заметите мелькающие сообщения вида:
</p>
<br /><!-- nohighlight --><source lang="bash">** Event #1121  t=0.0016001  Network.host0.app[0] (LLTRApp, id=130)  on &gt;&gt;&gt; 0/299 time:0.00136 (inet::FillPayload, id=1713)
INFO:   !!!!!! Iteration: 0 | 0 ~ 0
INFO:   10.0.1.1</source>
<br /><anchor>fig_qtenv-log-new_iteration_start-info-find</anchor><img alt="qtenv: log – new iteration start – info – find" align="center" height="285" src="https://habrastorage.org/webt/um/rf/o4/umrfo4st2temkq3llucjqcbdttm.png#qtenv-log-new_iteration_start-info-find.png"/>
<p><br />
	Часть из них можно найти поиском по “<code>!!!!!! Iteration:</code>”, по завершении симуляции:
</p>
<br /><!-- nohighlight --><source lang="bash">** Event #39453  t=0.11024815  Network.host1.app[0] (LLTRApp, id=163)  on &gt;&gt;&gt; 2/299 time:0.109888
INFO:   !!!!!! Iteration: 2 | 1 ~ 0
INFO:   10.0.1.2
** Event #58994  t=0.16451215  Network.host1.app[0] (LLTRApp, id=163)  on &gt;&gt;&gt; 3/299 time:0.164152
INFO:   !!!!!! Iteration: 3 | 1 ~ 1
INFO:   10.0.1.0
** Event #80954  t=0.21877615  Network.host2.app[0] (LLTRApp, id=196)  on &gt;&gt;&gt; 4/299 time:0.218416
INFO:   !!!!!! Iteration: 4 | 2 ~ 0
INFO:   10.0.1.0
** Event #102913  t=0.27304015  Network.host2.app[0] (LLTRApp, id=196)  on &gt;&gt;&gt; 5/299 time:0.27268
INFO:   !!!!!! Iteration: 5 | 2 ~ 1
INFO:   10.0.1.1</source>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> Другая часть этих сообщений уже не отображается в логе – превышен лимит на максимальное количество событий и строчек в логе. Лимит можно изменить в настройках (<nobr>Preferences &gt;</nobr> Logs: “Overall history size (in events)” и “Scrollback buffer (lines)”).
</p><p><br />
	Эти сообщения выводятся в начале каждой итерации. Сообщение генерирует unicast src хост новой итерации. Часть кода, в которой генерируются сообщения (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.27.0/inet/src/inet/applications/lltrapp/LLTRApp.cc#L152">строка 152</a> LLTRApp):
</p>
<br /><source lang="cpp">if(uSrcHostId == thisHostId) {
       destHost = HostPath_defSuperHost_(uDstHostId).GetIp();

       EV &lt;&lt; &quot;!!!!!! Iteration: &quot;
          &lt;&lt; iteration &lt;&lt; &quot; | &quot; &lt;&lt; thisHostId &lt;&lt; &quot; ~ &quot; &lt;&lt; <strong>iteration%(numHosts-1)</strong> &lt;&lt; endl;
       EV &lt;&lt; destHost &lt;&lt; endl;

       parentDispStr.setTagArg(&quot;i2&quot;, 0, &quot;status/up&quot;);
       //...
}</source>
<p><br />
	Я выводил эти сообщения, чтобы:
</p>
<br /><ul>
	<li>быстро находить начало новой итерации в логе;</li>
	<li>для просмотра параметров новой итерации (ее номер, номер unicast src хоста, IP‑адрес unicast dst хоста);</li>
	<li>для отладки формулы расчета номера unicast dst хоста (“<strong><code>uDstHostId</code></strong>”) – в лог выводится “<strong><code>iteration%(numHosts-1)</code></strong>”.</li>
</ul>
<p><br />
	Возможно, и вам тоже они пригодятся.
</p>
<br /><spoiler title="Подробнее про “iteration%(numHosts-1)”"><hr />
	<p>
		По сути, для unicast src хоста, он значит “с каким по счету хостом я здороваюсь”.
	</p><p><br />
		В разделе “<a href="#posledovatelnosti-chisel">Последовательности чисел</a>” я уже приводил код для расчета (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.27.0/inet/src/inet/applications/lltrapp/LLTRApp.cc#L146">строка 146</a>):
	</p>
	<br /><source lang="cpp">int uSrcHostId =               iteration/(numHosts-1);
int <strong>uDstHostId</strong> = (uSrcHostId + <strong>iteration%(numHosts-1) </strong>+ 1)%numHosts;</source>
	<p><br />
		И последовательность “рукопожатий” хостов, в которую я теперь добавил “<code><strong>iteration%(numHosts-1)</strong></code>”:
	</p>
	<br /><!-- nohighlight --><source lang="bash">  s   d
  r   s
  c   t
┬
⁞ 0
⁞ ├─˃ 1 [<strong>0</strong>]
⁞ └─˃ 2 [<strong>1</strong>]
⁞ 1
⁞ ├─˃ 2 [<strong>0</strong>]
⁞ └─˃ 0 [<strong>1</strong>]
⁞ 2
⁞ ├─˃ 0 [<strong>0</strong>]
⁞ └─˃ 1 [<strong>1</strong>]
˅t</source>
<hr /></spoiler>
<p><br />
	Еще одной из подобных вещей, упрощающих отладку, являются названия broadcast пакетов:
</p>
<br /><anchor>fig_qtenv-traffic-broadcast_pkt_name</anchor><img alt="qtenv: traffic – broadcast pkt name" align="center" height="186" src="https://habrastorage.org/webt/cf/lp/tw/cflptw-usb0f6ull7rujbqldz0s.png#qtenv-traffic-broadcast_pkt_name.png"/>
<p><br />
	Их формат:
</p>
<br /><!-- nohighlight --><source lang="bash">&gt;&gt;&gt; ‹номер итерации›/‹обратный отсчет: сколько еще осталось отправить broadcast пакетов за текущую итерацию› time:‹время отправки пакета›</source>
<p><br />
	Время отправки пакета позволяет визуально оценить (сравнивая со столбцом “Time”), сколько времени прошло от момента отправки пакета до наступления этого события. То есть по нему сразу видно, насколько задержали этот пакет промежуточные узлы в сети.
</p><p><br />
	А по “обратному отсчету” можно быстро оценить время до начала следующей итерации. Например, мне, во время симуляции, нужно посмотреть определенные (изменяющиеся) параметры хостов в моменты перехода на новую итерацию: я могу, во время симуляции, переключится между режимами until+fast и run/step, и, смотря обратный отсчет, быстро находить (предполагаемое время ±12%) моменты перехода на новую итерацию.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> Альтернатива из двух проходов: можно вначале записать весь лог, выбрать в нем нужное время или номер события, а затем опять запустить симуляцию в режиме until, подставляя нужное время или номер события. Возможно, существует и более легкий способ, например, программно приостановить симуляцию в нужный момент.
</p><p><br />
	Одна из частей кода, в которой генерируется имя пакета (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.27.0/inet/src/inet/applications/lltrapp/LLTRSuperApp.cc#L123-L128">строка 123</a> LLTRSuperApp):
</p>
<br /><source lang="cpp">FillPayload *fill; {
       char msgName[64], time[64]; //see min buf size in &quot;.str()&quot; doc
       snprintf(msgName, sizeof msgName,
                &quot;&gt;&gt;&gt; %d/%d time:%s&quot;, iN, 300-1-pktN, simTime().str(time));
       // http://demin.ws/blog/english/2013/01/28/use-snprintf-on-different-platforms/
       msgName[sizeof(msgName)-1] = '\0';
       fill = new FillPayload(msgName);
}</source>
<p><br />
	Все хорошо, все работает, но меня <a href="https://habrahabr.ru/company/pt/blog/315362">тревожат</a> ошибки на последних двух скриншотах:
</p>
<br /><ul>
	<li>“<code>Ignoring UDP error report</code>” – сгенерировано <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.27.0/inet/src/inet/applications/lltrapp/LLTRApp.cc#L169">строкой 169</a> в “LLTRApp”;</li>
	<li>“<code>ICMP-error-#22-type3-code3</code>” – “<a href="http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml#icmp-parameters-codes-3">Destination Unreachable, Port Unreachable</a>”.</li>
</ul>
<p><br />
	Посмотрим на ошибки поближе (новый запуск симуляции; режим run; трафик от свитчей скрыт):
</p>
<br /><anchor>fig_qtenv-traffic-icmp_error_port_unreachable</anchor><img alt="qtenv: traffic – icmp error port unreachable" align="center" height="218" src="https://habrastorage.org/webt/ib/01/fd/ib01fddry9jlibhpqirv9pusdyq.png#qtenv-traffic-icmp_error_port_unreachable.png"/>
<p><br />
	Уже сейчас ясна причина появления ошибок, но, тем не менее, я хочу точно увидеть, какой пакет стал причиной отправки “ICMP Error”. Например, посмотрим в инспекторе объектов на событие #728 (“<code>ICMP-error-#6-type3-code3</code>”):
</p>
<br /><anchor>fig_qtenv-inspector-icmp_error_port_unreachable-to_arp_pkt</anchor><img alt="qtenv: inspector – icmp error port unreachable – to arp pkt" align="center" height="465" src="https://habrastorage.org/webt/ma/06/-q/ma06-qhberelh6zdoozfnosykuw.png#qtenv-inspector-icmp_error_port_unreachable-to_arp_pkt.png"/>
<p><br />
	Причиной события #728 был “<code>To ARP</code>” пакет от “host0”.
</p><p><br />
	Получается, что мы рассылаем “<code>To ARP</code>” пакеты на DISCARD (9) порт, ожидая, что он будет отброшен, но в тех стандартных модулях INET, которые мы используем, не реализованы “обработчики поведения по умолчанию для стандартных портов”. Поэтому сделаем это вручную:
</p>
<br /><source lang="cpp">UDPSocket socketDISCARD;
socketDISCARD.setOutputGate(gate(&quot;udpOut&quot;));
socketDISCARD.bind(9);</source>
<p><br />
	Просто привязываем сокет к порту 9.
</p><p><br />
	И подправим метод “<code>handleMessage()</code>” у “LLTRApp”, чтобы по UDP обрабатывать только “<code>socketTrickle</code>”:
</p>
<br /><source lang="cpp">if     (msg-&gt;arrivedOn(gateUdpId) &amp;&amp; <strong>socketTrickle.belongsToSocket(msg)</strong>) handleUdp(msg);</source>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> альтернатива: можно было сделать отдельный DISCARD‑модуль, либо настроить “<a href="https://github.com/inet-framework/inet/blob/v3.4.0/src/inet/applications/udpapp/UDPSink.ned#L26">UDPSink</a>”.
</p><p><br /><anchor>git-tag-a1_v0-28-0</anchor>
	Должно получиться <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/commit/128f18e8aca861feba25c8d3f4c0cb2190e77932">примерно так (git tag a1_v0.28.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.27.0...a1_v0.28.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>.
</p>
<br /><h3><anchor>shag-5-bolshe-testov-eksperimenty</anchor><a href="#shag-5-bolshe-testov-eksperimenty" title="Ссылка на раздел"><font color="gray">#</font></a> Шаг 5: больше тестов (эксперименты)</h3>
<p><br />
	Вначале предлагаю представить, что произойдет, если раскомментировать <a href="#obrabotka-smeny-tekuschego-shagaiteracii">это условие</a> в “LLTRApp” (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.28.0/inet/src/inet/applications/lltrapp/LLTRApp.cc#L140">строка 140</a>):
</p>
<br /><source lang="cpp">/*if(iteration+1 == iN)*/countFill[iN]++;</source>
<br /><spoiler title="Спойлер! Спойлер! Осторожно, спойлер содержит ответ!"><hr />
	<p>
		Я предупреждал…
	</p><p><br />
		Симуляция с этим условием даст следующие результаты:
	</p>
	<br /><!-- nohighlight --><source lang="bash">{299,163,163},
{299,163,163},
{299,299,163},
{213,299,299},
{213,299,299},
{299,163,299},</source>
	<p><br />
		Предположение: те единичные пакеты, которые переключали “LLTRApp” на новую итерацию, теперь нигде не подсчитываются.
	</p><p><br />
		Данное предположение согласуется с условием [(номер итерации, записанный в пакете) +1 != (номеру итерации в “LLTRApp”)], и с результатами симуляции. Дополнительно, можно проверить нулевой элемент вектора “<code>countFill</code>” одного из “host#” – его значение должно быть равно “<code>0</code>”:
	</p>
	<br /><anchor>fig_qtenv-host0-watch-countfill-if_iteration</anchor><img alt="qtenv: host0 – watch – countfill – if iteration" align="center" height="216" src="https://habrastorage.org/webt/z4/7k/_3/z47k_3sdemfmln-v1kue7tva8de.png#qtenv-host0-watch-countfill-if_iteration.png"/>
	<p><br />
		Также это означает, что за все время симуляции ни разу не возникала <a href="#obrabotka-smeny-tekuschego-shagaiteracii">ситуация</a>:
	</p>
	<blockquote cite="#obrabotka-smeny-tekuschego-shagaiteracii">
		1. один из пакетов текущей итерации/шага “затерялся”, началась новая итерация/шаг и ее пакеты уже дошли до “LLTRApp”, а затем приходит “потерянный” пакет...
	</blockquote>
<hr /></spoiler>
<p><br />
	А если заменить его на:
</p>
<br /><source lang="cpp">if(iteration+1 &gt;= iN) countFill[iN]++;</source>
<br /><spoiler title="Спойлер! Спойлер! Осторожно, спойлер содержит ответ!"><hr />
	<p>
		Я предупреждал…
	</p><p><br />
		И мы получаем уже привычные результаты симуляции:
	</p>
	<br /><!-- nohighlight --><source lang="bash">{300,164,164},
{300,164,164},
{300,300,164},
{214,300,300},
{214,300,300},
{299,163,299},</source>
<hr /></spoiler>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> перед продолжением откатите назад эти изменения.
</p>
<br /><h4><anchor>variruem-parametry</anchor><a href="#variruem-parametry" title="Ссылка на раздел"><font color="gray">#</font></a> Варьируем параметры</h4>
<p><br />
	Ранее я <a href="#znachenie-parametra-packetlength-v-ned-i-ini-faylah">упоминал про варьирование параметров</a>:
</p>
<blockquote cite="#znachenie-parametra-packetlength-v-ned-i-ini-faylah">
	Однако, при моделировании я уже успел поварьировать значения задержки между передачей пакетов, и размер пакетов, для достижения приемлемой плотности трафика. Поэтому в “.ini” файле вы не найдете значения “<code>1472B</code>”, вместо него там будет стоять “<strong><code>1446B</code></strong>”. Что, по сути, приводит размер “EtherPhyFrame” <nobr>(1526 байт)</nobr> к размеру IPv4 <nobr>(1500 байт)</nobr>, т.е., в этой версии модели, размер “EtherPhyFrame” составляет <nobr>1500 байт</nobr>.
</blockquote>
<p>
	Все это я делал примерно в этот момент, т.е. после настройки размера очереди у свитчей. Также у меня были другие начальные константы, из‑за чего результаты симуляции не выглядели столь “идеально”. Однако, это позволило лучше изучить поведение модели.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> представьте многомерные пространства (оси – параметры модели; значения – описывают реакцию модели; пространства – характеристики модели), в каждой точке которых модель реагирует “по своему”, можно объединить точки в кластеры по схожести реакции модели, …
</p><p><br />
	В спойлерах я приведу реакцию модели (результаты симуляции) на варьирование двух параметров:
</p>
<br /><ul>
	<li>период отправки пакетов (базовая задержка; сейчас равна 136 мкс; изменяется для “LLTRSuperApp” и “LLTRApp”);</li>
	<li>задержка между итерациями (“PROBING Timeout”; влияет на опустошение очередей в свитчах; сейчас равна x100 (136×100 мкс), т.е. ее достаточно для вывода из очереди более 100 накопившихся пакетов).</li>
</ul>
<p><br />
	Задержка между итерациями (<strong>x150</strong>).
</p>
<br /><spoiler title="Реакция модели"><hr />
	<!-- nohighlight --><source lang="bash">INFO:   {300,164,164},
INFO:   {300,164,164},
INFO:   {300,300,164},
INFO:   {214,300,300},
INFO:   {214,300,300},
INFO:   {299,163,299},</source>
<hr /></spoiler>
<p><br />
	Задержка между итерациями (<strong>x50</strong>).
</p>
<br /><spoiler title="Реакция модели"><hr />
	<!-- nohighlight --><source lang="bash">INFO:   {300,164,164},
INFO:   {300,126,126},
INFO:   {300,300,300},
INFO:   {214,300,300},
INFO:   {187,300,300},
INFO:   {299,163,299},</source>
<hr /></spoiler>
<p><br />
	Задержка между итерациями (<strong>x80</strong>).
</p>
<br /><spoiler title="Реакция модели"><hr />
	<!-- nohighlight --><source lang="bash">INFO:   {300,164,164},
INFO:   {300,155,155},
INFO:   {300,300,278},
INFO:   {214,300,300},
INFO:   {205,300,300},
INFO:   {299,163,299},</source>
<hr /></spoiler>
<p><br />
	Задержка между итерациями (<strong>x80</strong>); период отправки пакетов (“LLTRSuperApp”: <strong>136 мкс</strong>; “LLTRApp”: <strong>128 мкс</strong>).
</p>
<br /><spoiler title="Реакция модели"><hr />
	<!-- nohighlight --><source lang="bash">INFO:   {300,223,223},
INFO:   {300,216,216},
INFO:   {300,300,216},
INFO:   {223,300,300},
INFO:   {225,300,300},
INFO:   {299,222,299},</source>
<hr /></spoiler>
<p><br />
	Задержка между итерациями (<strong>x80</strong>); период отправки пакетов (“LLTRSuperApp”: <strong>128 мкс</strong>; “LLTRApp”: <strong>136 мкс</strong>).
</p>
<br /><spoiler title="Реакция модели"><hr />
	<!-- nohighlight --><source lang="bash">INFO:   {300,217,217},
INFO:   {300,204,204},
INFO:   {300,300,300},
INFO:   {219,300,300},
INFO:   {204,300,300},
INFO:   {299,216,299},</source>
<hr /></spoiler>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> если результаты последних двух симуляций кажутся вам странными, то не волнуйтесь – это пройдет после прочтения одной из следующих статей ；）
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> и опять, напоминаю: перед продолжением откатите назад эти изменения.
</p>
<br /><h4><anchor>bolshe-setey-s-raznymi-topologiyami-dobavlyaem-novye-seti</anchor><a href="#bolshe-setey-s-raznymi-topologiyami-dobavlyaem-novye-seti" title="Ссылка на раздел"><font color="gray">#</font></a> Больше сетей с разными топологиями, добавляем новые сети</h4>
<p><br /><anchor>git-tag-a1_v0-29-0</anchor>
	Пора проверить работу протокола (и адекватность модели) на нескольких сетях с разной топологией. Все сети <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/tree/a1_v0.29.0/LLTR/simulations">здесь… (git tag a1_v0.29.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.28.0...a1_v0.29.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>
</p><p><br />
	Файлы новых сетей:
</p>
<br /><ul>
	<li>“package-<strong>3_2</strong>.ned” – аналогична существующей сети, добавлен новый хост к левому свитчу;</li>
	<li>“package-<strong>2_3</strong>.ned” – аналогична существующей сети, добавлен новый хост к правому свитчу;</li>
	<li>“package-<strong>tree</strong>.ned” – топология дерево: “<a href="https://habr.com/post/414799/#topologiya-zvezda-iz-svitchey">звезда из свитчей</a>”;</li>
	<li>“package-<strong>serial</strong>.ned” – топология дерево: “<a href="https://habr.com/post/414799/#topologiya-posledovatelnoe-soedinenie-svitchey">последовательное соединение свитчей</a>”.</li>
</ul>
<p><br />
	При запуске симулятора, теперь можно выбрать одну из сетей:
</p>
<br /><anchor>fig_qtenv-set_config-set_network</anchor><img alt="qtenv: set config – set network" align="center" height="168" src="https://habrastorage.org/webt/1r/rl/ul/1rrlulraswqt4qomai42uzh39i4.png#qtenv-set_config-set_network.png"/>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> “(General)” – это наша первая сеть (4 хоста, 2 свитча, т.е. “N2_2”).
</p><p><br />
	Если просто добавить файлы новых сетей, рядом с файлом существующей сети, то симулятор не покажет этот диалог. Чтобы появился этот диалог, в “omnetpp.ini” нужно добавить новые <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:config-sim:sections">секции</a>, точнее “<a href="https://omnetpp.org/doc/omnetpp/manual/#sec:config-sim:named-configurations">Named Configurations</a>” (<nobr>OMNeT++</nobr> - Simulation Manual).
</p><p><br />
	По сути, я создал несколько новых “именованных конфигураций”/секций, которые переопределяют параметр “<code>network</code>” секции “<code>[General]</code>” (<a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/blob/a1_v0.29.0/LLTR/simulations/omnetpp.ini#L33-L43">строка 33</a>):
</p>
<br /><source lang="ini">[Config N3_2]
network = lltr.Network_<strong>3_2</strong>

[Config N2_3]
network = lltr.Network_<strong>2_3</strong>

[Config Tree]
network = lltr.Network_<strong>tree</strong>

[Config Serial]
network = lltr.Network_<strong>serial</strong></source>
<p><br />
	Посмотрим на новые сети поближе.
</p><p><br />
	Сеть “<code>Network_<strong>3_2</strong></code>” (конфигурация “N3_2”):
</p>
<br /><anchor>fig_network_3_2</anchor><img alt="Network 3_2" align="center" height="471" src="https://habrastorage.org/webt/td/5s/cb/td5scbzv-y-edwkmvp6fsn0-4nk.png#network_3_2.png"/>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> Попробуйте закомментировать “<code>**.interfaceTable.displayAddresses = false</code>” в “omnetpp.ini”, и посмотреть на назначенные IP‑адреса хостов. Попробовали? А теперь переподключите “hostS” на “switch1”, и снова посмотрите на IP‑адреса хостов…
</p>
<br /><spoiler title="Результаты симуляции"><hr />
	<!-- nohighlight --><source lang="bash">INFO:   {300,164,164,300},
INFO:   {300,164,164,300},
INFO:   {300,300,300,164},

INFO:   {300,300,164,300},
INFO:   {300,300,300,<strong>214</strong>},
INFO:   {<strong>214</strong>,300,300,300},

INFO:   {300,300,300,<strong>214</strong>},
INFO:   {<strong>214</strong>,300,300,300},
INFO:   {300,164,300,300},

INFO:   {164,300,300,300},
INFO:   {300,164,164,300},
INFO:   {299,163,163,299},</source>
	<p><br />
		<font color="#54524F"><b>Note</b>:</font> пустые строки расставлены для улучшения восприятия – они визуально группируют итерации по unicast src хосту.
	</p><p><br />
		Заметили закономерность? Если unicast трафик проходит в направлении от “switch1” к “switch0”, то мы получаем число 214. Во всех остальных случаях (трафик направлен от “switch0” к “switch1”, либо когда unicast src и dst хосты подключены к одному и тому же свитчу) получаем число 164.
	</p><p><br />
		В чем отличие между “switch0” и “switch1”? В том, что “hostS” подключен к “switch0” ?!
	</p>
<hr /></spoiler>
<p><br />
	Сеть “<code>Network_<strong>2_3</strong></code>” (конфигурация “N2_3”):
</p>
<br /><anchor>fig_network_2_3</anchor><img alt="Network 2_3" align="center" height="471" src="https://habrastorage.org/webt/us/gk/en/usgkenladna6vkov1prmrnrg-c4.png#network_2_3.png"/>
<br /><spoiler title="Результаты симуляции"><hr />
	<!-- nohighlight --><source lang="bash">INFO:   {300,164,164,164},
INFO:   {300,164,164,164},
INFO:   {300,164,164,164},

INFO:   {300,300,164,300},
INFO:   {300,300,300,164},
INFO:   {214,300,300,300},

INFO:   {300,300,300,164},
INFO:   {214,300,300,300},
INFO:   {300,164,300,300},

INFO:   {214,300,300,300},
INFO:   {300,164,300,300},
INFO:   {299,299,163,299},</source>
	<p><br />
		<font color="#54524F"><b>Note</b>:</font> пустые строки расставлены для улучшения восприятия – они визуально группируют итерации по unicast src хосту.
	</p>
<hr /></spoiler>
<p><br />
	Сеть “<code>Network_<strong>tree</strong></code>” (конфигурация “Tree”):
</p>
<br /><anchor>fig_network_tree</anchor><img alt="Network tree" align="center" height="425" src="https://habrastorage.org/webt/rz/im/tz/rzimtz4agyepstiepewna2b4mhm.png#network_tree.png"/>
<br /><spoiler title="Результаты симуляции"><hr />
	<!-- nohighlight --><source lang="bash">INFO:   {300,164,164,164,164},
INFO:   {300,164,164,164,164},
INFO:   {300,164,164,164,164},
INFO:   {300,164,164,164,164},

INFO:   {300,300,164,300,300},
INFO:   {300,300,300,214,214},
INFO:   {300,300,300,214,214},
INFO:   {<strong>264</strong>,300,300,300,300},

INFO:   {300,300,300,214,214},
INFO:   {300,300,300,214,214},
INFO:   {<strong>264</strong>,300,300,300,300},
INFO:   {300,164,300,300,300},

INFO:   {300,300,300,300,164},
INFO:   {<strong>264</strong>,300,300,300,300},
INFO:   {300,214,214,300,300},
INFO:   {300,214,214,300,300},

INFO:   {<strong>264</strong>,300,300,300,300},
INFO:   {300,214,214,300,300},
INFO:   {300,214,214,300,300},
INFO:   {299,299,299,163,299},</source>
	<p><br />
		<font color="#54524F"><b>Note</b>:</font> пустые строки расставлены для улучшения восприятия – они визуально группируют итерации по unicast src хосту.
	</p>
<hr /></spoiler>
<p><br />
	Сеть “<code>Network_<strong>serial</strong></code>” (конфигурация “Serial”):
</p>
<br /><anchor>fig_network_serial</anchor><img alt="Network serial" align="center" height="425" src="https://habrastorage.org/webt/ta/yn/0c/tayn0cltf-igcsxyrgcqhxzkgoy.png#network_serial.png"/>
<br /><spoiler title="Результаты симуляции"><hr />
	<!-- nohighlight --><source lang="bash">INFO:   {300,164,164,164,164,164,164,300,300},
INFO:   {300,164,164,164,164,164,164,300,300},
INFO:   {300,164,164,164,164,164,164,300,300},
INFO:   {300,164,164,164,164,164,164,300,300},
INFO:   {300,164,164,164,164,164,164,300,300},
INFO:   {300,164,164,164,164,164,164,300,300},
INFO:   {300,300,300,300,300,300,300,164,164},
INFO:   {300,300,300,300,300,300,300,164,164},

INFO:   {300,300,164,300,300,300,300,300,300},
INFO:   {300,300,300,164,164,164,164,300,300},
INFO:   {300,300,300,164,164,164,164,300,300},
INFO:   {300,300,300,164,164,164,164,300,300},
INFO:   {300,300,300,164,164,164,164,300,300},
INFO:   {300,300,300,300,300,300,300,214,214},
INFO:   {300,300,300,300,300,300,300,214,214},
INFO:   {214,300,300,300,300,300,300,300,300},

INFO:   {300,300,300,164,164,164,164,300,300},
INFO:   {300,300,300,164,164,164,164,300,300},
INFO:   {300,300,300,164,164,164,164,300,300},
INFO:   {300,300,300,164,164,164,164,300,300},
INFO:   {300,300,300,300,300,300,300,214,214},
INFO:   {300,300,300,300,300,300,300,214,214},
INFO:   {214,300,300,300,300,300,300,300,300},
INFO:   {300,164,300,300,300,300,300,300,300},

INFO:   {300,300,300,300,164,300,300,300,300},
INFO:   {300,300,300,300,300,164,164,300,300},
INFO:   {300,300,300,300,300,164,164,300,300},
INFO:   {300,300,300,300,300,300,300,264,264},
INFO:   {300,300,300,300,300,300,300,264,264},
INFO:   {264,300,300,300,300,300,300,300,300},
INFO:   {300,214,300,300,300,300,300,300,300},
INFO:   {300,300,214,300,300,300,300,300,300},

INFO:   {300,300,300,300,300,164,164,300,300},
INFO:   {300,300,300,300,300,164,164,300,300},
INFO:   {300,300,300,300,300,300,300,264,264},
INFO:   {300,300,300,300,300,300,300,264,264},
INFO:   {264,300,300,300,300,300,300,300,300},
INFO:   {300,214,300,300,300,300,300,300,300},
INFO:   {300,300,214,300,300,300,300,300,300},
INFO:   {300,300,300,164,300,300,300,300,300},

INFO:   {300,300,300,300,300,300,164,300,300},
INFO:   {300,300,300,300,300,300,300,300,300},
INFO:   {300,300,300,300,300,300,300,300,300},
INFO:   {300,300,300,300,300,300,300,300,300},
INFO:   {300,264,300,300,300,300,300,300,300},
INFO:   {300,300,264,300,300,300,300,300,300},
INFO:   {300,300,300,214,300,300,300,300,300},
INFO:   {300,300,300,300,214,300,300,300,300},

INFO:   {300,300,300,300,300,300,300,300,300},
INFO:   {300,300,300,300,300,300,300,300,300},
INFO:   {300,300,300,300,300,300,300,300,300},
INFO:   {300,264,300,300,300,300,300,300,300},
INFO:   {300,300,264,300,300,300,300,300,300},
INFO:   {300,300,300,214,300,300,300,300,300},
INFO:   {300,300,300,300,214,300,300,300,300},
INFO:   {300,300,300,300,300,164,300,300,300},

INFO:   {300,300,300,300,300,300,300,300,164},
INFO:   {214,300,300,300,300,300,300,300,300},
INFO:   {300,214,214,214,214,214,214,300,300},
INFO:   {300,214,214,214,214,214,214,300,300},
INFO:   {300,214,214,214,214,214,214,300,300},
INFO:   {300,214,214,214,214,214,214,300,300},
INFO:   {300,214,214,214,214,214,214,300,300},
INFO:   {300,214,214,214,214,214,214,300,300},

INFO:   {214,300,300,300,300,300,300,300,300},
INFO:   {300,214,214,214,214,214,214,300,300},
INFO:   {300,214,214,214,214,214,214,300,300},
INFO:   {300,214,214,214,214,214,214,300,300},
INFO:   {300,214,214,214,214,214,214,300,300},
INFO:   {300,214,214,214,214,214,214,300,300},
INFO:   {300,214,214,214,214,214,214,300,300},
INFO:   {299,299,299,299,299,299,299,163,299},</source>
	<p><br />
		<font color="#54524F"><b>Note</b>:</font> пустые строки расставлены для улучшения восприятия – они визуально группируют итерации по unicast src хосту.
	</p><p><br />
		<font color="#54524F"><b>Note</b>:</font> “<a href="https://ru.wikiquote.org/wiki/Матрица_(фильм)">Я уже даже не вижу код. Я вижу блондинку, брюнетку, рыжую.</a>” (<em>The Matrix</em>) → “Я уже даже не вижу числа. Я вижу, топологию.”
	</p><p><br />
		“<a href="https://ru.wikiquote.org/wiki/Матрица:_Революция#Пифия">Все, что имеет начало, имеет и конец. Я вижу конец…</a>”, точнее вижу проблему с итерациями, в которых хост из левого конца (“host6” или “host5”) посылает unicast трафик на хост из правого конца (“host7” или “host8” или “host0”). Однако, собранных данных достаточно, чтобы корректно построить топологию сети. (<em>Пифия</em>)
	</p>
<hr /></spoiler>
<p><br />
	Похоже, что проблема не одинакового количества принятых broadcast пакетов (164, 214, 264, 300) зависит:
</p>
<br /><ul>
	<li>[отчасти] от близости unicast dst хоста к broadcast src (“hostS”);</li>
	<li>от удаленности unicast src хоста от свитча, который “вливает” unicast и broadcast трафик в один канал (т.е. от количества промежуточных свитчей между ними);</li>
	<li>от числа 50…</li>
</ul>
<p><br /><anchor>git-tag-a1_v0-30-0</anchor>
	Проверим это предположение. Я добавил еще две сети… <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/tree/a1_v0.30.0/LLTR/simulations">(git tag a1_v0.30.0)</a> <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/compare/a1_v0.29.0...a1_v0.30.0"><img alt="diff" title="diff" width="19" height="19" src="https://habrastorage.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/></a>
</p><p><br />
	Файлы новых сетей:
</p>
<br /><ul>
	<li>“package-<strong>serial-len-test</strong>.ned” – аналогичен “<code>Network_<strong>serial</strong></code>”, для более быстрой симуляции убраны все хосты, кроме подключенных к крайним свитчам, и подключенных к “switch0”;</li>
	<li>“package-<strong>serial-len-test-simple</strong>.ned” – аналогичен “<code>Network</code>” (“N2_2”, “(General)”), добавлены несколько промежуточных свитчей (это еще более упрощенный вариант сети “<code>Network_<strong>serial</strong></code>”).</li>
</ul>
<p><br />
	Сеть “<code>Network_<strong>serial-len-test</strong></code>” (конфигурация “SerialLenTest”):
</p>
<br /><anchor>fig_network_serial_len_test</anchor><img alt="Network serial-len-test" align="center" height="425" src="https://habrastorage.org/webt/jf/vo/tr/jfvotrlmvxk4ndqpfcdebwzcgxy.png#network_serial_len_test.png"/>
<br /><spoiler title="Результаты симуляции"><hr />
	<!-- nohighlight --><source lang="bash">INFO:   {300,164,164,300,300},
INFO:   {300,164,164,300,300},
INFO:   {300,300,300,164,164},
INFO:   {300,300,300,164,164},

INFO:   {300,300,164,300,300},
INFO:   {300,300,300,300,300},
INFO:   {300,300,300,300,300},
INFO:   {300,300,300,300,300},

INFO:   {300,300,300,300,300},
INFO:   {300,300,300,300,300},
INFO:   {300,300,300,300,300},
INFO:   {300,164,300,300,300},

INFO:   {300,300,300,300,164},
INFO:   {214,300,300,300,300},
INFO:   {300,214,214,300,300},
INFO:   {300,214,214,300,300},

INFO:   {214,300,300,300,300},
INFO:   {300,214,214,300,300},
INFO:   {300,214,214,300,300},
INFO:   {299,299,299,163,299},</source>
	<p><br />
		<font color="#54524F"><b>Note</b>:</font> пустые строки расставлены для улучшения восприятия – они визуально группируют итерации по unicast src хосту.
	</p><p><br />
		Удаление хостов не повлияло на проблему с крайними хостами (из “<code>Network_<strong>serial</strong></code>”), что логично.
	</p>
<hr /></spoiler>
<p><br />
	Сеть “<code>Network_<strong>serial-len-test-simple</strong></code>” (конфигурация “SerialLenTestSimple”):
</p>
<br /><anchor>fig_network_serial_len_test_simple</anchor><img alt="Network serial-len-test-simple" align="center" height="471" src="https://habrastorage.org/webt/ak/v-/km/akv-kmalqldyhd44st4lrgnnv7e.png#network_serial_len_test_simple.png"/>
<br /><spoiler title="Результаты симуляции"><hr />
	<!-- nohighlight --><source lang="bash">INFO:   {300,164,164},
INFO:   {300,164,164},
INFO:   {300,300,164},
INFO:   {300,300,300},
INFO:   {300,300,300},
INFO:   {299,163,299},</source>
	<p><br />
		Получилось воспроизвести проблему на топологии исходной сети, изменяя количество промежуточных свитчей.
	</p>
<hr /></spoiler>
<p><br />
	Мы немного “приоткрыли” неучтенный фактор, и, <a href="#unclear-factor">как я писал ранее</a>, окончательно раскрою его в одной из следующих статей.
</p>
<br /><h3><anchor>shag-6-shag-vpered-shag-nazad</anchor><a href="#shag-6-shag-vpered-shag-nazad" title="Ссылка на раздел"><font color="gray">#</font></a> Шаг 6: шаг вперед, шаг назад</h3>
<p><br />
	Этот шаг должен был называться “последние штрихи”, и начинаться примерно так:
</p>
<br /><spoiler title="Последние штрихи"><hr />
	<p>
		Мы уже несколько раз пытались бороться с адресацией хостов:
	</p>
	<br /><ol>
		<li>вначале пытались <a href="#pomeschaem-hosty-v-vektor">поместить хосты в несуществующий вектор</a>;</li>
		<li>затем просто <a href="#shag-4-realizaciya-protokola-versiya-v_basic_global-wave">сделали более удобную индексацию (в именах) у хостов, и назначили “не вводящие в заблуждение” IP‑адреса</a>.</li>
	</ol>
	<p><br />
		И, на данный момент, чтобы получить IP‑адрес хоста нам приходится <strong>каждый раз</strong> делать так (немного упростил):
	</p>
	<br /><!-- nohighlight --><source lang="bash">Берем индекс хоста (<strong>число</strong>)
–-[itoa]--&gt; получаем имя хоста &quot;host#&quot; (<strong>строка</strong>)
–-[getModuleByPath; последовательно перебирая все модулей сети, ищем модуль хоста по его имени]--&gt; получаем модуль хоста (<strong>указатель</strong>)
-–[getNetworkAddress]--&gt; наконец, получаем IP-адрес хоста (<strong>число</strong>).</source>
	<p><br />
		То есть:
	</p>
	<br /><!-- nohighlight --><source lang="bash"><strong>0</strong> -&gt; &quot;host0&quot; -&gt; *** -&gt; 10.0.1.<strong>0</strong>
<strong>1</strong> -&gt; &quot;host1&quot; -&gt; *** -&gt; 10.0.1.<strong>1</strong>
<strong>2</strong> -&gt; &quot;host2&quot; -&gt; *** -&gt; 10.0.1.<strong>2</strong>
...</source>
	<p><br />
		Не кажется странным, что проще было бы сразу получить число (10.0.1.<strong>0</strong>) из числа (<strong>0</strong>)?
	</p><p><br />
		А теперь <a href="#pomeschaem-hosty-v-vektor">вспомним</a>, из‑за чего нам приходится делать именно так:
	</p>
	<blockquote cite="#pomeschaem-hosty-v-vektor">
		Сейчас мы для соединения с “host1” используем его IP‑адрес “10.0.1.2”. Однако, все адреса распределяются автоматически, и не факт, что “host1” всегда будет иметь адрес “10.0.1.2”.
	</blockquote>
	<p>
		Однако, <a href="#shag-4-realizaciya-protokola-versiya-v_basic_global-wave">далее</a> мы добились соответствия номера unicast src/dst хоста его IP‑адресу, с некоторыми ограничениями.
	</p>
<hr /></spoiler>
<p><br />
	А заканчиваться:
</p>
<br /><ul>
	<li>прямым конвертированием индекса хоста в его IP‑адрес;</li>
	<li>проверкой в “LLTRSuperApp” (в самом начале стадии инициализации <em>INITSTAGE_APPLICATION_LAYER</em>) соответствия IP‑адрес↔индекс хоста;</li>
	<li>удалением класса “<code>HostPath_defSuperHost_</code>”.</li>
</ul>
<p><br />
	Проверка соответствия IP‑адрес↔индекс хоста должна была выглядеть так:
</p>
<br /><ol>
	<li>пройтись по списку всех дочерних модулей сети:</li>
	<li>искать “<code>&quot;host*&quot;</code>”, пропускать “<code>&quot;hostS&quot;</code>”;</li>
	<li>использовать “<code>atoi()</code>” для получения индекса хоста;</li>
	<li>преобразовать число в “IP‑адрес”;</li>
	<li>сложить полученный “IP‑адрес” с базовым/начальным IP‑адресом (10.0.1.0);</li>
	<li>сверить с IP‑адресом хоста</li>
	<li>если не совпало, то кинуть “<code>throw cRuntimeError()</code>”.</li>
</ol>
<p><br />
	Это позволило бы точно определить нарушение соответствия. Например, оно сразу бы обнаружило несоответствие в “<code>Network_<strong>3_2</strong></code>”, и предотвратило запуск симуляции (для запуска нужно было бы переименовать хосты: “<code>&quot;host3&quot;</code>” → “<code>&quot;host1&quot;</code>”′; “<code>&quot;host1&quot;</code>” → “<code>&quot;host2&quot;</code>”′; “<code>&quot;host2&quot;</code>” → “<code>&quot;host3&quot;</code>”′ – в точности как были назначены IP‑адреса).
</p><p><br />
	<strong>Почему же я это все не сделал</strong>? При изменении индексов хостов, также меняется порядок сканирования сети (порядок итераций). Но я не хотел менять порядок сканирования сети. Например, в “<code>Network_<strong>3_2</strong></code>” было важно, чтобы “host3” был unicast src хостом именно в последних итерациях (для корректного сравнения с результатами “<code>Network_<strong>2_3</strong></code>” и “<code>Network</code>”/“N2_2”), и я не могу изменить его имя на “host1”, т.к. это изменит порядок сканирования.
</p><p><br />
	К тому же, изменение индекса хоста – это самый быстрый способ изменения последовательности сканирования, и не хотелось бы от него отказываться (от возможности быстро проверить реакцию модели на другой порядок сканирования).
</p><p><br />
	В итоге, оставался только один вариант для сохранения соответствия (IP‑адрес↔индекс) – <strong>реализовать свой “*NetworkConfigurator”</strong> на основе “IPv4NetworkConfigurator”. Причем, код, проверяющий соответствие (из <em>INITSTAGE_APPLICATION_LAYER</em> в “LLTRSuperApp”) помог бы и здесь.
</p><p><br />
	Однако, не зря этот шаг называется “шаг вперед, шаг назад” – предлагаю потренироваться с созданием “*NetworkConfigurator”, сделав собственный “последний штрих”.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> Следующие статьи не будут требовать строгого соответствия IP‑адреса хоста и его индекса. Поэтому можете, не торопясь, хорошо продумать реализацию.
</p><p><br />
	Теперь самое время прочитать оригинальную документацию (“inet/doc/inet-manual-draft.pdf” и “omnetpp-5.0/doc/*”) от начала и до конца. В частности, рекомендую посмотреть “UserGuide.pdf” и “manual/index.html” (в нем находится Simulation Manual именно для версии 5.0).
</p>
<br /><spoiler title="Про ссылки на Simulation Manual"><hr />
	<p>
		В этой статье все ссылки вели на online версию Simulation Manual, которая предназначена для последней версии <nobr>OMNeT++</nobr>. Жалко, что они не хранят документацию, раздельно для каждой вышедшей версии (я нашел только для версии 4.6: “<a href="https://omnetpp.org/doc/omnetpp4/manual/usman.html">omnetpp.org/doc/omnetpp4/manual/usman.html</a>”). Поэтому надеюсь, что новые версии документации (в пределах 5.*) будут совместимы с 5.0. Во всяком случае, всегда есть локальная версия, и “<a href="https://web.archive.org/web/20170802125337/https://omnetpp.org/doc/omnetpp/manual/">web.archive.org/web/20170802125337/https://omnetpp.org/doc/omnetpp/manual/</a>” (начиная с 5.1.1).
	</p>
<hr /></spoiler>

<br /><h2><anchor>ps</anchor><a href="#ps" title="Ссылка на раздел"><font color="gray">#</font></a> P.S.</h2><hr />
<p>
	Если вам, так же как и мне, не нравится стандартные иконки устройств, и фон инспектора сети в симуляторе, то это можно легко исправить.
</p>
<br /><h3><anchor>zamena-standartnyh-ikonok</anchor><a href="#zamena-standartnyh-ikonok" title="Ссылка на раздел"><font color="gray">#</font></a> Замена стандартных иконок</h3>
<p><br />
	Если вам понравилась иконка хоста (“<code>&quot;device/pc2&quot;</code>”) и свитча (“<code>&quot;device/switch&quot;</code>”) из этой статьи, то разархивируйте (7zip) эту картинку в “omnetpp-5.0/images/device/”:
</p>
<br /><anchor>fig_new-device-icons-un_7z_me</anchor><img alt="new device icons (un[7z]me)" align="center" height="157" src="https://habrastorage.org/webt/3j/oh/gm/3johgmlafqmlvaqtcsgbxs95aly.png#new-device-icons-un_7z_me.png"/>
<br /><h3><anchor>zamena-cveta-fona-zelenogo-v-tkenv</anchor><a href="#zamena-cveta-fona-zelenogo-v-tkenv" title="Ссылка на раздел"><font color="gray">#</font></a> Замена цвета фона (зеленого) в Tkenv</h3>
<br /><anchor>fig_tkenv-green_background-x64dbg</anchor><img alt="tkenv: green background – x64dbg (жучки атакуют!)" align="center" height="283" src="https://habrastorage.org/webt/hh/xh/es/hhxhesumevvor1z7f8oinpaygxq.png#tkenv-green_background-x64dbg.png"/>
<p><br />
	Чтобы заменить цвет, надо знать место, где он задается (в коде) или находится (в памяти). Чтобы найти это место, надо определить числовое значение цвета (RGB):
</p>
<br /><ol>
	<li>делаем скриншот окна симулятора;</li>
	<li>в любом растровом графическом редакторе, “пипеткой” определяем цвет.</li>
</ol>
<p><br />
	Числовое значение “зеленого” цвета фона: <font color="#A00000">A0</font><font color="#00E000">E0</font><font color="#0000A0">A0</font> (hex); <font color="#A00000">R</font>:160, <font color="#00E000">G</font>:224, <font color="#0000A0">B</font>:160.
</p><p><br />
	Я пока еще не подобрал цвет фона на замену, и у меня есть 3 варианта (пути) дальнейших действий:
</p>
<br /><ol>
	<li>[<strong>долгий</strong>] поиск цвета в исходниках, {замена цвета на один из вариантов, компиляция, просмотр результата}(повторять в цикле, пока не будет найден “оптимальный цвет”);</li>
	<li>[<strong>повышающий скилы Reverse Engineering; хакерский</strong>] поиск цвета в памяти запущенной программы, {замена цвета на один из вариантов в “интерактивном режиме”}(повторять в цикле, пока не будет найден “оптимальный цвет”);</li>
	<li>[<strong>прототипный</strong>] сделать скриншот, и менять цвет в любом графическом редакторе.</li>
</ol>
<p><br />
	Начнем с конца: “<strong>прототипный</strong>” вариант – самый быстрый, однако, сам графический редактор (его GUI) может повлиять на выбор итогового цвета, поэтому при подборе цвета нужно скрыть весь GUI редактора, оставив только холст, а еще лучше – переключится в полноэкранный режим. Минус этого пути – он позволяет только подобрать цвет, в то время как остальные варианты позволяют изменить (зафиксировать) цвет в самой программе.
</p><p><br />
	“<strong>Долгий</strong>” вариант можно сразу отбросить, к тому же “собирать пазл”, пробираясь сквозь дебри классово‑объектного (с привкусом лазании) кода <nobr>OMNeT++</nobr> уже поднадоело. Хочется простоты, и возможности сразу видеть финальный результат. Как в графическом редакторе, поддерживающем слои – мы можем работать, как и с отдельными слоями или группами слоев, так и с итоговым изображением в целом. Причем, работая с отдельными слоями можно сразу же видеть влияние внесенных изменений на всю картину в целом.
</p><p><br />
	Я опишу “<strong>хакерский</strong>” вариант с простым asm, и работой с “финальным результатом” (скомпилированной, слинкованной, и запущенной программой). Он состоит из нескольких шагов:
</p>
<br /><ol>
	<li>запускаем симулятор (Tkenv);</li>
	<li>запускаем отладчик <a href="http://x64dbg.com">x64_dbg</a> (32bit версию, т.к. Tkenv – 32bit) (его возможностей вполне достаточно для наших целей);</li>
	<li>подключаемся к процессу Tkenv (<nobr>File &gt;</nobr> Attach; “<code>LLTR.exe</code>”), и “размораживаем” (нижний левый угол – “Paused”) Tkenv (<nobr>Debug &gt;</nobr> Run);</li>
	<li>ищем в памяти нужную константу (“<code><font color="#A00000">A0</font><font color="#00E000">E0</font><font color="#0000A0">A0</font></code>” <a href="https://en.wikipedia.org/wiki/Endianness?stable=1#Little-endian">RGB</a> или “<code><font color="#0000A0">A0</font><font color="#00E000">E0</font><font color="#A00000">A0</font></code>” <a href="https://en.wikipedia.org/wiki/Endianness?stable=1#Big-endian">BGR</a> ；） ;</li>
	<li>меняем ее в нужном месте.</li>
</ol>
<br /><spoiler title="Подробнее про “ищем в памяти нужную константу” и “меняем ее в нужном месте”"><hr />
	<p>
		Для поиска константы (паттерна):
	</p>
	<br /><ul>
		<li>открываем вкладку “Memory Map”;</li>
		<li>выбираем первую строку (начало адресного пространства);</li>
		<li>в контекстном меню выбираем “Find Pattern…” (<kbd>Ctrl+B</kbd>);</li>
		<li>используем Hex паттерн (“<code><nobr>A0 E0 A0</nobr></code>”) для поиска.</li>
	</ul>
	<p><br />
		<font color="#54524F"><b>Note</b>:</font> x64_dbg ищет начиная с текущего адреса (выбранной строки), и до конца адресного пространства. Поэтому, для поиска по всему адресному пространству важно следить за тем, чтобы была выбрана первая строка, и список был отсортирован по столбцу “Address”.
	</p><p><br />
		Результаты поиска отобразятся во вкладке “References” (после поиска опять нужно разморозить (<nobr>Debug &gt;</nobr> Run) Tkenv):
	</p>
	<br /><anchor>fig_x64_dbg-1-references-pattern_a0_e0_a0_1</anchor><img alt="references – pattern a0e0a0" align="center" height="569" src="https://habrastorage.org/webt/zh/rm/bk/zhrmbkrkecvcjuo-sry3kfsd2uy.png#x64_dbg-1-references-pattern_a0_e0_a0_1.png"/>
	<br /><!-- nohighlight --><source lang="bash">Address  | Data
===================
0497801C | A0 E0 A0
0497A6C0 | A0 E0 A0
0497DE60 | A0 E0 A0
0497DED0 | A0 E0 A0
0497DF60 | A0 E0 A0
0497DFD0 | A0 E0 A0

078E7EFB | A0 E0 A0
079A8235 | A0 E0 A0
079C8235 | A0 E0 A0
079E8235 | A0 E0 A0

662CE88D | A0 E0 A0

7340A1A7 | A0 E0 A0
7340A31D | A0 E0 A0
7340A4CF | A0 E0 A0
7340A693 | A0 E0 A0
7340A80F | A0 E0 A0
7340A935 | A0 E0 A0
7340AA69 | A0 E0 A0
7340AB71 | A0 E0 A0
7340ADAF | A0 E0 A0
7340B1B7 | A0 E0 A0
7344E1ED | A0 E0 A0

77E1924B | A0 E0 A0
77E1936B | A0 E0 A0</source>
	<p><br />
		Совпадений несколько, поэтому перед “лихорадочным” изменением значений в памяти программы, хорошо бы знать, кто владеет областью памяти, в которой нашлось совпадение. Поэтому возвращаемся в “Memory Map”, и смотрим, в какой диапазон попали найденные адреса:
	</p>
	<br /><!-- nohighlight --><source lang="bash">Address  | Size     | Page Info                 | Alloc Type | Current Prot | Alloc Prot
========================================================================================
048A0000 | 00400000 |                           | PRV        | -RW--        | -RW--
07430000 | 00930000 | ...\Fonts\StaticCache.dat | MAP        | -R---        | -R---
6621F000 | 000DD000 | libiconv-2.dll &gt; &quot;.rdata&quot; | IMG        | -R---        | ERWC-
733B0000 | 0005C000 | netapi32.dll &gt;            | IMG        | -R---        | ERWC-
77C70000 | 001AA000 | imm32.dll &gt;               | IMG        | -R---        | ERWC-</source>
	<p><br />
		Было бы очень странно, если значение, задающее цвет фона инспектора сети, находилось бы в последних 4‑х диапазонах памяти. Остался только первый диапазон памяти (0x048A0000 + 0x00400000), это означает, что стоит исключить все результаты поиска, кроме первых 6‑и.
	</p><p><br />
		Изменять значения в памяти все еще “опасно”, сперва стоит взглянуть на код, использующий найденные области памяти. Последовательно повторяем, для каждого из 6‑и найденных адресов:
	</p>
	<br /><ol>
		<li>[открываем дамп памяти по найденному адресу] в “References” → контекстное меню результата поиска → “<strong>Follow in Dump</strong>”</li>
		<li>[создаем точку останова на доступ (чтение/запись) к памяти] в “Dump 1” (вкладка в нижней части окна) (начало паттерна будет выделено) → контекстное меню → <strong>Breakpoint</strong> → <strong>Hardware</strong>, Access → Dword;</li>
		<li>[пытаемся вызвать код, перерисовывающий фон] c Tkenv:
			<ul>
				<li>сворачиваем/разворачиваем окно;</li>
				<li>меняем размер окна;</li>
				<li>перемещаем (скролим) область сети/модуля;</li>
				<li>увеличиваем/уменьшаем (лупы +/-) область сети/модуля;</li>
				<li>открываем модуль‑хост/свитч (двойной клик по модулю), и возвращаемся назад к сети;</li>
				<li>открываем дочернее окно инспектора сети (<nobr>Inspect &gt;</nobr> Network);</li>
				<li>перестраиваем сеть (“Re‑layout”, кнопка “обновить”);</li>
			</ul>
		</li>
		<li>Если код нам <em>нравится</em> (напоминает код “перерисовывающий что‑либо”), то пробуем изменить “<code><nobr>A0 <strong>E0</strong> A0</nobr></code>” на “<code><nobr>A0 <strong>00</strong> A0</nobr></code>” (двойной клик на “<code><strong>E0</strong></code>” в “Dump 1”), и смотрим результат. Дополнительно можно поставить точку останова на сам код, и посмотреть, с какими параметрами (окружением) он также работает (т.е. просмотреть стек и регистры).</li>
		<li>Отключаем точку останова во вкладке “Breakpoints”, секция “Hardware” – выключаем нажатием пробела (если адрес нам “<em>подходит</em>”), либо удаляем нажатием Del (если адрес нам “<em>не подходит</em>”).</li>
	</ol>
	<p><br />
		<font color="#54524F"><b>Note</b>:</font> слово “нравится”: по сути я подменил “подходит” (результат) на “нравится” (причину). При этом саму причину я детально не раскрыл. В данном случае “подходит” – это положительный результат оценки (тестирования) фрагмента кода на присутствие нескольких признаков. <em>Также как и искусственная нейросеть сама не может дать ответ на вопрос “Почему?” (“Почему ты выбрала именно этот ответ?”), так и опытный человек (</em><a href="https://habrahabr.ru/post/181372">неосознанная</a> <a href="https://habrahabr.ru/company/stratoplan/blog/198870">компетентность</a><em> – 2 ссылки) часто не сможет сразу дать ответ на этот вопрос</em>.
	</p><p><br />
		К первому адресу (0x<strong>0497801C</strong> [0]) было обращение только при “Re‑layout”:
	</p>
	<br /><anchor>fig_x64_dbg-2-cpu-hardware_breakpoint_0x0497801C</anchor><img alt="cpu – hardware breakpoint 0x0497801C" align="center" height="736" src="https://habrastorage.org/webt/6f/kl/vr/6fklvrqsmfrqwxyvfjkah5skrye.png#x64_dbg-2-cpu-hardware_breakpoint_0x0497801C.png"/>
	<p><br />
		В этом фрагменте привлекают внимание вызовы “<code>tk86.XSetWindowBackground</code>” и “<code>tk86.XChangeWindowAttributes</code>”. Однако, при попытке изменить “<code><nobr>A0 <strong>E0</strong> A0</nobr></code>” на “<code><nobr>A0 <strong>00</strong> A0</nobr></code>” ничего не происходит. Более того, при повторном “Re‑layout” (либо при изменении значения в процессе “Re‑layout”) значение возвращается назад – на “<code><nobr>A0 <strong>E0</strong> A0</nobr></code>”.
	</p><p><br />
		Подсказка, почему это происходит (на скриншоте помечено синим):
	</p>
	<br /><!-- nohighlight --><source lang="bash">= EСX{00 A0 E0 A0} =

EСX{00 A0 E0 A0} =&gt; ds:[eax{04977FC0}+5C = <strong>0497801C</strong>] -&gt; Hardware Breakpoint (write)
EСX{00 A0 E0 A0} &lt;= ss:[esp{0028EC90}+24 = <em>0028ECB4</em>] &lt;- Stack</source>
	<p><br />
		<font color="#54524F"><b>Note</b>:</font> <a href="https://ru.wikipedia.org/wiki/Регистр_процессора?stable=1#Архитектура_x86">если подзабыли назначение/наименование регистров/сегментов x86 (cs, ds, ss, …)</a>.
	</p><p><br />
		Следующий адрес (0x<strong>0497A6C0</strong> [1]) был более интересным (обращение также – только при “Re‑layout”):
	</p>
	<br /><anchor>fig_x64_dbg-3-cpu-hardware_breakpoint_0x0497A6C0</anchor><img alt="cpu – hardware breakpoint 0x0497A6C0" align="center" height="624" src="https://habrastorage.org/webt/dr/de/zp/drdezp0cpykyqvu3mgkcglxnp2a.png#x64_dbg-3-cpu-hardware_breakpoint_0x0497A6C0.png"/>
	<p><br />
		Здесь привлекает внимание переход на “<code>tk86.Tk_SetWindowBackground</code>”, вызов “<code>tk86.Tk_FreeBitmap</code>” и уже знакомый адрес стека (<em>0x0028ECB4</em>).
	</p><p><br />
		Еще одна подсказка:
	</p>
	<br /><!-- nohighlight --><source lang="bash">= EAX{00 A0 E0 A0} =

EAX{00 A0 E0 A0} &lt;= ds:[eax{<strong>?    ??    ?</strong>}] -&gt; Hardware Breakpoint (read)

ss:[esp{0028ECAC}+8  = <em>0028ECB4</em>]{0497DDC8} =&gt; EAX
ds:[eax{0497DDC8}+18 = 0497DDE0]{? <strong>0497A6C0</strong> ?} =&gt; EAX

EAX{00 A0 E0 A0} &lt;= ds:[eax{? <strong>0497A6C0</strong> ?}] -&gt; Hardware Breakpoint (read)
EAX{00 A0 E0 A0} =&gt; ss:[esp{0028ECAC}+8 = <em>0028ECB4</em>] -&gt; Stack</source>
	<p><br />
		А теперь попробуем заменить “<code><nobr>A0 <strong>E0</strong> A0</nobr></code>” на “<code><nobr>A0 <strong>00</strong> A0</nobr></code>”, и пошагать немного вперед (“Step Over”, <kbd>F8</kbd>)… и мы пришли к уже знакомому коду (с дополнительной информацией):
	</p>
	<br /><anchor>fig_x64_dbg-4-cpu-step_over-from_0x0497A6C0-to_0x0497801C</anchor><img alt="cpu – step over – from 0x0497A6C0 to 0x0497801C" align="center" height="624" src="https://habrastorage.org/webt/70/xh/nk/70xhnkcrkvkitqfwo1kisuzhymi.png#x64_dbg-4-cpu-step_over-from_0x0497A6C0-to_0x0497801C.png"/>
	<p><br />
		Будет еще несколько остановок, а в конце:
	</p>
	<br /><ul>
		<li>значение по адресу 0x<strong>0497801C</strong> [0] изменится на “<code><nobr>A0 <strong>00</strong> A0</nobr></code>”;</li>
		<li><strong>цвет фона в Tkenv изменится</strong>!</li>
	</ul>
	<p><br />
		Мы уже нашли то место, где задается цвет фона, но для его изменения нужно делать “Re‑layout”. У нас осталось еще несколько адресов, и я бы хотел найти тот адрес, в котором значение цвета кешируется, и используется при перерисовке содержимого окна.
	</p><p><br />
		К адресам 0x<strong>0497DE60</strong> [2] и 0x<strong>0497DED0</strong> [3] обращений не было. Вдобавок, по этим адресам до сих пор хранится значение “<code><nobr>A0 <strong>E0</strong> A0</nobr></code>”, а должно – “<code><nobr>A0 <strong>00</strong> A0</nobr></code>”, т.к. цвет фона изменился.
	</p><p><br />
		А вот по адресам 0x<strong>0497DF60</strong> [4] и 0x<strong>0497DFD0</strong> [5] сейчас хранится “<code><nobr>98 00 00</nobr></code>” и “<code><nobr>37 00 00</nobr></code>” соответственно. <strong>Предположение</strong>: старый “кеш” после “Re‑layout” стирается, и создается новый “кеш” по новым адресам. Похоже, именно в этих двух адресах ранее (до “Re‑layout”) был “закеширован” цвет. Теперь они располагаются по новому адресу.
	</p><p><br />
		Чтобы найти новый адрес, снова запустим поиск паттерна “<code><nobr>A0 E0 A0</nobr></code>” в памяти:
	</p>
	<br /><anchor>fig_x64_dbg-5-references-pattern_a0_e0_a0_2</anchor><img alt="references – pattern a0e0a0" align="center" height="569" src="https://habrastorage.org/webt/gf/c-/0r/gfc-0rv3_g6ojnq1xapjvqmbodi.png#x64_dbg-5-references-pattern_a0_e0_a0_2.png"/>
	<p><br />
		Что‑то не то – слишком мало адресов в диапазоне (0x048A0000 + 0x00400000), к тому же здесь отсутствуют адреса 0x<strong>0497A6C0</strong> [1] и 0x<strong>0497801C</strong> [0]!
	</p><p><br />
		Ах да, я забыл, что мы поменяли “<code><nobr>A0 <strong>E0</strong> A0</nobr></code>” на “<code><nobr>A0 <strong>00</strong> A0</nobr></code>”, придется вернуть обратно (или искать “<code><nobr>A0 <strong>00</strong> A0</nobr></code>”). Однако, теперь мы будем уверены, что найденные сейчас адреса не имеют отношения к цвету фона.
	</p><p><br />
		Вернем старое значение по адресу 0x<strong>0497A6C0</strong> [1] сделаем “Re‑layout”, и повторим поиск (после поиска разморозим (<nobr>Debug &gt;</nobr> Run) Tkenv):
	</p>
	<br /><anchor>fig_x64_dbg-6-references-pattern_a0_e0_a0_3</anchor><img alt="references – pattern a0e0a0" align="center" height="569" src="https://habrastorage.org/webt/o9/yh/_z/o9yh_z2zzxcjsx4eh9rghwpankm.png#x64_dbg-6-references-pattern_a0_e0_a0_3.png"/>
	<p><br />
		Появились 2 новых адреса из другого диапазона памяти. Найдем его в “Memory Map”:
	</p>
	<br /><!-- nohighlight --><source lang="bash">Address  | Size     | Page Info                 | Alloc Type | Current Prot | Alloc Prot
========================================================================================
06460000 | 0026E000 |                           | PRV        | -RW--        |-RW--</source>
	<p><br />
		Похоже все нормально. Проверим новые адреса.
	</p><p><br />
		К адресу 0x<strong>065B5AC8</strong> [4′] обращаются при:
	</p>
	<br /><ul>
		<li>увеличении/уменьшении (лупа +/-) области сети/модуля;</li>
		<li>открытии модуля, и возвращаемся назад к сети;</li>
		<li>открытии дочернего окна инспектора сети (<nobr>Inspect &gt;</nobr> Network).</li>
	</ul>
	<br /><anchor>fig_x64_dbg-7-cpu-hardware_breakpoint_0x065B5AC8</anchor><img alt="cpu – hardware breakpoint 0x065B5AC8" align="center" height="679" src="https://habrastorage.org/webt/jh/fj/ms/jhfjmsvp0wms83ipcy80aungeha.png#x64_dbg-7-cpu-hardware_breakpoint_0x065B5AC8.png"/>
	<p><br />
		Но я пока не буду менять значение, и переду к следующему адресу 0x<strong>065E4E18</strong> [5′]:
	</p>
	<br /><anchor>fig_x64_dbg-8-cpu-hardware_breakpoint_0x065E4E18</anchor><img alt="cpu – hardware breakpoint 0x065E4E18" align="center" height="721" src="https://habrastorage.org/webt/ts/up/-g/tsup-gkzrwvvefxgu5chcpcrbic.png#x64_dbg-8-cpu-hardware_breakpoint_0x065E4E18.png"/>
	<p><br />
		Какой интересный фрагмент: ESI:“<code>gdi32.CreateSolidBrush</code>”; вызов “<code>tk86.TkWinGetDrawableDC</code>”, <nobr>EAX′:</nobr>“<code>user32.FillRect</code>”, и в стеке “<code>tk86.XFillRectangles</code>”. Причем, если изменить “<code><nobr>A0 <strong>E0</strong> A0</nobr></code>” на “<code><nobr>A0 <strong>00</strong> A0</nobr></code>”, и свернуть/развернуть окно, то <strong>цвет фона изменится</strong>! Однако, по адресу 0x<strong>065B5AC8</strong> [4′] осталось прежнее значение, и даже если вызвать код, использующий его [4′], то в Tkenv цвет фона останется “<code><nobr>A0 <strong>00</strong> A0</nobr></code>”, а в 0x<strong>065B5AC8</strong> [4′] останется “<code><nobr>A0 <strong>E0</strong> A0</nobr></code>”.
	</p><p><br />
		<font color="#54524F"><b>Note</b>:</font> Если вы не знакомы с механизмом работы Software Breakpoints, то попробуйте прямо сейчас поставить Breakpoint (это можно сделать сразу во вкладке с результатами поиска – “References” → контекстное меню → Toggle Breakpoint; клавиша <kbd>F2</kbd>) на адрес, хранящий цвет фона для перерисовки окна (у меня, в данный момент, это адрес 0x<strong>065E4E18</strong> [5′], а у вас будет другой адрес). Теперь сверните/разверните окно Tkenv… как вам взгляд на сеть через “розовые очки” ：）? А теперь попробуйте заменить “<code><nobr><strong>A0</strong> 00 <strong>A0</strong></nobr></code>” на “<code><nobr><strong>00</strong> 00 <strong>00</strong></nobr></code>”, и посмотрите на итоговый цвет (должен быть черным, но…). Теперь вы поняли, почему в IDE метка Breakpoint имеет именно этот цвет ；）(возможно, эта фраза была шуткой, а возможно и нет).
	</p>
<hr /></spoiler>
<p><br />
	Я остановился на цвете “<code>E6E6E6</code>”.
</p><p><br />
	Теперь можно зафиксировать изменения, и, чтобы изменения сохранялись при перекомпиляции Tkenv, цвет придется заменять в исходниках. В исходниках цвет может быть задан множеством способов (3 одно‑байтных числа, одно 4‑х байтное число, строка с hex значением или названием цвета, …), я начал поиск со строки “<code>a0e0a0</code>” (без учета регистра) в директории с исходниками Tkenv (“omnetpp-5.0/src/tkenv/”). И мне повезло:
</p>
<br /><ul>
	<li>“canvas<strong>inspector</strong>.tcl” строка 79: `<code>tkp::canvas $c -background &quot;#<strong>a0e0a0</strong>&quot; -relief raised -closeenough 2</code>`;</li>
	<li>“module<strong>inspector</strong>.tcl” строка 96: `<code>tkp::canvas $c -background &quot;#<strong>a0e0a0</strong>&quot; -relief raised -closeenough 2</code>`;</li>
	<li>“gate<strong>inspector</strong>.tcl” строка 50: `<code>canvas $c -background #<strong>a0e0a0</strong> -relief raised</code>`.</li>
</ul>
<p><br />
	Так вот он какой <a href="https://habrahabr.ru/post/308962">Tcl</a>/<a href="https://habrahabr.ru/post/332924">Tk</a>… Тот факт, что в названиях всех файлов присутствует “inspector” – обнадеживает, поэтому просто поменяем цвет, и <a href="#ustanovka-omnet-i-inet">пересоберем <nobr>OMNeT++</nobr></a>:
</p>
<br /><source lang="bash">make MODE=release –j17</source>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> <a href="#use-parallel-jobs">вспомните про “<code>-j</code>” и “<code>17</code>”</a>.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> пересобирать проект “LLTR” (через Eclipse) нет необходимости, т.к. сам Tkenv (и внесенные нами изменения) находится в библиотеке “omnetpp-5.0/bin/libopptkenv.dll”.
</p><p><br />
	Цвет должен был измениться:
</p>
<br /><anchor>fig_tkenv-bg_color_e6e6e6-bg_images-un_7z_me</anchor><img alt="tkenv: bg color e6e6e6 – bg images (un[7z]me)" align="center" height="484" src="https://habrastorage.org/webt/59/ny/un/59nyunuka-yw3qbsbmnovte3w3u.png#tkenv-bg_color_e6e6e6-bg_images-un_7z_me.png"/>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> Подложку (с тенью) для фона сети, используемую в этой статье (как на скриншоте выше), можно достать разархивировав (7zip) эту картинку. В архиве 3 фона под несколько используемых размеров холста, и файл с готовыми display string для “.ned” файлов сетей. Фоны можно распаковать прямо в “omnetpp-5.0/images/background/”, либо <a href="https://omnetpp.org/doc/omnetpp/manual/#sec:graphics:image-path">расположить их в любом другом удобном месте</a>.
</p>
<br /><h3><anchor>zamena-fona-zelenogo-na-kartinku-uzor-v-qtenv</anchor><a href="#zamena-fona-zelenogo-na-kartinku-uzor-v-qtenv" title="Ссылка на раздел"><font color="gray">#</font></a> Замена фона (зеленого) на картинку (узор) в Qtenv</h3>
<p><br />
	Поступаем точно также как и с Tkenv, с той лишь разницей, что теперь цвет будем менять на изображение, и не будем использовать отладчик для интерактивного просмотра результата замены.
</p><p><br />
	“На глаз” зеленые цвета фона в Tkenv и Qtenv совпадают, но совпадают ли их числовые значения (RGB)? Тест “пипеткой” показал, что совпадают: <font color="#A00000">A0</font><font color="#00E000">E0</font><font color="#0000A0">A0</font> (hex); <font color="#A00000">R</font>:160, <font color="#00E000">G</font>:224, <font color="#0000A0">B</font>:160.
</p><p><br />
	Поиск “оптимального узора для фона” отложим на потом, и сразу перейдем к поиску цвета в исходниках (директория “omnetpp-5.0/src/qtenv/”):
</p>
<br /><ul>
	<li>“<strong>canvasviewer</strong>.cc” строка 46: `<code>setBackgroundBrush(QColor(&quot;#a0e0a0&quot;))</code>`;</li>
	<li>“module<strong>canvasviewer</strong>.cc” строка 92: `<code>setBackgroundBrush(QColor(&quot;#a0e0a0&quot;))</code>`;</li>
	<li>“module<strong>canvasviewer</strong>.cc” строка 371: `<code>layoutScene-&gt;setBackgroundBrush(QColor(&quot;#a0e0a0&quot;))</code>`.</li>
</ul>
<p><br />
	Здесь можно сразу же заменить зеленый цвет на другой цвет, но нам нужно поменять цвет на картинку. В дополнение к этому представим, что мы видим Qt впервые в жизни, и не знаем, как он устроен. Что же делать?
</p><p><br />
	В Qtenv уже используются иконки (изображения) для кнопок, а в директории с исходниками есть поддиректория “icons/” где и располагаются (в своих поддиректориях) иконки. Теперь можно поискать места/варианты использования в коде нескольких из этих иконок по их имени, либо можно осмотреть файлы в директории с исходниками и заметить:
</p>
<br /><ul>
	<li>“<strong>icons.qrc</strong>” – перечислены пути до изображений в “icons/”;</li>
	<li>“*.ui”, и в частности “mainwindow.ui” – описание GUI окон/диалогов/виджетов, в них также упоминаются пути до иконок, и файл “<strong>icons.qrc</strong>”;</li>
	<li>“<strong>Image</strong>cache.*” (“.h” и “.cc”) – название файла говорит само за себя, как и строчка в одном из них: “<code>QImage *image = new QImage(fileName);</code>”.</li>
</ul>
<p><br />
	Не буду долго тянуть – для продолжения нужно познакомится с Qt чуть поближе:
</p>
<br /><ol>
	<li>описание “<a href="https://doc.qt.io/qt-5/qgraphicsview.html#backgroundBrush-prop"><code>setBackgroundBrush()</code></a>”, и <a href="https://doc.qt.io/qt-5/qgraphicsview.html#cacheMode-prop">пример использование картинки с заданием режима кеширования чуть ниже</a>;</li>
	<li><a href="http://forum.sources.ru/index.php?showtopic=349342#post_3063091">что лучше: переопределить “<code>drawBackground</code>” или использовать “<code>setBackgroundBrush()</code>”</a>;</li>
	<li><a href="http://doc.crossplatform.ru/qt/4.4.3/qgraphicsview.html#details">попытка перевода Qt v4.4.3 документации: описание класса QGraphicsView</a>;</li>
	<li><a href="https://doc.qt.io/qt-5/resources.html">подробнее про “<strong>icons.qrc</strong>”</a>, и про использование изображений (ресурсов) в приложении;</li>
	<li><a href="https://doc.qt.io/qt-5/qbrush.html#details">QBrush</a>;</li>
	<li><a href="https://doc.qt.io/qt-5/qimage.html#details">QImage</a> и <a href="https://doc.qt.io/qt-5/qpixmap.html#details">QPixmap</a>;</li>
	<li>производительность: <a href="http://www.prog.org.ru/topic_19289_0.html">QPixmap vs. QImage</a>;</li>
	<li><a href="https://stackoverflow.com/a/17889388">привыкаем писать без “new”: “<code>setBackgroundBrush(new ...)</code>”</a>;</li>
	<li><a href="https://stackoverflow.com/a/8457129">привыкаем писать без “new”: “<code>setBackgroundBrush(new ...)</code>”</a>;</li>
	<li><a href="https://doc.qt.io/qt-5/implicit-sharing.html">привыкаем писать без “new”: “<code>setBackgroundBrush(new ...)</code>”</a>;</li>
</ol>
<p><br />
	<strong>В итоге</strong>: на фон влияет только строка 92 в “module<strong>canvasviewer</strong>.cc”. Строка 371 в этом же файле должна задавать фон при “Re‑layout” (если в настройках Qtenv включена анимация процесса “Re‑layout”, и есть незакрепленные модули в сети), но я не заметил эффекта от изменения цвета в этой строке (даже если ее закомментировать, то процесс “Re‑layout” выглядел, так же как и прежде). Влияние строки 46 в “<strong>canvasviewer</strong>.cc” также не удалось установить.
</p><p><br />
	Патч будет выглядеть примерно так:
</p><p><br />
	В конце “<strong>icons.qrc</strong>” (перед закрывающим “<code>&lt;/RCC&gt;</code>”) добавить <strong>один</strong> путь до <strong>одной</strong> картинки с фоном:
</p>
<br /><source lang="xml">    &lt;qresource prefix=&quot;/backgrounds&quot;&gt;
        &lt;file alias=&quot;bg.png&quot;&gt;icons/backgrounds/greennoise_grid.png&lt;/file&gt;
    &lt;/qresource&gt;</source>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> несколько изображений (узоров, паттернов) для фона, я прикрепил ниже.
</p><p><br />
	В “module<strong>canvasviewer</strong>.cc” строка 92:
</p>
<br /><source lang="cpp">   //setBackgroundBrush(QColor(&quot;#a0e0a0&quot;));
   // https://doc.qt.io/qt-5/qgraphicsview.html#backgroundBrush-prop
   // http://forum.sources.ru/index.php?showtopic=349342#post_3063091
   // http://doc.crossplatform.ru/qt/4.4.3/qgraphicsview.html
   // icons.qrc https://doc.qt.io/qt-5/resources.html
   // https://doc.qt.io/qt-5/qbrush.html#details
   // https://doc.qt.io/qt-5/qimage.html#details
   // https://doc.qt.io/qt-5/qpixmap.html#details
   // http://www.prog.org.ru/topic_19289_0.html
   // new vs no new https://stackoverflow.com/a/17889388
   // new vs no new https://stackoverflow.com/a/8457129
   // new vs no new https://doc.qt.io/qt-5/implicit-sharing.html
   setBackgroundBrush(QPixmap(&quot;:/backgrounds/bg.png&quot;));</source>
<p><br />
	В остальных местах заменять цвет изображением – бесполезно, однако можно заменить на “цвет основы узора”.
</p><p><br />
	В “module<strong>canvasviewer</strong>.cc” строка 371 (383):
</p>
<br /><source lang="cpp">        //layoutScene-&gt;setBackgroundBrush(QColor(&quot;#a0e0a0&quot;));
        layoutScene-&gt;setBackgroundBrush(QColor(&quot;#2db612&quot;));</source>
<p><br />
	В “<strong>canvasviewer</strong>.cc” строка 46:
</p>
<br /><source lang="cpp">    //setBackgroundBrush(QColor(&quot;#a0e0a0&quot;));
    setBackgroundBrush(QColor(&quot;#2db612&quot;));</source>
<p><br />
	Осталось пересобрать <nobr>OMNeT++</nobr> (так же, как и пересобрали при патчинге Tkenv), и замерить падение скорости (залить одним цветом – легче, чем замостить картинку).
</p>
<br /><h4><anchor>uvelichilas-li-nagruzki-na-cpu-posle-patcha</anchor><a href="#uvelichilas-li-nagruzki-na-cpu-posle-patcha" title="Ссылка на раздел"><font color="gray">#</font></a> Увеличилась ли нагрузки на CPU после патча?</h4>
<p><br />
	Я замерял “CPU time” (user + sys time) для процесса симулятора, привязанного к одному наиболее свободному ядру CPU. В симуляторе запускалась модель с конфигурацией “(General)” (сеть “<code>Network</code>” – “N2_2”) в режиме “until-run” 999 первых событий (примерно в этот момент, чуть ранее, начинается нулевая итерация). После каждого испытания симулятор перезапускался. Я хотел сравнить с оригинальным Qtenv, сравнить скорость при использовании QPixmap и QImage (как с использованием <a href="https://doc.qt.io/qt-5/qgraphicsview.html#cacheMode-prop">кеширования</a>, так и без). В итоге получилось 5 конфигураций:
</p>
<br /><ul>
	<li>оригинальный Qtenv;</li>
	<li>QPixmap без кеширования;</li>
	<li>QImage без кеширования;</li>
	<li>QImage кеширование включено;</li>
	<li>QPixmap кеширование включено (весьма сомнительное сочетание, ввиду того как работает кеширование, но все же я проверил).</li>
</ul>
<p><br />
	Также я проверял нагрузку на CPU при горизонтальной прокрутке содержимого инспектора сети.
</p><p><br />
	В результатах будет указано (в секундах):
</p>
<br /><ul>
	<li>“<code>start</code>” – “CPU time” перед нажатием кнопки для запуска симуляции; </li>
	<li>“<code>end</code>” – “CPU time” после остановки симуляции на 999 событии;</li>
	<li>“<code>diff</code>” – разность между “<code>end</code>” и “<code>start</code>”.</li>
</ul>
<p><br />
	Результаты (без комментариев):
</p>
<br /><!-- nohighlight --><source lang="bash">Affinity: core 1
Until event #1000

Original Qtenv:
start -  1.419
end   - 50.403
diff  - 48.984


[cache off] QPixmap:
start -  1.762
end   - 50.528
diff  - 48.766

[cache off] QImage:
start -  1.638
end   - 52.073
diff  - 50.435


[cache on] QImage:
start -  1.700
end   - 55.629
diff  - 53.929

[cache on] QPixmap:
start -  1.528
end   - 52.509
diff  - 50.981</source>
<p><br />
	При горизонтальной прокрутке, наибольшая нагрузка на CPU была в тесте “<code>[cache off] QImage</code>”, в остальных же тестах нагрузка была примерно одинаковая.
</p><p><br />
	<font color="#54524F"><b>Note</b>:</font> рассматривайте эти тесты только как призыв к действию – ваши результаты (относительные) могут отличатся от моих.
</p>
<br /><h4><anchor>nabor-uzorov-dlya-fona</anchor><a href="#nabor-uzorov-dlya-fona" title="Ссылка на раздел"><font color="gray">#</font></a> Набор узоров для фона</h4>
<p><br />
	Обещанные выше фоны (узоры, паттерны):
</p>
<br /><anchor>fig_qtenv-background_patterns-un_7z_me</anchor><img alt="qtenv: background patterns (un[7z]me)" align="center" height="1160" src="https://habrastorage.org/webt/cw/aa/e0/cwaae0mpyejzdehbuwpiningnjg.png#qtenv-background_patterns-un_7z_me.png"/>
<p><br />
	<font color="#54524F"><b>Note</b>:</font> справа на картинке указаны числовые значения “цвета основы узора”.
</p><p><br />
	После разархивирования (7zip) можно сразу же открыть “demo/page.htm” и посмотреть, как будет выглядеть конкретный узор в GUI Qtenv.
</p><p><br />
	Для смены узора я просто использую “инструментарий разработчика” (<kbd>Ctrl+Shift+I</kbd>). Путь к нужному узору указывается в стиле (“<code>style</code>”; второй фон в свойстве “<code>background</code>”) единственного “<code>div</code>”. Этим же способом можно посмотреть, как будет выглядеть любая картинка в качестве фона. Например, мне понравились фракталы “<a href="http://www.fractalsciencekit.com/tutorial/examples/juliapat1.htm">Julia Pattern Map</a>”, в частности “<a href="http://www.fractalsciencekit.com/fractals/large/Fractal-Julia-Pattern-Map-11.jpg">Cognitive Architecture (11)</a>” и “<a href="http://www.fractalsciencekit.com/fractals/large/Fractal-Julia-Pattern-Map-24.jpg">Patchwork Design (24)</a>” (он напоминает мне <a href="https://ru.wikipedia.org/wiki/Куб_2:_Гиперкуб?stable=1">Куб1,2</a>):
</p>
<br /><anchor>fig_fractal-julia_pattern_map-cognitive_architecture-and-patchwork_design</anchor><img alt="Fractal: Julia pattern map: Cognitive Architecture and Cube 2 [Hypercube]" align="center" height="200" src="https://habrastorage.org/webt/fy/v4/dm/fyv4dmdinxbb8z-flkb0a34qrc4.jpeg#fractal-julia_pattern_map-cognitive_architecture-and-patchwork_design.jpg"/>
<p><br />
	Я брал ¼ этих изображений, и смотрел, как они будут выглядеть в GUI. Результат – слишком привлекали внимание на себя, т.е. отвлекали.
</p>
<br /><spoiler title="Моя субъективная оценка некоторых из узоров, включенных в архив"><hr />
	<ul>
		<li><strong>bluenoise_grid</strong> – насыщенный цвет отвлекает; синий цвет фона + преобладающий синий цвет иконок хостов + светло‑серый GUI ⇒ не смог долго смотреть.</li>
		<li><strong>greennoise_grid</strong> – насыщенный цвет отвлекает, и если, после долгого нахождения в симуляторе, переключится на IDE, то его цветовая схема будет казаться менее насыщенной.</li>
		<li><strong>blueprint/blueprint</strong> – синий цвет фона + преобладающий синий цвет иконок хостов + светло‑серый GUI ⇒ не смог долго смотреть.</li>
		<li><strong>blueprint/print-26</strong> – оптимальный вариант для случая, если дисплей днем бликует, однако он чуть больше привлекает к себе внимание, чем print-36.</li>
		<li><strong>blueprint/print-36</strong> – высококонтрастная версия print-26:
			<ul>
				<li>при переводе взгляда между областями (лог → карта сети; инспектор объектов → карта сети), взгляд притягивает центр карты сети (на фон даже смотреть не хочется), т.е. можно быстро переключаться между областями;</li>
				<li>элементы на карте сети кажутся более контрастными;</li>
				<li>поиск конкретного элемента на карте сети затруднен, т.к. взгляд постоянно стремится перейти к центру карты.</li>
			</ul>
		</li>
		<li><strong>blueprint/*print45*</strong> – почему‑то все они напоминают узор на одежде…</li>
	</ul>
	<p><br />
		В итоге, я выбрал “<strong>print-26.png</strong>”.
	</p>
<hr /></spoiler>

<br /><h2><anchor>to-be-continued</anchor><a href="#to-be-continued" title="Ссылка на раздел"><font color="gray">#</font></a> В следующих частях / To be continued…</h2><hr />
<ul>
	<li>2. <a href="https://habr.com/post/421243/">Алгоритм определения топологии сети по собранной статистике</a></li>
	<li>3. <nobr>OMNeT++</nobr> продолжение</li>
	<li>4. Математика</li>
	<li>5. <nobr>OMNeT++</nobr> продолжение 2</li>
	<li>6. Реализация</li>
	<li>7. Эксперимент <font color="gray">(название‑спойлер: “<a title="фильм" href="#hack-is here"><font color="gray">в конце Джон умрет</font></a>”)</font></li>
</ul>
<p><br />
	Эта часть: в <a href="https://zirokyl.github.io/LLTR-Simulation-Model/a1/">GitHub Pages</a>;<br />
	<anchor>doi</anchor><a href="https://doi.org/10.5281/zenodo.1407029" title="Цифровой идентификатор статьи"><img alt="DOI: 10.5281/zenodo.1407029" width="186" height="20" src="https://zenodo.org/badge/DOI/10.5281/zenodo.1407029.svg"/></a>
</p>

<br /><h2><anchor>poll</anchor><a href="#poll" title="Ссылка на раздел"><font color="gray">#</font></a> Обратная связь</h2><hr />
<p>
	Небольшой опрос. Первый вопрос поможет мне лучше определить время для публикации следующей части. Второй – улучшить статью. Остальные вопросы – чистое любопытство.
</p>
</body>
</html>
