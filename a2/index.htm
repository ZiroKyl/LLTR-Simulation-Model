<!DOCTYPE html>
<html lang="ru">
<head>
	<meta charset="UTF-8">
	<title>LLTR Часть 2: Алгоритм определения топологии сети по собранной статистике</title>

	<link rel="stylesheet" href="../css/main.css">

	<script src="js/main.js" defer></script>
	<script src="../js/hljs.js" defer></script>

	<meta name="viewport" content="width=device-width, initial-scale=1.0, minimum-scale=1.0">
	<!-- маленький экран смартфона не очень подходит для чтения подобного текста -->

	<style>img[src$="Git-Icon_2x.png"] { vertical-align: top; }</style>

	<link rel="canonical" href="https://habr.com/post/421243/">
</head>
<body class="NZT">
<h1>LLTR Часть 2: Алгоритм определения топологии сети по собранной статистике</h1>
<img id="LLTR_a2_habr-pic" alt="Link Layer Topology Reveal logo" align="center" height="164" src="https://hsto.org/webt/5i/-e/hf/5i-ehfvfk0-jh7flz-1ti9yyyke.gif#splash.gif"/>
<details>
	<summary>В предыдущих частях…</summary>
	<p>
		0. <a href="https://habr.com/post/414799/">Автоматическое определение топологии сети и неуправляемые коммутаторы. Миссия невыполнима?</a> (+ <a href="https://habr.com/post/414799/#user-css" title="Набор стилей, упрощающих чтение больших статей"><em>classic Habrahabr <strong>UserCSS</strong></em></a>)
	</p>
	<p>
		1. <a href="https://habr.com/post/420327/">Первые шаги в <nobr>OMNeT++</nobr> и INET [tutorial]</a>
	</p>
</details>
<p>
	<b>Q:</b> Что у нас есть?<br />
	<b>A:</b> Статистика, собранная с хостов.
</p>
<p>
	<b>Q:</b> Что мы хотим получить?<br />
	<b>A:</b> Топологию сети! Точнее, нужно <a href="https://habr.com/post/414799/#lltr-basic">построить правильную цепочку пиров (хостов)</a> для <a href="http://9b.asoiu.com/2016/3704-ringsync-синхронизируем-на-полной-скорости-с/">RingSync</a>.
</p>
<p>
	Нам предстоит придумать алгоритм, который вначале превратит статистику в топологию сети, а затем – в цепочку пиров. Пока алгоритм выглядит так:
</p>
<pre><code class="nohighlight">статистика –-[*магия*]--&gt; топология сети --[*магия*]--&gt; цепочка пиров</code></pre>
<!--more-->
<img id="fig_arthur_c_clarke-quote" alt="Любая достаточно развитая технология неотличима от магии. — Arthur C. Clarke" align="center" height="291" src="https://hsto.org/webt/be/x5/k9/bex5k9ckqfzus8g85fzf-td0hzi.png#arthur_c_clarke-quote.png"/>
<p>
	<font color="#54524F"><b>Note</b>:</font> далее вместо “<code>–-[*магия*]--&gt;</code>” я буду использовать “<code>–-[???]--&gt;</code>”.
</p>
<p>
	Собранная статистика показывает нам, на каких хостах упала скорость получения broadcast трафика. Например, посмотрим на результат нулевой итерации в сети “N2_2” (“<code>Network</code>” из предыдущей статьи “LLTR Часть 1”):
</p>
<pre><code class="cpp">{300,164,164},</code></pre>
<p>
	Здесь четко видны 2 состояния хоста:
</p>
<ul>
	<li>нормальная скорость (значение “<code>300</code>”) – <strong>отсутствие реакции</strong>;</li>
	<li>скорость упала (значение “<code>164</code>”) – <strong>есть реакция</strong>.</li>
</ul>
<p>
	К чему я клоню? К бинаризации! Если мы закодируем <strong>отсутствие реакции</strong> как <strong>0</strong>, а <strong>присутствие реакции</strong> как <strong>1</strong>, то сможем поместить все реакции хостов, отдельно взятой итерации, в одну переменную (<nobr>32&thinsp;–&thinsp;512 bit</nobr> [<abbr title="Advanced Vector Extensions 512‑bit">AVX‑512</abbr>]). Помимо экономии памяти (и места, занимаемого в кэшах), это увеличит скорость обработки – за одну инструкцию будут обрабатываться сразу все реакции хостов конкретной итерации (<abbr title="Single instruction, multiple data">SIMD</abbr>).
</p>
<p>
	<font color="#54524F"><b>Note</b>:</font> т.к. использовать LLTR Basic для большого числа хостов весьма накладно (<a href="https://habr.com/post/414799/#lltr-advanced" title="Автоматическое определение топологии сети и неуправляемые коммутаторы. Миссия невыполнима?">см. начало раздела “LLTR Часть 0::LLTR Advanced”</a>), то все поместится в <nobr>64&thinsp;bit</nobr> регистры x86‑64.
</p>
<p>
	<font color="#54524F"><b>Note</b>:</font> В текст ссылки на раздел, расположенный в другой статье (другая часть), я буду добавлять номер части в формате: “<strong>LLTR Часть #</strong>::<strong>‹название раздела›</strong>”. А в “<strong><code><a href="http://htmlbook.ru/html/attr/title">title</a></code></strong>” ссылки буду записывать название части, например, для “LLTR Часть 0::” будет всплывать “Автоматическое определение топологии сети и неуправляемые коммутаторы. Миссия невыполнима?”.
</p>
<p>
	Возьмем тот же пример нулевой итерации, и посмотрим, как он будет выглядеть после бинаризации:
</p>
<pre><code class="nohighlight">{300,164,164} --[бинаризация]--&gt; 011</code></pre>
<p>
	Весьма компактно, однако я бы хотел, чтобы “<code><strong>1</strong></code>” (<strong>присутствие реакции</strong>) сразу бросались в глаза при просмотре списка из всех итераций. Сейчас “<code><strong>1</strong></code>” не сильно выделяется на фоне “<code><strong>0</strong></code>” (фейковые данные, для <strong>визуального примера</strong>):
</p>
<pre><code class="nohighlight">0101011010110
1100010110010
0101101010111
0100010110100</code></pre>
<p>
	Чтобы выделить “<code><strong>1</strong></code>”, я введу обозначения:
</p>
<ul>
	<li>“<code><strong>1</strong></code>” означает 1 – <strong>есть реакция</strong>;</li>
	<li>“<code><strong>.</strong></code>” означает 0 – <strong>отсутствие реакции</strong>.</li>
</ul>
<p>
	Посмотрим опять на “фейковые данные”:
</p>
<pre><code class="nohighlight">.1.1.11.1.11.
11...1.11..1.
.1.11.1.1.111
.1...1.11.1..</code></pre>
<p>
	Так значительно лучше (<abbr title="In My Honest Opinion">IMHO</abbr>).
</p>
<p>
	Алгоритм, на данный момент, выглядит так:
</p>
<pre><code class="nohighlight">статистика –-[бинаризация]--&gt; реакции хостов --[???]--&gt; топология сети --[???]--&gt; цепочка пиров</code></pre>
<p>
	Оставим детали бинаризации для конца статьи, и сконцентрируемся на остальной части алгоритма.
</p>
<p>
	Создавать алгоритм, проще всего, отталкиваясь от конкретных исходных/входных данных (частные случаи, граничные условия; тесты – в терминах <a href="https://habrahabr.ru/post/206828/"><abbr title="Test‑driven development">TDD</abbr></a>). В нашем случае исходные данные зависят от топологии сети, поэтому нужно придумать такую сеть, которая была бы одновременно небольшой, и в то же время содержала разные схемы соединения свитчей (<a href="https://habr.com/post/414799/#topologiya-zvezda-iz-svitchey" title="LLTR Часть 0::Топология: “звезда из свитчей”">звезда</a>, <a href="https://habr.com/post/414799/#topologiya-posledovatelnoe-soedinenie-svitchey" title="LLTR Часть 0::Топология: “последовательное соединение свитчей”">последовательное соединение</a>). Возможно, в нее удастся включить нечто особенное… В общем, воображение нарисовало такую сеть (обозначения элементов аналогичны обозначениям, используемым в конце раздела “<a href="https://habr.com/post/414799/#topologiya-posledovatelnoe-soedinenie-svitchey" title="Автоматическое определение топологии сети и неуправляемые коммутаторы. Миссия невыполнима?">LLTR Часть 0::Топология: “последовательное соединение свитчей”</a>”):
</p>
<img id="fig_LLTR_Hybrid_Net" alt="Диаграмма: LLTR гибридная сеть" align="center" height="116" src="https://hsto.org/webt/tw/ow/dk/twowdkqrjmlca7haw3oe_vshbfw.png#LLTR_Hybrid_Net.svg.png"/>
<p>
	<font color="#54524F"><b>Note</b>:</font> смотря на эту сеть, вспоминается вопрос “а можно ли в данной топологии провести полноценное сканирование, если к одному из свитчей …” (ближе к концу раздела “<a href="https://habr.com/post/414799/#fig_LLTR_Advanced_serial_parallel_0" title="Автоматическое определение топологии сети и неуправляемые коммутаторы. Миссия невыполнима?">LLTR Часть 0::Топология: “последовательное соединение свитчей”</a>”), и замечаешь, что к одному из свитчей напрямую не подключен ни один хост. Причем в этом нет никаких проблем, т.к. к этому свитчу подключены еще 3 свитча (я считал только свитчи, подключенные “снизу”, без учета того, что он подключен к еще одному свитчу “сверху”), у каждого из которых есть хосты.
</p>
<p>
	Однако, в этой диаграмме присутствуют несколько лишних (отвлекающих) деталей. Я собираюсь ее подчистить, убрав:
</p>
<ul>
	<li>broadcast хост (он отсутствует во входных данных/статистике);</li>
	<li>порты, соединяющие свитчи между собой.</li>
</ul>
<img id="fig_LLTR_Hybrid_Net_clear" alt="Диаграмма: LLTR гибридная сеть (clear)" align="center" height="116" src="https://hsto.org/webt/f9/z1/su/f9z1sup7mkzb279mtfihllio5v4.png#LLTR_Hybrid_Net_clear.svg.png"/>
<p>
	Здесь сразу виден свитч “без хостов”. К тому же все свитчи я расположил таким образом, чтобы хосты в них не перекрывали друг друга по вертикали. Это будет полезно, если я в будущем захочу показать “реакции хостов” не в виде текстовой записи “<code>.....1......</code>”, а в виде диаграммы (на одной вертикали находится только один хост):
</p>
<img id="fig_LLTR_Hybrid_Net_clear_explain_reaction" alt="Диаграмма: LLTR гибридная сеть (clear), пояснение обозначения “реакций хостов”" align="center" height="154" src="https://hsto.org/webt/k2/4t/s_/k24ts_ucirxe87qfcbyki_7q7ic.png#LLTR_Hybrid_Net_clear_explain_reaction.svg.png"/>
<p>
	А теперь представьте статистику, которую мы получим, по завершению всех итераций сканирования этой сети. В сети <strong>12</strong> хостов (без учета broadcast хоста), следовательно, у нас будут данные по <strong>132</strong> итерациям. Однако не все результаты итераций нам пригодятся, например, будут бесполезны:
</p>
<ul>
	<li>единичные реакции (как в примере выше – “<code><strong>.....1......</strong></code>”; <a href="https://habr.com/post/414799/#interesno-kakie-mogut-byt-varianty-pervoy-iteracii" title="Автоматическое определение топологии сети и неуправляемые коммутаторы. Миссия невыполнима?">LLTR Часть 0::Интересно, какие могут быть варианты первой итерации? &gt; Вариант 4: “unicast in sw”</a>);</li>
	<li>дубли (повторяющиеся результаты), например, “<code><strong>.....111....</strong></code>” будет встречаться примерно <strong>15 раз</strong> ( <nobr>3×(12&thinsp;−&thinsp;3−&thinsp;(2&thinsp;+&thinsp;2))</nobr> ; “примерно”, т.к. я не создавал модель этой сети в <nobr>OMNeT++</nobr>, и не запускал симуляцию, я провел лишь мысленный эксперимент, в котором мог не учесть некоторые детали).</li>
</ul>
<p>
	После очистки, из всех <strong>132</strong> результатов итераций, останется только <strong>5</strong> (реакции хостов):
</p>
<pre><code class="nohighlight">1111111111..
11111111....
..111.......
.....111....
11..........</code></pre>
<p>
	<font color="#54524F"><b>Note</b>:</font> для наглядности я расположил итерации в порядке от большего количества “<code>1</code>” к меньшему.
</p>
<p>
	Алгоритм стал выглядеть так:
</p>
<pre><code class="nohighlight">статистика –-[бинаризация]--&gt; реакции хостов --[очистка от единичных реакций]--[очистка от дублей]--[???]--&gt; топология сети --[???]--&gt; цепочка пиров</code></pre>
<details>
	<summary>reset point</summary>
	<p>
		Я размышлял над включением всего этого в спойлер, но в итоге понял, что это важная часть повествования, которую лучше не пропускать при чтении.
	</p>
	<p>
		¬( <em>Не пропускать в мозг при чтении</em> ：）
	</p>
</details>
<p><a name="reset-point"></a>
	<b>[reset point]</b> В оставшихся <strong>5</strong> результатах итераций, внимание привлекают первые две: первая включает в себя вторую, а вторая включает оставшиеся 3 нижние. Здесь вспоминается “тень” из раздела “<a href="https://habr.com/post/414799/#topologiya-posledovatelnoe-soedinenie-svitchey" title="Автоматическое определение топологии сети и неуправляемые коммутаторы. Миссия невыполнима?">LLTR Часть 0::Топология: “последовательное соединение свитчей”</a>”. В том же разделе, по завершении каждой итерации мы формировали (или не формировали) новые кластеры на основе только что полученных данных. Сейчас нужно сделать то же самое.
</p>
<p>
	Но как мы формировали новые кластеры? По сути все (не единичные) реакции “<code>1</code>” хостов текущей итерации и были “новым кластером”, нам оставалось только найти пересечения (“∩”; не пустые “∅”) с существующими кластерами, чтобы убрать (“∖”) из большего кластера хосты, входящие в меньший кластер.
</p>
<p>
	Однако, в наших действиях присутствовало условие/ветвление (if): нужно определить какой из кластеров больше, и уже затем совершить простую операцию (A∖B) – из большего кластера (A) вычесть меньший (B). Представляя мучения CPU с длинным конвейером, вызванные необходимостью сброса конвейера при неверном предсказании ветвления (если в нем вообще “блок предсказания ветвлений” присутствует), я почти решил использовать <a href="https://habrahabr.ru/post/205848">тернарный оператор “<code>?:</code>”</a>, но в этот момент…
</p>
<blockquote cite="https://ru.wikiquote.org/wiki/Назад_в_будущее">
	<p>
		Я стоял на унитазе и вешал часы. Вдруг поскользнулся, ударился головой о раковину, а когда очнулся мне было видение, картинка в моём мозгу, видение вот этого – <s>потоковый накопитель</s> потоковый разделитель <i>(<a href="https://ru.wikiquote.org/wiki/Назад_в_будущее">Назад в будущее</a>)</i>:
	</p>
	<img id="fig_Back_to_the_Future-Flux_Divider-quote_cut" alt="Back to the Future: Flux Divider" align="center" height="425" src="https://hsto.org/webt/sj/io/qs/sjioqspeukzuxke27slvjg5uvee.jpeg#Back_to_the_Future-Flux_Divider-quote_cut.jpg"/>
</blockquote>
<pre><code class="cpp">// Flux Divider
c=a^b;
aa=a&amp;c;
bb=b&amp;c;
cc=a&amp;b;</code></pre>
<p>
	И сразу посмотрим его работу на примере перекрывающихся кластеров (точнее, одно множество (кластер) строго включено “<a href="https://en.wikipedia.org/wiki/Subset?stable=1#⊂_and_⊃_symbols">⊊</a>” в другое множество):
</p>
<pre><code class="nohighlight">.....11..... - a
..11111111.. - b

..111..111.. - c=a^b

............ - aa=a&amp;c
..111..111.. - bb=b&amp;c
.....11..... - cc=a&amp;b</code></pre>
<p>
	Непересекающиеся кластеры:
</p>
<pre><code class="nohighlight">..111....... - a
.......111.. - b

..111..111.. - c=a^b

..111....... - aa=a&amp;c
.......111.. - bb=b&amp;c
............ - cc=a&amp;b</code></pre>
<p>
	Получается, что:
</p>
<ul>
	<li>в “<code>aa</code>” попадают элементы, уникальные для “<code>a</code>”;</li>
	<li>в “<code>bb</code>” – уникальные для “<code>b</code>”;</li>
	<li>в “<code>cc</code>” – общие для “<code>a</code>” и “<code>b</code>”.</li>
</ul>
<p>
	Еще один пример с пересекающимися кластерами (“невозможный”, но наглядный пример):
</p>
<pre><code class="nohighlight">...1111..... - a
.....1111... - b

...11..11... - c=a^b

...11....... - aa=a&amp;c
.......11... - bb=b&amp;c
.....11..... - cc=a&amp;b</code></pre>
<p>
	<font color="#54524F"><b>Note</b>:</font> такой вариант отклика (реакции хостов) – отсутствует в исходных данных.
</p>
<p>
	Этим же способом можно избавляться от <strong>дублей</strong>:
</p>
<pre><code class="nohighlight">.....11..... - a
.....11..... - b

............ - c=a^b

............ - aa=a&amp;c
............ - bb=b&amp;c
.....11..... - cc=a&amp;b</code></pre>
<p>
	Но, чуть позже…
</p>
<blockquote>
	Голова перестает болеть после удара об раковину, разум проясняется, и всплывают очевидные проблемы…
</blockquote>
<p>
	На входе у нас 2 переменные (результаты итераций / реакции хостов / кластеры / множества / …), но на выходе их уже 3, причем хотя бы один из них будет пуст (“∅”). Если сразу не избавится от “∅”, то их в дальнейшем придется включить в обработку. Поэтому лучше избавится от “∅” сразу. Но как это сделать? Использовать условие/ветвление! … В общем, я вернулся к тому, с чего начал. К тому же если все сделать, как было описано выше, плюс избавится от “∅”, то в итоге мы получим из:
</p>
<pre><code class="nohighlight">1111111111..
11111111....
..111.......
.....111....
11..........</code></pre>
<p>
	Это:
</p>
<pre><code class="nohighlight">........11..
              - здесь должно было быть &quot;............&quot;, но мы его стерли ：（
..111.......
.....111....
11..........</code></pre>
<p>
	Пора задаться вопросом: “Как из этого получить топологию сети?”. Сейчас эти данные могут “сказать”, о том, к какому кластеру принадлежит конкретный хост (т.е. к какому свитчу подключен хост), но в этих данных теперь полностью отсутствует информация о топологии свитчей (т.е. о том, как соединены свитчи между собой) – мы потеряли эту информацию в ходе преобразования данных. К тому же, к какому кластеру (свитчу) принадлежат 2 крайних справа хоста? Если рассматривать каждую строку как отдельный кластер (или как указание на то, какие хосты подключены к конкретному свитчу), то окажется, что эти 2 крайних хоста никуда не подключены! Более того, в сети у нас 6 свитчей, а строк осталось 4, где же еще 2 строки? Одну мы стерли (как гласит комментарий выше), а в другой как раз и должны были быть “2 крайних справа хоста”.
</p>
<p>
	<b>[<a href="#reset-point">goto reset point</a>]</b> Дальше развивать эту идею бесполезно. Тупиковая ветвь (git branch). Придется откатиться назад к метке “reset point”, забыв все, что было после нее, но оставив эту ветвь для истории.
</p>
<p>
	Теперь же, чтобы не попасть в еще одну “мертвую ветвь”, нужно определиться с итоговой структурой (представлением) топологии сети в памяти. То есть, с тем, что мы хотим получить к моменту “топология сети”:
</p>
<pre><code class="nohighlight">статистика –-[бинаризация]--&gt; реакции хостов --[очистка от единичных реакций]--[очистка от дублей]--[???]--&gt; <strong>топология сети</strong> --[???]--&gt; цепочка пиров</code></pre>
<p>
	<strong>Во‑первых</strong>, должны присутствовать все хосты:
</p>
<pre><code class="nohighlight"><strong>..........11</strong>  &lt;--
1111111111..
11111111....
..111.......
.....111....
11..........</code></pre>
<p>
	<strong>Во‑вторых</strong>, должны быть указаны родители (родительский кластер для каждого кластера; на данный момент: <em>родитель</em> <a href="https://en.wikipedia.org/wiki/Subset?stable=1#⊂_and_⊃_symbols">⊋</a> <em>ребенок</em>; на диаграмме сети, родителей я располагал выше детей) (слева добавлены номера кластеров):
</p>
<pre><code class="nohighlight">0) ..........11  parent: ?
1) 1111111111..  parent: ?
2) 11111111....  parent: 1
3) ..111.......  parent: 2
4) .....111....  parent: 2
5) 11..........  parent: 2</code></pre>
<p>
	<font color="#54524F"><b>Note</b>:</font> если вы заметили здесь что‑то странное, сравнивая диаграмму этой сети с этими данными, то вам <em>like</em> от меня.
</p>
<details>
	<summary>Спойлер, лучше не открывать до прочтения всего списка</summary>
	<p>
		По сути (по диаграмме), родителем для кластера 1 является кластер 0, но тогда не выполняется условие “<em>родитель</em> <a href="https://en.wikipedia.org/wiki/Subset?stable=1#⊂_and_⊃_symbols">⊋</a> <em>ребенок</em>”. Возможно в “<strong>Во‑первых</strong>” мы ошиблись, и вместо “<code>..........11</code>” стоило добавить “<code>111111111111</code>”?
	</p>
</details>
<p>
	<strong>В‑третьих</strong>, должен быть один “корневой” родитель, связывающий отдельные <a href="https://ru.wikipedia.org/wiki/Дерево_(теория_графов)?stable=1">деревья</a> (т.е. <a href="https://ru.wikipedia.org/wiki/Лес_непересекающихся_множеств?stable=1">лес</a>) в одно дерево:
</p>
<pre><code class="nohighlight">-1) 111111111111
 0) ..........11  parent:-1
 1) 1111111111..  parent:-1
 2) 11111111....  parent: 1
 3) ..111.......  parent: 2
 4) .....111....  parent: 2
 5) 11..........  parent: 2</code></pre>
<p>
	<strong>В‑четвертых</strong>, неплохо было бы иметь списки детей у каждого родителя:
</p>
<pre><code class="nohighlight">-1) 111111111111             children: 0,1
 0) ..........11  parent:-1
 1) 1111111111..  parent:-1, children: 2
 2) 11111111....  parent: 1, children: 3,4,5
 3) ..111.......  parent: 2
 4) .....111....  parent: 2
 5) 11..........  parent: 2</code></pre>
<p>
	<strong>И наконец</strong>, именно теперь можно исключить детей из родителей:
</p>
<pre><code class="nohighlight">-1) ............             children: 0,1
 0) ..........11  parent:-1
 1) ........11..  parent:-1, children: 2
 2) ............  parent: 1, children: 3,4,5
 3) ..111.......  parent: 2
 4) .....111....  parent: 2
 5) 11..........  parent: 2</code></pre>
<p>
	Теперь каждая строка описывает один кластер, т.е. указывает на хосты, подключенные к одному и тому же свитчу. Однако, постойте, в нашей сети 6 свитчей, а кластеров получилось 7&nbsp;<!--пробел вставлен, т.к. "7!" можно спутать с факториалом семи-->!&emsp;Пора, наконец, прочитать текст из спойлера выше “<em>Спойлер, лучше не открывать до прочтения всего списка</em>”, и исправить ситуацию:
</p>
<pre><code class="nohighlight">0) ..........11             children: 1
1) ........11..  parent: 0, children: 2
2) ............  parent: 1, children: 3,4,5
3) ..111.......  parent: 2
4) .....111....  parent: 2
5) 11..........  parent: 2</code></pre>
<p>
	Эти данные как раз и являются “топологией сети” – они описывают дерево свитчей, и по ним можно определить все хосты, подключенные к конкретному свитчу.
</p>
<pre><code class="nohighlight">статистика –-[бинаризация]--&gt; реакции хостов --[очистка от единичных реакций]--[очистка от дублей]--[???]--&gt; <strong>топология сети</strong> --[???]--&gt; цепочка пиров</code></pre>
<p>
	Осталось понять, как привести данные к такому виду. По сути, все, что мы сделали (во‑первых, во‑вторых, …) можно преобразовать в алгоритм:
</p>
<ol>
	<li>“во‑первых” (после внесения исправлений из спойлера становится аналогичен действию “в‑третьих”) – <strong>добавить “корневой” кластер</strong> “<code>111111111111</code>” (<a href="https://ru.wikipedia.org/wiki/Универсальное_множество?stable=1">универсум</a>), включающий (хосты всех деревьев в лесу  ∪  хосты, находящиеся на одном свитче с broadcast хостом), т.е. он включает в себя все хосты сети;</li>
	<li>“во‑вторых” – <strong>поиск родителя для каждого кластера</strong>;</li>
	<li>“в‑четвертых” – <strong>построение списка детей для каждого родителя</strong>;</li>
	<li>“и наконец” – <strong>исключение детей из родителей</strong>.</li>
</ol>
<p>
	Теперь можно внести эти действия в общий алгоритм (немного изменил вид):
</p>
<pre><code class="nohighlight">                                               ● статистика ●
                                 [бинаризация] ► реакции хостов
                [очистка от единичных реакций]
                           [очистка от дублей] ► кластеры/лес
                 [добавить &quot;корневой&quot; кластер] ► кластеры/дерево
         [поиск родителя для каждого кластера]
[построение списка детей для каждого родителя]
               [исключение детей из родителей] ► топология сети ●
                                         [???] ► цепочка пиров ●</code></pre>
<details>
	<summary>Альтернативный вид</summary>
	<pre><code class="nohighlight">● статистика      ► [бинаризация]
▬ реакции хостов  ► [очистка от единичных реакций]
                    [очистка от дублей]
▬ кластеры/лес    ► [добавить &quot;корневой&quot; кластер]
▬ кластеры/дерево ► [поиск родителя для каждого кластера]
                    [построение списка детей для каждого родителя]
                    [исключение детей из родителей]
● топология сети  ► [???]
● цепочка пиров   ●</code></pre>
</details>
<p>
	Посмотрим, что произойдет, если применить этот алгоритм к другой сети. Я бы хотел взять сеть “<code>Network_<strong>serial</strong></code>” и ее результаты симуляции (статистику) из раздела “<a href="https://zirokyl.github.io/LLTR-Simulation-Model/a1/#bolshe-setey-s-raznymi-topologiyami-dobavlyaem-novye-seti" title="Первые шаги в OMNeT++ и INET">LLTR Часть 1::Больше сетей с разными топологиями, добавляем новые сети</a>”.
</p>
<p>
	<font color="#54524F"><b>Note</b>:</font> Почему я выбрал именно эту сеть? Она достаточно большая, и в собранных с нее данных присутствуют недочеты (см. конец спойлера “Результаты симуляции” для этой сети).
</p>
<p>
	Поехали!
</p>
<details>
	<summary>Бинаризация</summary>
	<p>
		Реакции хостов:
	</p>
	<pre><code class="nohighlight">.111111..
.111111..
.111111..
.111111..
.111111..
.111111..
.......11
.......11
..1......
...1111..
...1111..
...1111..
...1111..
.......11
.......11
1........
...1111..
...1111..
...1111..
...1111..
.......11
.......11
1........
.1.......
....1....
.....11..
.....11..
.......11
.......11
1........
.1.......
..1......
.....11..
.....11..
.......11
.......11
1........
.1.......
..1......
...1.....
......1..
.........
.........
.........
.1.......
..1......
...1.....
....1....
.........
.........
.........
.1.......
..1......
...1.....
....1....
.....1...
........1
1........
.111111..
.111111..
.111111..
.111111..
.111111..
.111111..
1........
.111111..
.111111..
.111111..
.111111..
.111111..
.111111..
.......1.</code></pre>
</details>
<details>
	<summary>Очистка от единичных реакций</summary>
	<pre><code class="nohighlight">.111111..  --&gt;  .111111..
.111111..  --&gt;  .111111..
.111111..  --&gt;  .111111..
.111111..  --&gt;  .111111..
.111111..  --&gt;  .111111..
.111111..  --&gt;  .111111..
.......11  --&gt;  .......11
.......11  --&gt;  .......11
..1......  --&gt; 
...1111..  --&gt;  ...1111..
...1111..  --&gt;  ...1111..
...1111..  --&gt;  ...1111..
...1111..  --&gt;  ...1111..
.......11  --&gt;  .......11
.......11  --&gt;  .......11
1........  --&gt; 
...1111..  --&gt;  ...1111..
...1111..  --&gt;  ...1111..
...1111..  --&gt;  ...1111..
...1111..  --&gt;  ...1111..
.......11  --&gt;  .......11
.......11  --&gt;  .......11
1........  --&gt; 
.1.......  --&gt; 
....1....  --&gt; 
.....11..  --&gt;  .....11..
.....11..  --&gt;  .....11..
.......11  --&gt;  .......11
.......11  --&gt;  .......11
1........  --&gt; 
.1.......  --&gt; 
..1......  --&gt; 
.....11..  --&gt;  .....11..
.....11..  --&gt;  .....11..
.......11  --&gt;  .......11
.......11  --&gt;  .......11
1........  --&gt; 
.1.......  --&gt; 
..1......  --&gt; 
...1.....  --&gt; 
......1..  --&gt; 
.........  --&gt;  .........
.........  --&gt;  .........
.........  --&gt;  .........
.1.......  --&gt; 
..1......  --&gt; 
...1.....  --&gt; 
....1....  --&gt; 
.........  --&gt;  .........
.........  --&gt;  .........
.........  --&gt;  .........
.1.......  --&gt; 
..1......  --&gt; 
...1.....  --&gt; 
....1....  --&gt; 
.....1...  --&gt; 
........1  --&gt; 
1........  --&gt; 
.111111..  --&gt;  .111111..
.111111..  --&gt;  .111111..
.111111..  --&gt;  .111111..
.111111..  --&gt;  .111111..
.111111..  --&gt;  .111111..
.111111..  --&gt;  .111111..
1........  --&gt; 
.111111..  --&gt;  .111111..
.111111..  --&gt;  .111111..
.111111..  --&gt;  .111111..
.111111..  --&gt;  .111111..
.111111..  --&gt;  .111111..
.111111..  --&gt;  .111111..
.......1.  --&gt;  </code></pre>
</details>
<p>
	Очистка от дублей (получаем “кластеры/лес”):
</p>
<pre><code class="nohighlight">.111111..
.......11
...1111..
.....11..
.........</code></pre>
<p>
	Дополнительно, <strong>для удобства</strong>, отсортирую по убыванию количества “<code>1</code>”:
</p>
<pre><code class="nohighlight">.111111..
...1111..
.....11..
.......11
.........</code></pre>
<p>
	<font color="#54524F"><b>Note</b>:</font> Возможно стоит включить сортировку в алгоритм. Как думаете?
</p>
<p>
	Добавление “корневого” кластера (получаем “кластеры/дерево”):
</p>
<pre><code class="nohighlight">111111111
.111111..
...1111..
.....11..
.......11
.........</code></pre>
<p>
	В него вошли хосты 2‑х деревьев (левая “<code>.111111..</code>” и правая “<code>.......11</code>” часть сети) и 1 хост (“<code>1........</code>”, расположенный на одном свитче с broadcast хостом).
</p>
<p>
	Поиск родителя для каждого кластера:
</p>
<pre><code class="nohighlight">0) 111111111 
1) .111111..  parent: 0
2) ...1111..  parent: 1
3) .....11..  parent: 2
4) .......11  parent: 0
5) .........  parent: 4</code></pre>
<p>
	<font color="#54524F"><b>Note</b>:</font> Вот здесь как раз и проявилось негативное влияние недочетов в данных – 4‑й кластер стал родителем для 5‑го! Вообще, родителем 5‑го кластера может стать любой кластер, т.к. он пуст (∅).
</p>
<p>
	Построение списка детей для каждого родителя:
</p>
<pre><code class="nohighlight">0) 111111111             children: 1,4
1) .111111..  parent: 0, children: 2
2) ...1111..  parent: 1, children: 3
3) .....11..  parent: 2
4) .......11  parent: 0, children: 5
5) .........  parent: 4</code></pre>
<p>
	Исключение детей из родителей:
</p>
<pre><code class="nohighlight">0) 1........             children: 1,4
1) .11......  parent: 0, children: 2
2) ...11....  parent: 1, children: 3
3) .....11..  parent: 2
4) .......11  parent: 0, children: 5
5) .........  parent: 4</code></pre>
<p>
	На этом шаге мы должны были получить “топологию сети”. И мы ее получили. Если нам интересно только местоположение хостов, то такая “топологию сети” нас вполне устраивает. Однако, в нашей сети появился еще один свитч, в котором 0 хостов!
</p>
<p>
	Чтобы все исправить, достаточно будет после одного из первых шагов исключить эти “недочеты в данных”. Это можно сделать сразу же после “бинаризации”:
</p>
<pre><code class="nohighlight">                                               ● статистика ●
                                 [бинаризация] ► реакции хостов
[<strong>очистка от пустоты (∅), и от универсумов (⦱)</strong>]
                [очистка от единичных реакций]
                           [очистка от дублей] ► кластеры/лес
                 [добавить &quot;корневой&quot; кластер] ► кластеры/дерево
         [поиск родителя для каждого кластера]
[построение списка детей для каждого родителя]
               [исключение детей из родителей] ► топология сети ●
                                         [???] ► цепочка пиров ●</code></pre>
<p>
	Мы удаляем пустые множества (∅; “<code>.........</code>”), но зачем удалять универсумы (⦱; “<code>111111111</code>”)? Ответ станет очевидным, когда мы начнем реализовывать этап “бинаризации”. Разные варианты реализации “бинаризации” могут на одних и тех же данных (данных с описанным недочетом) выдать как “<code>.........</code>”, так и “<code>111111111</code>”. И, т.к. получить в корректных входных данных “<code>111111111</code>” на столько же невозможно, как и получить “<code>.........</code>”, то мы можем удалить все “<code>111111111</code>” (к тому же они не несут никакой информации, кроме той, что в данных присутствуют “недочеты”).
</p>
<p>
	Если применить этот (дополненный, исправленный) алгоритм к этой же сети (“<code>Network_<strong>serial</strong></code>”), то “топология сети” станет выглядеть так:
</p>
<pre><code class="nohighlight">0) 1........             children: 1,4
1) .11......  parent: 0, children: 2
2) ...11....  parent: 1, children: 3
3) .....11..  parent: 2
4) .......11  parent: 0</code></pre>
<p>
	<font color="#54524F"><b>Note</b>:</font> Красиво, получилась диагональ. Напоминает <a href="https://ru.wikipedia.org/wiki/Единичная_матрица?stable=1">единичную матрицу</a>, но ее в чистом виде получить не удастся. Можно сделать, чтобы в каждом кластере было по 2 хоста (для этого нужно добавить один хост в “switch0”), но мы не сможем получить в каждых кластерах только 1 хост (в крайних кластерах <a href="https://habr.com/post/414799/#topologiya-posledovatelnoe-soedinenie-svitchey" title="LLTR Часть 0::Топология: “последовательное соединение свитчей” – ближе к концу раздела">всегда будут как минимум 2 хоста</a>):
</p>
<details>
	<summary>Примеры не “единичной матрицы”</summary>
	<pre><code class="nohighlight">0) 11........             children: 1,4
1) ..11......  parent: 0, children: 2
2) ....11....  parent: 1, children: 3
3) ......11..  parent: 2
4) ........11  parent: 0</code></pre>
	<pre><code class="nohighlight">0) 1......             children: 1,4
1) .1.....  parent: 0, children: 2
2) ..1....  parent: 1, children: 3
3) ...11..  parent: 2
4) .....11  parent: 0</code></pre>
</details>
<p>
	Мы смогли дописать алгоритм до получения корректной “топологии сети”. Осталось построить “цепочку пиров” из “топологии сети”. В статье про RingSync я уже <a href="http://9b.asoiu.com/2016/3704-ringsync-синхронизируем-на-полной-скорости-с/#h-3-3-pc-podklyucheny-k-raznym-switch">описывал, как это сделать</a> (обход дерева в глубину: <a href="https://en.wikipedia.org/wiki/Tree_traversal?stable=1#Pre-order_(NLR)">Pre‑order</a>). В итоге “цепочка пиров” должна получиться такой:
</p>
<pre><code class="nohighlight">1 1........  hostS/seed -&gt; host0 -&gt;
. .11......  host1 -&gt; host2 -&gt;
. ...11....  host3 -&gt; host4 -&gt;
. .....11..  host5 -&gt; host6 -&gt;
. .......11  host7 -&gt; host8/leech</code></pre>
<p>
	<font color="#54524F"><b>Note</b>:</font> в первую строчку (левый, отделенный столбец) добавлен сид, он же broadcast хост.
</p>
<p>
	Кажется, что ничего не изменилось по сравнению с порядком кластеров в “топологии сети” (все та же диагональ), и это действительно так для этой сети (“<code>Network_<strong>serial</strong></code>”). Чуть ниже я проделаю то же самое с нашей предыдущей сетью (которой я так и не дал название), возможно на ней будут видны изменения. А пока я покажу путь движения трафика для построенной цепочки:
</p>
<img id="fig_network_serial-chain_no_prio" alt="Диаграмма: последовательное соединение свитчей; путь движения трафика для цепочки, построенной без приоритетов" align="center" height="425" src="https://hsto.org/webt/jz/z4/kr/jzz4krcoae75dext_zypn9cgn7o.png#network_serial-chain_no_prio.png"/>
<p>
	Как и обещал, делаю то же самое для “предыдущей сети” (“цепочка пиров”):
</p>
<pre><code class="nohighlight">..........11 1  hS/seed -&gt; h10 -&gt; h11 -&gt;
........11.. .  h8 -&gt; h9 -&gt;
..111....... .  h2 -&gt; h3 -&gt; h4 -&gt;
.....111.... .  h5 -&gt; h6 -&gt; h7 -&gt;
11.......... .  h0 -&gt; h1/leech</code></pre>
<p>
	Изменений (по сравнению с расположением кластеров в “топологии сети”) практически нет. Единственное, что изменилось – это исчез кластер 2, т.к. он был пуст (∅). Означает ли это, что “обход дерева в глубину” не нужен, и достаточно взять кластеры из “топологии сети” (в том же порядке, в котором они будут на этот момент), и удалить все пустые (∅) кластеры? Однако, это не так: во‑первых, чтобы кластеры выстроились в таком “удобном” порядке я использовал сортировку, но она до сих пор не была включена в алгоритм ( надо бы включить, но пока еще рано ；） ; во‑вторых, не для всех сетей этот трюк сработает (попробуйте придумать такую сеть без заглядывания в спойлер).
</p>
<details>
	<summary>Простым трансформированием, сеть “предыдущая сеть” превращается в сеть, для которой нужен “обход дерева в глубину”</summary>
	<img id="fig_LLTR_Hybrid_Net_clear-mirrored-need_depth_first_traversal" alt="Диаграмма: LLTR гибридная сеть (clear), зеркально скопирована, нужно использовать “depth first traversal”" align="center" height="116" src="https://hsto.org/webt/z4/im/50/z4im5081mvtt5m8tgq8bhntd-l4.png#LLTR_Hybrid_Net_clear-mirrored-need_depth_first_traversal.svg.png"/>
	<p>
		Я попробовал применить алгоритм (вместе с сортировкой) к этой сети, и, на момент получения “топологии сети”, расположение кластеров <a href="https://ru.wikipedia.org/wiki/Поиск_в_ширину?stable=1">стало сильно что‑то напоминать</a>…
	</p>
</details>
<p>
	Ладно, вернемся к построенной “цепочке пиров”, и посмотрим на путь движения трафика…
</p>
<p>
	<font color="#54524F"><b>Note</b>:</font> Здесь должна была быть картинка, но изображение пути движения трафика на такой маленькой диаграмме, стало напоминать спагетти. Не рекомендую смотреть на это.
</p>
<details>
	<summary>Одна из попыток изобразить путь</summary>
	<p>
		Я даже изменил последовательность соединения пиров, подключенных к одному свитчу (их все равно можно соединять в любой последовательности), но и это не помогло.
	</p>
	<img id="fig_LLTR_Hybrid_Net_clear-chain" alt="Диаграмма: LLTR гибридная сеть (clear); путь движения трафика" align="center" height="116" src="https://hsto.org/webt/oi/e6/2p/oie62pzxdprqvpjiampqfx6xg0o.png#LLTR_Hybrid_Net_clear-chain.svg.png"/>
	<p>
		Цепочка пиров:
	</p>
	<pre><code class="nohighlight">..........11 1  hS/seed -&gt; <strong>h11</strong> -&gt; <strong>h10</strong> -&gt;
........11.. .  <strong>h9</strong> -&gt; <strong>h8</strong> -&gt;
..111....... .  h2 -&gt; h3 -&gt; h4 -&gt;
.....111.... .  h5 -&gt; h6 -&gt; h7 -&gt;
11.......... .  h0 -&gt; h1/leech</code></pre>
</details>
<p>
	В этот момент мне захотелось опять взглянуть на путь движения трафика в “<code>Network_<strong>serial</strong></code>”…
</p>
<p>
	Теперь я обратил внимание, на то в какой последовательности трафик проходит через свитчи:
</p>
<pre><code class="nohighlight">           switch0 -&gt; switch1 -&gt; switch2 -&gt; switch3 -┐
switch4 &lt;- <strong>switch0 &lt;- switch1 &lt;- switch2</strong> &lt;-----------┘</code></pre>
<p>
	… и мне очень не понравился “крюк” через “<code>switch0 &lt;- switch1 &lt;- switch2</code>”. Хотелось получить на выходе алгоритма такую последовательность:
</p>
<pre><code class="nohighlight">                                 switch0 -&gt; switch4 -┐
switch3 &lt;- switch2 &lt;- switch1 &lt;- <strong>switch0</strong> &lt;-----------┘</code></pre>
<p>
	Путь движения трафика для нее:
</p>
<img id="fig_network_serial-chain_prio" alt="Диаграмма: последовательное соединение свитчей; путь движения трафика для цепочки, построенной с учетом приоритетов" align="center" height="425" src="https://hsto.org/webt/l3/a2/pa/l3a2pajwqqxotzgjamw1lvkshvg.png#network_serial-chain_prio.png"/>
<p>
	Путь стал короче, и, главное, нагрузка на сеть уменьшилась!
</p>
<p>
	<font color="#54524F"><b>Note</b>:</font> но меня все же больше привлекает уменьшение количества промежуточных сетевых узлов, т.е. “путь стал короче”.
</p>
<p>
	<font color="#54524F"><b>Note</b>:</font> имеется ввиду именно “количество промежуточных сетевых узлов”, а не “суммарная длина канала” (длина сетевого кабеля; длина пути прохождения сигнала на <a href="https://ru.wikipedia.org/wiki/Физический_уровень?stable=1">физическом уровне – L0</a>) – она вполне могла и увеличится.
</p>
<p>
	Чтобы этого добиться, достаточно добавить в “обход дерева в глубину” небольшую эвристику.
</p>
<p>
	<font color="#54524F"><b>Note</b>:</font> эту эвристику я изначально создавал для другой цели, но у нее оказался очень полезный побочный эффект – уменьшение количества промежуточных сетевых узлов.
</p>
<p>
	<strong><a href="https://ru.wikipedia.org/wiki/Эвристика?stable=1#Эвристические_методы">Эвристика</a> (правило)</strong>: при “входе в поддерево” (<a href="https://habr.com/post/414799/#topologiya-zvezda-iz-svitchey" title="Автоматическое определение топологии сети и неуправляемые коммутаторы. Миссия невыполнима?">LLTR Часть 0::Топология: “звезда из свитчей”</a>) отдавать <strong>приоритет</strong> <em>узлам</em> с меньшей вложенностью:
</p>
<ol>
	<li><em>узел</em> – хост;</li>
	<li><em>узел</em> – один свитч;</li>
	<li><em>узел</em> – два свитча (соединенных последовательно);</li>
	<li><em>узел</em> – много свитчей (соединенных как угодно) – чем больше, тем ниже приоритет.</li>
</ol>
<p>
	<font color="#54524F"><b>Note</b>:</font> если в тексте этого списка заменить “<em>узел –</em>” на “<em>порт свитча, к которому подключен</em>”, то, возможно, он станет понятнее.
</p>
<p>
	<font color="#54524F"><b>Note</b>:</font> Изначальная цель этих правил – вначале пустить трафик через ближайшие хосты (хосты до которых меньше всего промежуточных устройств). Меньше промежуточных устройств – меньше вероятность возникновения ошибки (при передаче данных) в самом начале пути. Сравните две дорожные ситуации, приводящие к временной пробке (одна полоса): затор случился в начале дороги (буферная зона практически отсутствует); затор случился ближе к концу дороги (размер буферной зоны достаточен для смягчения последствий затора).
</p>
<p>
	Обновим алгоритм:
</p>
<pre><code class="nohighlight">                                                    ● статистика ●
                                      [бинаризация] ► реакции хостов
     [очистка от пустоты (∅), и от универсумов (⦱)]
                     [очистка от единичных реакций]
                                [очистка от дублей] ► кластеры/лес
                      [добавить &quot;корневой&quot; кластер] ► кластеры/дерево
              [поиск родителя для каждого кластера]
     [построение списка детей для каждого родителя]
                    [исключение детей из родителей] ► топология сети ●
[обход дерева в глубину с учетом приоритетов/весов] ► цепочка пиров ●</code></pre>
<p>
	И обновленная “цепочка пиров” для “<code>Network_<strong>serial</strong></code>” сети станет выглядеть так:
</p>
<pre><code class="nohighlight">1 1........  hostS/seed -&gt; host0 -&gt;
. .......11  host7 -&gt; host8 -&gt;
. .11......  host1 -&gt; host2 -&gt;
. ...11....  host3 -&gt; host4 -&gt;
. .....11..  host5 -&gt; host6/leech</code></pre>
<p>
	Что полностью соответствует измененному “пути движения трафика”, который изображен выше.
</p>
<p>
	А вот на “прежнюю сеть” обновление алгоритма никак не повлияло. “Цепочка пиров” осталась прежней:
</p>
<pre><code class="nohighlight">s0) ..........11 1  hS/seed -&gt; h10 -&gt; h11 -&gt;
s1) ........11.. .  h8 -&gt; h9 -&gt;
s3) ..111....... .  h2 -&gt; h3 -&gt; h4 -&gt;
s4) .....111.... .  h5 -&gt; h6 -&gt; h7 -&gt;
s5) 11.......... .  h0 -&gt; h1/leech</code></pre>
<p>
	Почему не изменилось? Обновление алгоритма влияет на последовательность свитчей, однако, в этой сети, последовательность уже была оптимальной (обновление алгоритма не смогло ни улучшить и ни ухудшить ее):
</p>
<pre><code class="nohighlight">s0 -&gt; s1 -&gt; s2 -&gt; s3 -┐
   ┌- s4 &lt;- <strong>s2</strong> &lt;------┘
   └------&gt; <strong>s2</strong> -&gt; s5</code></pre>
<p>
	<font color="#54524F"><b>Note</b>:</font> номер свитча “<code>s#</code>” соответствует номеру кластера в “топологии сети” для этой сети (см. выше).
</p>
<h2 id="tldr"><a href="#tldr" title="Ссылка на раздел"><font color="gray">#</font></a> TL;DR</h2><hr />
<p>
	Алгоритм определения топологии сети и построения цепочки пиров по собранной статистике:
</p>
<ol>
	<li>Бинаризация (~~ k‑medoids ~~) + очистка от пустоты (∅), и от универсумов (⦱) + очистка от единичных реакций:
		<ol type="a">
			<li>середина между <code>a<sub>min</sub></code> и <code>a<sub>max</sub></code></li>
			<li>разделить на 2 части посередине
				<ol type="I">
					<li>+ очистка от пустоты (∅), и от универсумов (⦱)</li>
				</ol>
			</li>
			<li>найти медиану массива левой и правой части:
				<ol type="I">
					<li>(<a href="https://habrahabr.ru/post/346930">Мой любимый алгоритм: нахождение медианы за линейное время</a>)</li>
					<li>(<a href="https://habrahabr.ru/post/247053">Сортировка на односвязном списке за O(nlogn) времени в худшем случае с O(1) дополнительной памяти</a>)</li>
					<li>(<a href="https://stackoverflow.com/questions/11068429/nth-element-implementations-complexities">nth_element implementations complexities</a>)</li>
				</ol>
			</li>
			<li>найти середину между <code>a<sub>medL</sub></code> (medLow) и <code>a<sub>medR</sub></code> (medHi)</li>
			<li>разделить на 2 части по новой середине, и сразу представить в двоичном виде</li>
			<li>+ очистка от единичных реакций</li>
		</ol>
	</li>
	<li>Дедупликация + добавление “корневого” кластера:
		<ol type="a">
			<li>+ добавить “корневой” кластер</li>
			<li>+ отсортировать по <code>bitCount</code> (от max к min)</li>
			<li>убрать дубликаты</li>
		</ol>
	</li>
	<li>Поиск родителя для каждого кластера:
		<ol type="a">
			<li>начиная с min элемента искать снизу (min) вверх (max) тот (первый попавшийся) элемент, куда входит текущий;<br />
				искать при помощи проверки <code><nobr>bitCount(a<sub>i</sub>)==bitCount(a<sub>i</sub>|a<sub>min</sub>)</nobr></code>, либо более простая проверка: <code><nobr>a<sub>i</sub>==a<sub>i</sub>|a<sub>min</sub></nobr></code></li>
			<li>предыдущий шаг выполнять рекурсивно, попутно фиксировать цепочку элементов (путь рекурсии) – к текущему элементу добавлять идентификатор следующего элемента</li>
			<li>найти следующий min элемент (не участвующий в цепочке) и повторить рекурсию</li>
		</ol>
	</li>
	<li>Построение списка (карты) детей для каждого родителя:
		<ol type="a">
			<li>создать обратную цепочку (от “родителей” к “потомкам”)</li>
		</ol>
	</li>
	<li>Исключение детей из родителей:
		<ol type="a">
			<li>когда все элементы будут в “цепочке”, то начиная с max элемента, сделать <nobr>or|=a<sub>i</sub></nobr> над его потомками, и применить <code><nobr>a<sub>max</sub>&amp;=~or</nobr></code><br />
				(либо “<code><nobr>a<sub>max</sub>^=or</nobr></code>” – при корректных данных результат совпадет)</li>
			<li>рекурсивно повторить с потомками потомков<br />
				(либо просто двигаемся от <code>a<sub>max</sub></code> до <code>a<sub>min</sub></code>, т.к. это дерево, и его вершины отсортированы в массиве)</li>
		</ol>
	</li>
	<li>Обход дерева в глубину с учетом приоритетов/весов:
		<ol type="a">
			<li>построить маршрут для трафика (RingSync)</li>
		</ol>
	</li>
</ol>
<p>
	<font color="#54524F"><b>Note</b>:</font> примерно в таком виде я <a href="https://github.com/ZiroKyl/LLTR-Process/blob/a6e93c666c9fd0278768f7ad9b7df1340a9d0934/LLTR/LLTR.cpp#L450-L493" title="Woops">записал алгоритм</a> <img alt="git" width="19" height="19" src="https://hsto.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/>, перед его реализации в коде.
</p>
<details>
	<summary>Немного про структуру кода</summary>
	<blockquote cite="https://habrahabr.ru/post/349336">
		Гипотеза. Чем умнее программист (чем более объёмной рабочей памятью он располагает), тем более длинные методы и функции он пишет.
	</blockquote>
	<p align="right">
		<i>Из “<a href="https://habrahabr.ru/post/349336">Горе от ума, или Почему отличники пишут непонятный код</a>”</i>
	</p>
	<p>
		Я не настолько умный, чтобы создавать такие большие функции с таким большим количеством переменных, поэтому я использую области видимости (“<code>{…}</code>”) для структурирования (упрощения) кода. Получается аналог вложенных анонимных функций (пример):
	</p>
	<pre><code class="cpp">// вначале перечислены переменные &quot;возвращаемые из функции&quot;
int ...;{
    // а здесь тело &quot;функции&quot;
}</code></pre>
	<p>
		Если надо дать название “функции”, то оно записывается в комментарии перед блоком (пример):
	</p>
	<pre><code class="cpp">//==[Name]==//
int ...;{
    ...
}</code></pre>
	<p>
		Если такой код визуализировать, то получится подобная диаграмма:
	</p>
	<img id="fig_TensorsFlowing" alt="Tensors Flowing" align="center" height="448" src="https://hsto.org/webt/gi/pl/sb/giplsbsx_pzinjjngcqqph2rmdu.gif#TensorsFlowing.gif"/>
	<p align="center">
		<i><a href="https://youtu.be/iJKv3gKjvb4">TensorsFlowing</a></i>
	</p>
	<p>
		т.е. каждая область видимости – это отдельный блок на диаграмме, а “переменные, возвращаемые из функции” – связи между блоками.
	</p>
	<p>
		Что дает такой подход к структурированию?<br />
		Это дает:
	</p>
	<ul>
		<li>Свободу перемещения частей кода – я могу (если это потребуется) быстро перенести часть кода из одного блока в другой блок, реорганизуя тем самым последовательность действий. Мне не нужно заботиться о передаваемых в “функцию” параметрах, т.к. любая “функция” уже “видит” все переменные из внешних областей видимости. Также, если для оптимального выполнения кода нужно будет сделать “нечто странное”, то это можно будет сделать.</li>
		<li>Все в одном месте – не нужно “прыгать” по множеству функций / файлов в проекте, чтобы понять, что конкретно делает этот код. Достаточно прочесть его последовательно от начала до конца. Это похоже на чтение дизассемблированной программы, при сборке которой линкер (Interprocedural optimization, Whole program optimization; Link‑time optimization) большинство функций “заинлайнил” – это очень упрощает чтение.</li>
	</ul>
	<p>
		<font color="#54524F"><b>Note</b>:</font> Мой ответ на тему статьи из которой была взята цитата: т.к. еще до создания своих программ они успели поработать с множеством ресурсоемких приложений (2D/3D графические редакторы, рендеры, другие приложения для моделирования *, …). И им со временем начали надоедать лаги (задержки), возникающие при редактировании проекта, а также тот факт, что финальный просчет может занимать несколько жарких летних дней (в течение которых компьютер, расположенный в спальне, работает 24 часа, и мешает заснуть; это происходило во времена, когда <a href="https://ru.wikipedia.org/wiki/ACPI?stable=1#Глобальные_состояния">ACPI</a> <a href="https://en.wikipedia.org/wiki/Sleep_mode?stable=1#Microsoft_Windows">только</a> <a href="https://en.wikipedia.org/wiki/Hibernation_(computing)?stable=1#Operating_system_support">появился</a>), в процессе одного из которых взрываются (выстреливают оболочкой) конденсаторы на материнской плате, что явно не добавляет им дофамина ：（ . Дальше они знакомятся с тонкостями разгона (тайминги, системы фазового перехода, …) и тюнинга операционной системы, чтобы хоть как‑нибудь подправить ситуацию подручными средствами. И наконец, они встречают первое в своей жизни демо, и узнают про демо‑сцену. Уровень их дофамина повышается (они словно видят лучик “нитро” в мире “тормозов”), и просят родителей купить первую в их жизни книгу “по программированию на *”. В общем, они – это те люди, которые сами используют то, что создают, и хотят максимально утилизировать доступные ресурсы. А также у них есть нечеткое разделение (правило) – реализовывать алгоритм для того, кто будет его выполнять. Если это – компьютер (не человек), то пишется код для него. Если это – человек, то ничего нагляднее диаграммы/схемы/инфо‑графики/анимации пока еще никто не придумал/реализовал. А отладочная (debug) реализация находится где‑то посередине.
	</p>
	<p>
		<font color="#54524F"><b>Note</b>:</font> Это всего лишь Debug версия кода, по которой еще надо несколько раз пройтись профилировщиком (ведь, иногда повторив одно и то же в коде два раза – можно <a href="http://zirokyl.github.io/DFD2015-TeHI/TeHI-PoC/index.wo.section.htm">увеличить производительность программы в несколько раз</a> {вроде простое дублирование кода ускорило его в 9 раз, записей про этот вариант не осталось; по ссылке – окончательный вариант с ×16 ускорением (раздел 1.2 и 1.5); скриншоты из профилировщика <a href="https://lh3.googleusercontent.com/-ibEyIYQKRDA/Ud-l3E86nBI/AAAAAAAAAVI/6p3fUPiHw9oSVspXc0FQEpQRzimceDU2ACL0BGAYYCw/h1110/old.PNG">до</a> → <a href="https://lh3.googleusercontent.com/-NFKe0i6AkcE/Ud-mMawTWZI/AAAAAAAAAVc/Q17ZwcTqky4zl8hrUsn_rUbmRR7vWRNdQCL0BGAYYCw/h708/new%2B%2528%252BCPI%2529.PNG">после</a>}), и устранить warning'и компилятора.
	</p>
	<p>
		<font color="#54524F"><b>Note</b>:</font> Некоторые комментарии в коде могут показаться странными, особенно учитывая тот факт, что после <em>дедупликации</em> размер обрабатываемых данных значительно сократится, и поместится в одну кеш‑линию. В эти моменты я думал, как обрабатывать значительно больший объем данных, и забывал (вытеснял из “рабочей памяти” мозга) этап <em>дедупликации</em>.
	</p>
</details>
<h2 id="tooo-long-didnt-read-visualize-plz"><a href="#tooo-long-didnt-read-visualize-plz" title="Ссылка на раздел"><font color="gray">#</font></a> Tooo Long; Didn't Read; Visualize, plz.</h2><hr />
<p>
	<font color="#54524F"><b>Note</b>:</font> Ниже вы увидите анимацию работы каждого из блоков, и анимацию передачи данных между блоками (как в GIF “TensorsFlowing” из спойлера “Немного про структуру кода”). При создании этих GIF меня вдохновляли уже упомянутый “TensorsFlowing” и GIF “<a href="https://plus.google.com/103542603958891638042/posts/Zs2hQSbpHiZ">Loop over python list animation</a>”. Также, в эти GIF я пытался перенести образы, которые “всплывают в мозге” при чтении/создании этих строк кода. Естественно, из‑за определенных ограничений перенос не может быть осуществлен 1:1, тем не менее “добро пожаловать в мой мозг”.
</p>
<h3 id="blok-binarizacii"><a href="#blok-binarizacii" title="Ссылка на раздел"><font color="gray">#</font></a> Блок бинаризации</h3>
<p>
	<font color="#54524F"><b>Note</b>:</font> При создании GIF я пробовал разными способами разместить код рядом с анимацией (как в “Loop over python list animation”), но не один из вариантов не выглядел хорошо. Поэтому, связанный с анимацией код, я поместил в спойлеры под анимацией. Номер спойлера соответствует номеру этапа в анимации ( номера появляются справа ；）
</p>
<p>
	<font color="#54524F"><b>Note</b>:</font> Первую (и вторую) итерацию лучше посмотреть без заглядывания в спойлеры (одновременное наблюдение за анимацией и чтение исходников может запутать). В частности, по этой причине я поместил в спойлеры кадр из анимации конкретного этапа.
</p>
<p>
	<font color="#54524F"><b>Note</b>:</font> Не во всех браузерах GIF начнет проигрываться с начала (в начале есть надпись “Scroll Down”), для того, чтобы вернуться на начало, я сделал эту кнопку: <button onclick="var _=document.getElementById('fig_binarization'),uri;uri=_.src;_.src='';_.src=uri;">с начала</button>
</p>
<img id="fig_binarization" alt="Анимация: бинаризация" align="center" height="1042" src="https://hsto.org/webt/7r/mf/m8/7rmfm8ntqxja04lzz5c0gwvzpc4.gif#binarization.gif"/>
<details>
	<summary>#1</summary>
	<pre><code class="cpp">int average;{
       int max,min;
       max=min=countFill[i][0];
       for(int j=1;j&lt;numHosts;j++){
             max=countFill[i][j]&gt;max?countFill[i][j]:max;
             min=countFill[i][j]&lt;min?countFill[i][j]:min;
       }
       average=(max+min)/2;
}</code></pre>
	<img id="fig_binarization-step-1" alt="Кадр: бинаризация – этап 1" align="center" height="405" src="https://hsto.org/webt/qb/2w/6q/qb2w6qmjjuaz8ogkgjj0tnzacum.png#binarization-step-1.png"/>
	<p>
		<font color="#54524F"><b>Note</b>:</font> на самом деле в GIF нету этого кадра…
	</p>
</details>
<details>
	<summary>#2</summary>
	<pre><code class="cpp">int lo=0;
struct CnN{
       int Count;
}iFill[numHosts];
for(int j=0,hi=numHosts-1;j&lt;numHosts;j++){
       if(countFill[i][j]&lt;average) iFill[lo++].Count=countFill[i][j];
       else                        iFill[hi--].Count=countFill[i][j];
}

bitCluster[i]=0;
if(lo==0||lo==numHosts) continue;  //псевдо-очистка от пустоты и от универсумов</code></pre>
	<p>
		<font color="#54524F"><b>Note</b>:</font> эти фрагменты кода (в спойлерах) немного отличаются от <a href="https://github.com/ZiroKyl/LLTR-Process/blob/a6e93c666c9fd0278768f7ad9b7df1340a9d0934/LLTR/LLTR.cpp#L148-L167">кода в репозитории</a>.
	</p>
	<img id="fig_binarization-step-2" alt="Кадр: бинаризация – этап 2" align="center" height="531" src="https://hsto.org/webt/lf/p9/s5/lfp9s52pyu8sygo960saoduulqq.png#binarization-step-2.png"/>
</details>
<details>
	<summary>#3</summary>
	<pre><code class="cpp">int averageMed;{
       CnN *iFillLo=&amp;iFill[0];
       CnN *iFillHi=&amp;iFill[lo];
       const int hi=numHosts-lo;

       if(lo&gt;1) std::nth_element(iFillLo,&amp;iFillLo[lo/2],&amp;iFillLo[lo],[](const CnN a,const CnN b){return a.Count&lt;b.Count;});
       if(hi&gt;1) std::nth_element(iFillHi,&amp;iFillHi[hi/2],&amp;iFillHi[hi],[](const CnN a,const CnN b){return a.Count&lt;b.Count;});

       averageMed=(iFillLo[lo/2].Count+iFillHi[hi/2].Count)/2;
}</code></pre>
	<img id="fig_binarization-step-3" alt="Кадр: бинаризация – этап 3" align="center" height="590" src="https://hsto.org/webt/zt/mv/7n/ztmv7ngkoxo4hbchmuw87clx_uo.png#binarization-step-3.png"/>
	<p>
		<font color="#54524F"><b>Note</b>:</font> <code>std::nth_element()</code> работает оптимальнее, чем вариант, показанный на анимации (сортировка + выбор среднего элемента = медиана).
	</p>
</details>
<details>
	<summary>#4</summary>
	<pre><code class="cpp">for(unsigned int j=0;j&lt;numHosts;j++) bitCluster[i]|=( (countFill[i][j]&lt;averageMed)?1:0 )&lt;&lt;j;</code></pre>
	<img id="fig_binarization-step-4" alt="Кадр: бинаризация – этап 4" align="center" height="655" src="https://hsto.org/webt/jv/9t/ps/jv9tpsmlj_jishpu8vp0lcrog4e.png#binarization-step-4.png"/>
</details>
<details>
	<summary>#5</summary>
	<pre><code class="cpp">bitCluster[i] = bitCluster[i]^(1&lt;&lt;((i/(numHosts-1))+(i%(numHosts-1)+1))%numHosts) ? bitCluster[i]:0;</code></pre>
	<img id="fig_binarization-step-5" alt="Кадр: бинаризация – этап 5" align="center" height="890" src="https://hsto.org/webt/x6/qx/_w/x6qx_w2xyxanwrzvi4wdhrancfo.png#binarization-step-5.png"/>
</details>
<p>
	<font color="#54524F"><b>Note</b>:</font> Исходники GIF находятся в <a href="https://github.com/ZiroKyl/LLTR-Process/tree/60fecb781b6a7933701c8784669dd316b0ffc6a3/doc/visualization">репозитории</a> <img alt="git" width="19" height="19" src="https://hsto.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/>. Перед их просмотром рекомендую прочесть ReadMe (это может сберечь ваши нервные клетки; и если кто‑нибудь знает более подходящий инструмент для визуального создания подобной анимации, то прошу написать про него в <a href="https://habr.com/post/421243/#comments">комментариях</a>).
</p>
<details>
	<summary>Входные данные</summary>
	<p>
		Я все‑таки создал в <nobr>OMNeT++</nobr> модель “прежней сети”, а полученную статистику сохранил в “<a href="https://github.com/ZiroKyl/LLTR-Process/blob/a6e93c666c9fd0278768f7ad9b7df1340a9d0934/LLTR/DAT_EX.h">DAT_EX.h</a>”.
		<!-- хотел вставить <oembed> с GitHub, но оказалось, что он существует только для GitHub Gist -->
	</p>
</details>
<h3>…</h3>
<h2 id="rip-protocol"><a href="#rip-protocol" title="Ссылка на раздел"><font color="gray">#</font></a> Протокол прощения с жизнью</h2><hr />
<p>
	Написание первых 3‑х частей растянулось на 1.92&thinsp;года, и я не уверен, что за <nobr>1.6&thinsp;-&thinsp;2</nobr> месяца успею дописать оставшиеся части. При том, что описанные в первых 3‑х частях события длились (в реальной жизни) чуть меньше месяца (за который я также успел написать первую реализацию на Go – это заняло 2&thinsp;дня, и провести эксперимент на реальной сети – <nobr>2&thinsp;-&thinsp;4</nobr> дня). Затем был перерыв (4&thinsp;месяца), и еще 2.5&thinsp;месяца работы над LLTR.
</p>
<p>
	В спойлере находятся наброски оставшихся частей + TODO’шки + ссылки на исходники.
</p>
<p>
	Возможно, я смогу что‑нибудь из этого дописать, поэтому прошу, по крайней мере, 2&thinsp;месяца не заглядывать под спойлер.
</p>
<p>
	<font color="#54524F"><b>Note</b>:</font> в конце понимаешь, сколько знаний/идей ты не описал, и они просто умрут вместе с тобой…
</p>
<details>
	<summary>спойлер</summary>
	<p>
		Прошло ли 2&thinsp;месяца с момента публикации этой статьи?
	</p>
	<details>
		<summary>Нет</summary>
		<p>
			Любопытно?
		</p>
		<p>
			Ладно, ничего страшного, я бы и сам при встрече условного оператора прошелся по обеим веткам. Тем боле, что если появятся вопросы по неописанным частям, то через 2 месяца на них уже некому будет ответить. Поэтому лучше задать их сейчас.
		</p>
	</details>
	<details>
		<summary>Да</summary>
		<details>
			<summary>Продолжение данной части</summary>
			<h2 id="tooo-long-didnt-read-visualize-plz--continue"><a href="#tooo-long-didnt-read-visualize-plz--continue" title="Ссылка на раздел"><font color="gray">#</font></a> Tooo Long; Didn't Read; Visualize, plz.</h2><hr />
			<p>
				TODO[old]: сделать анимацию каждого этапа алгоритма (1 этап – gif_1, стрелка вниз, 2 этап – gif_2, стрелка вниз, …)
			</p>
			<p>
				TODO: сделать анимацию каждого этапа алгоритма, разместить каждую анимацию в своем подразделе
			</p>
			<a href="https://hsto.org/webt/pt/0y/ol/pt0yolttokv5i7riwqilzyradqi.jpeg#sticker_2x.jpg"><img id="fig_sticker" alt="Стикер: демонстрация побитового & – он ипользуется где‑то в алгоритме" align="center" height="258" src="https://hsto.org/webt/wy/4a/ag/wy4aagpiizafzimifpzgmtqt0ks.jpeg#sticker.jpg"/></a>
			<p align="center">
				(набросок элементов и анимации одного из этапов)
			</p>
			<p>
				TODO: сделать общую анимацию передачи данных между блоками (как в GIF “TensorsFlowing”, только направить поток данных сверху‑вниз – как в коде программы), разместить ее в последнем подразделе
			</p>
			<p>
				(объяснить в Note, почему я выбрал именно GIF для анимации, а, например, не загрузил видео на YouTube. Ответ простой: субдискретизация 4:2:0 и TV‑диапазон яркостей (динамический диапазон <nobr>16&thinsp;-&thinsp;235</nobr>). Первое создаст цветные ореолы на границе цветных однопиксельных линий и белого фона, а второе – сделает белый фон тусклым (серым). Другие форматы: SVG – были бы проблемы с рендером текста, и при рендере “желтой обводки‑подсветки”; SWF – R.I.P.)
			</p>
			<h2 id="chto-esche-mozhno-uskorit"><a href="#chto-esche-mozhno-uskorit" title="Ссылка на раздел"><font color="gray">#</font></a> Что еще можно ускорить?</h2><hr />
			<p>
				Избавится от структур (массивов структур), и адаптировать реализацию используемых std функций (например, сортировки) для работы с отдельными массивами (которые получились после избавления от структур);
			</p>
			<p>
				Можно ускорить нахождение родителей (пропуская кластеры с количеством “<code>1</code>” == количеству “<code>1</code>” текущего кластера). Пример:
			</p>
			<pre><code class="nohighlight">0) 111111111111
1) 1111111111..
2) 11111111....
3) ..111.......
4) .....111.... &lt;- текущий кластер, можно сразу прыгнуть ко 2‑му, пропустив 3‑й
5) 11..........</code></pre>
			<p>
				Это можно сделать (т.е. это безопасно), т.к. пересекающихся кластеров с одинаковым количеством “<code>1</code>” быть не может (дублей мы удалили ранее) (см. “невозможный пример” из примеров “потокового разделителя”). Для этой оптимизации необходима дополнительная информация об индексе конца предыдущего диапазона с большим числом “<code>1</code>”, т.е.:
			</p>
			<pre><code class="nohighlight">0) 111111111111 
1) 1111111111..  0
2) 11111111....  1
3) ..111.......  2
4) .....111....  2
5) 11..........  4</code></pre>
			<p>
				(вставить более наглядный пример с сетью, похожей на бинарное дерево – нарисовать диаграмму сети + представить в текстовом виде (кластеры+индексы), как сделано выше)
			</p>
			<p>
				Информацию об индексе можно получить на этапе сортировки (ее все равно уже собрались “препарировать”). Главное в конце оценить суммарное время CPU, затраченное на сортировку + поиски родителей. Оно вполне может стать больше, чем прежде, если дополнения, внесенные в сортировку, сильно замедлят ее.
			</p>
			<p>
				…
			</p>
		</details>
		<details>
			<summary>3: OMNeT++ продолжение</summary>
			<h1>LLTR Часть 3: OMNeT++ продолжение</h1>
			<p>
				Неудача с первой реализацией на Golang. (просто упомянуть факт, что она была)
			</p>
			<p>
				(вначале сделать бекап, и обновится до последней версии <nobr>OMNeT++</nobr> c исправленным Qtenv)
			</p>
			<p>
				(перейти на фон “background/fresh” для “.ned” {“<code>grey99</code>” → “<code>-,-,0;bgi=background/fresh</code>”}, и “blueprint/print-26.png” для фона Qtenv из “LLTR Часть 1::Набор узоров для фона”)
			</p>
			<p>
				(улучшение результатов, из “OMNetProject (v0.9) lltdapp”)
			</p>
			<p>
				(при объяснении, почему на хостах с разным удалением от “hostS” доходит разное количество пакетов – сразу запустить симуляцию (с большим количеством промежуточных свитчей) и открыть одну из очередей свитча в инспекторе. Показать, что, при свободном месте в очереди – доходит broadcast пакет, а за ним приходит unicast пакет, но т.к. очередь заполнена – он отбрасывается, и так происходит всегда. Вот что бывает в идеальном мире, в неидеальном мире – есть “спонтанные задержки”. “идеальный мир – мертвый мир”, из Лангольеров: “здесь нет эхо” – вспомнить про результаты сети “Serial” из “Части 1” (проблема с концами – “затухание воздействия”). Попробовать добавить еще несколько промежуточных свитчей – ситуация должна улучшится (задержка, создаваемая свитчами, поменяла порядок broadcast и unicast пакетов)[показать как добавить rand либо сейчас, либо сказать, что добавим в будущем – в зависимости от того, как я делал ранее – в исходниках])
			</p>
			<p>
				(ссылка <a href="https://habrahabr.ru/post/163253">Precision Time Protocol (PTP)</a> дата сохранения 2016-04-12)
			</p>
			<p>
				(для версии с предварительно рассчитанным временем – создать отдельную ветку, и именовать теги иначе, например “a3_v0.3_ft0.1.0”, где “a3_v0.3.0” – коммит, с которого началось разветвление; “ft” – fixed time)
			</p>
			<p>
				Развитие модели.
			</p>
			<p>
				<b>TODO</b>[x]: добавить ссылки на архивы, при этом упомянуть про различия в коде, подробнее про различия см. “<b>TODO</b>[x]” перед “<strong>ссылки на исходники</strong>” после списка спойлеров (с содержимым частей)
			</p>
			<p>
				Ссылки:
			</p>
			<ul>
				<li><a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/releases/download/a1_v0.30.0/03.OMNetProject_v0.9_lltdapp.7z">OMNetProject (v0.9) lltdapp</a></li>
				<li><a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/releases/download/a1_v0.30.0/04.OMNetProject_v0.9.1_lltdapp.7z">OMNetProject (v0.9.1) lltdapp</a></li>
				<li><a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/releases/download/a1_v0.30.0/05.OMNetProject_fixed_event_time_-_v0.9.2_lltdapp.7z">OMNetProject (fixed event time - v0.9.2) lltdapp</a></li>
				<li><a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/releases/download/a1_v0.30.0/06.OMNetProject_v0.9.3_lltdapp.7z">OMNetProject (v0.9.3) lltdapp</a></li>
			</ul>
		</details>
		<details>
			<summary>4: Математика</summary>
			<h1>LLTR Часть 4: Математика</h1>
			<img id="LLTR_a4_habr-pic" alt="Wolfram Mathematica – Numbers (last episode 1 season) – см. на книжку на столе" align="center" height="398" src="https://hsto.org/webt/_y/jp/dp/_yjpdpjfe5izoow0fjvfhnnzbjw.jpeg#mathematica - numbers (last episode 1 season).jpg"/>
			<p>
				Поиск закономерностей и написание формул
			</p>
			<details>
				<summary>∀ habrauser ∈ {user ∈ Habrahabr | user пришедший с хаба “Математика”},</summary>
				<p>
					Существует ненулевая вероятность того, что и в этот раз комментарии к статье окажутся “интереснее” самой статьи.
				</p>
			</details>
			<p>
				(написать, что эта статья посвящена мат. индукции)
			</p>
			<p>
				Ссылки:
			</p>
			<ul>
				<li><a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/releases/download/a1_v0.30.0/09.Get_sequence_math_induction.7z">Get sequence (math induction)</a>, online (Google Spreadsheets):
					<ul>
						<li><a href="https://docs.google.com/spreadsheets/d/1Pt_hziyuut4hnMaCXcLUTYbar06ipSqWL7-N02BvFAk/edit">Sequence</a></li>
						<li><a href="https://docs.google.com/spreadsheets/d/1FOh_LK_f7_tys4tNb0Uc62CHrlgbMah-V-8gP8NpM2k/edit">Convert sequence dstId and srcId to i</a></li>
					</ul>
				</li>
			</ul>
			<p>
				Лучше всего, когда число хостов (hostsCount) – степень двойки. В этом случае получится использовать специальную формулу. Чем эта формула так хороша? (подсказка: одинаковые расстояния)
			</p>
			<p>
				(написать, что я не использую слово “доказательство”, но его смысл включаю в такие слова как {“вывод”,“получение”,“написание”})
			</p>
			<p>
				(в спойлере рассказать про вывод еще одной полезной формулы для быстрого разложения числа (в двоичном виде) на комбинацию [количество единичных бит в числе; номер “битовой перестановки”], и обратной формулы – для быстрого получения n‑й “битовой перестановки”; упомянуть, что они не используются в LLTR, они могут помочь при сжатии данных)
			</p>
			<details>
				<summary>Permutation of bitsets (“lexicographic” order) derivation (mathematical induction)</summary>
				<p>
					(привести пример того, что это _штука_ делает [можно взять пример из таблицы, сказать, что она работает как в прямом направлении, так и в обратном]):
				</p>
				<pre><code class="nohighlight">n=4; k=2
bitset  i
0011 &lt;- 0
0101 &lt;- 1
1001 &lt;- 2
0110 &lt;- 3
1010 &lt;- 4
1100 &lt;- 5</code></pre>
				<p>
					Note: используется лексикографический порядок, т.е. bitset<sup>k</sup><sub>i</sub> &lt; bitset<sup>k</sup><sub>i+1</sub>, где i – номер “битовой перестановки”; k – количество единичных бит; n – количество бит в числе.
				</p>
				<p>
					Где “мясо” (получение формул; функции/код; и программа, которую можно собрать и “распотрошить”/отладить), и с чего лучше начать?
				</p>
				<ul>
					<li>открыть <a href="https://docs.google.com/spreadsheets/d/1EBClwdIeS0cHwFlTYMrCbIfGgSpeiUmG5XP-WxtpgtU/edit">таблицу</a> (обратить внимание на ячейку “B9”) (оказывается “электронные таблицы” бывают полезными O_o; люблю их использовать для визуального наблюдения за числами, и визуального поиска закономерностей)</li>
					<li><a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/releases/download/a1_v0.30.0/10.Get_n-th_Permutation_of_bitsets_AND_vice_versa_math_induction.7z">скачать исходники</a></li>
					<li>изучить “<code>_tmain()</code>” (не обращая внимания за закомментированные куски кода)</li>
					<li>собрать программу, запустить ее, и на основе ее вывода – проверить свои догадки насчет предназначения функций “<code>med()</code>” и “<code>demed()</code>”</li>
				</ul>
				<p>
					Жалко, что это прошло мимо меня:
				</p>
				<ul>
					<li><a href="https://habrahabr.ru/post/276937/#comment_8768131">habrahabr.ru/post/276937/#comment_8768131</a> ( @alisey @Trif )</li>
					<li><a href="https://stackoverflow.com/questions/7918806/finding-n-th-permutation-without-computing-others/24257996#24257996">stackoverflow.com/questions/7918806/finding-n-th-permutation-without-computing-others/24257996#24257996</a>
						<ul>
							<li><a href="https://stackoverflow.com/a/7918978">stackoverflow.com/a/7918978</a>
								<ul>
									<li><a href="https://en.wikipedia.org/wiki/Factorial_number_system?stable=1">en.wikipedia.org/wiki/Factorial_number_system?stable=1</a></li>
									<li><a href="https://en.wikipedia.org/wiki/Lehmer_code?stable=1">en.wikipedia.org/wiki/Lehmer_code?stable=1</a></li>
								</ul>
							</li>
						</ul>
					</li>
				</ul>
				<p>
					Но есть и отличия:<br />
					Здесь используется “битовая перестановка” (“перестановка с повторением”; либо корректнее “Permutations of multisets”).<br />
					В чем отличие? В обычной перестановке повторяющихся элементов нет (пример [abcdef]), но в нашем случае они есть (пример [000011]).<br />
					Если же взять алгоритм генерации перестановок, и ограничится сопоставлением (сделать замену):
				</p>
				<pre><code class="nohighlight">a =&gt; 0
b =&gt; 0
c =&gt; 0
d =&gt; 0
e =&gt; 1
f =&gt; 1</code></pre>
				<p>
					, то ничего не получится, т.к. одним из вариантов перестановки, генерируемых алгоритмом, будет [abcdfe] ⇒ [000011], однако вариант [000011] уже есть в нашем наборе. (следовательно, алгоритм не подходит)
				</p>
				<p>
					Попробуем определить количество вариантов для нашего случая {{000011}}.<br />
					Число всех перестановок {abcdef} равно 6! ( <a href="http://nuclphys.sinp.msu.ru/mathan/p1/m0204.html">nuclphys.sinp.msu.ru/mathan/p1/m0204.html</a> ).<br />
					Исключим из него лишние перестановки.<br />
					Так, например, на каждую уникальную перестановку (например [000011]) будут сгенерированы дубли, (переставляющие единицы (“1”) 2! раз  ×  переставляющие нули (“0”) 4! раз) = 2! × 4! = 2! × (6−2)! .<br />
					В итоге получим количество вариантов для нашего случая = 6! ∕ (2! × (6−2)!) .
				</p>
				<p>
					Эта запись очень напоминает формулу для расчёта числа сочетаний ( <a href="http://nuclphys.sinp.msu.ru/mathan/p1/m0204.html">nuclphys.sinp.msu.ru/mathan/p1/m0204.html</a> ), но по определению ( <a href="https://ru.wikipedia.org/wiki/Сочетание?stable=1">ru.wikipedia.org/wiki/Сочетание?stable=1</a> ) наш случай – это не сочетание. Для нас порядок следования элементов важен. Тогда может это “размещение с повторениями” ( <a href="https://ru.wikipedia.org/wiki/Размещение?stable=1">ru.wikipedia.org/wiki/Размещение?stable=1</a> ), однако в нем нельзя “зафиксировать” конкретное число повторений “1” и “0” – в нем перебираются все возможные варианты повторений ( <a href="https://ru.wikipedia.org/wiki/Размещение?stable=1#Количество_размещений_с_повторениями">ru.wikipedia.org/wiki/Размещение?stable=1#Количество_размещений_с_повторениями</a> ).
				</p>
				<p>
					Пора переключится на EN: сочетания → комбинации → combination: ( k‑combination with repetitions / k‑multicombination / multisubset ), и увидеть пример ( <a href="https://en.wikipedia.org/wiki/Combination?stable=1#Example_of_counting_multisubsets">en.wikipedia.org/wiki/Combination?stable=1#Example_of_counting_multisubsets</a> ), использующий “Stars and Bars” ( <a href="https://en.wikipedia.org/wiki/Stars_and_bars_(combinatorics)?stable=1#Proofs_via_the_method_of_stars_and_bars">en.wikipedia.org/wiki/Stars_and_bars_(combinatorics)?stable=1#Proofs_via_the_method_of_stars_and_bars</a> ). Что позволяет представить двоичную запись числа в виде звездочек и ящичков (границ/перегородок ящичков): “1” – Star, а “0” – Bar.
				</p>
				<p>
					Вот так, через “Stars and Bars” были связаны “сочетания” (и “сочетания с повторением” – k‑combination with repetitions) с “перестановками с повторением” (permutations of multisets): <a href="https://en.wikipedia.org/wiki/Permutation?stable=1#Permutations_of_multisets">en.wikipedia.org/wiki/Permutation?stable=1#Permutations_of_multisets</a> .<br />
					Возвращаясь на RU: <a href="https://ru.wikipedia.org/wiki/Перестановка?stable=1#Перестановки_с_повторением">ru.wikipedia.org/wiki/Перестановка?stable=1#Перестановки_с_повторением</a>
				</p>
				<p>
					P.S. код из ответа <a href="https://stackoverflow.com/a/24257996">stackoverflow.com/a/24257996</a> генерирует не варианты Перестановок, а варианты Размещений ( Перестановка – частный случай Размещения: n!∕((n−k)!); n⩵k; (n−k)!⇒1; n! ).
				</p>
				<p>
					P.P.S. [скорее обращение к @alisey и @Trif] если раньше где‑нибудь в сети встречали похожий алгоритм/код (для “Permutations of multisets”), то можете оставить ссылки в <a href="https://habr.com/post/421243/#comments">комментариях</a>?
				</p>
			</details>
		</details>
		<details>
			<summary>5: OMNeT++ продолжение 2</summary>
			<h1>LLTR Часть 5: OMNeT++ продолжение 2</h1>
			<p>
				Почти все готово
			</p>
			<p>
				(нужно еще адаптировать LLTR-Process под новую sequence, вначале сделать простой вариант – просто переупорядочим новые данные под старую последовательность {именно этот вариант находится в “LLTD-Process (vFinal)”}, а затем сделать вариант получше – без переупорядочивания данных, просто заменить в нужном месте формулу расчета i → dstId, а предыдущий вариант можно использовать в качестве теста для улучшенного варианта)
			</p>
			<p>
				Ссылки:
			</p>
			<ul>
				<li><a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/releases/download/a1_v0.30.0/07.OMNetProject_v0.9.4_lltdapp.7z">OMNetProject (v0.9.4) lltdapp</a></li>
				<li><a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/releases/download/a1_v0.30.0/08.OMNetProject_vFinal_lltdapp.7z">OMNetProject (vFinal) lltdapp</a></li>
				<li><a href="https://github.com/ZiroKyl/LLTR-Process/releases/download/vEnd/LLTD-Process_vFinal.7z">LLTD-Process (vFinal)</a></li>
			</ul>
		</details>
		<details>
			<summary>6+7: Реализация + Эксперимент</summary>
			<h1>LLTR Часть 6: Реализация</h1>
			<p>
				Таймеры и счетчики систем, программа на Golang.
			</p>
			<p>
				Ссылки:
			</p>
			<ul>
				<li><a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/releases/download/a1_v0.30.0/11.Timers_QPC.7z">Timers (QPC)</a></li>
			</ul>
			<h1>LLTR Часть 7: Эксперимент (название: “в конце Джон умрет” – фильм)</h1>
			<p>
				(Что делать если для эксперимента нужно минимум 4 сетевых устройства {без учета свитчей/роутеров/Wi‑Fi}, а у вас их только 3 и больше ничего нет? Сделать из одного из устройств – 2 устройства! Один из устройств – MacBook, у которого есть Wi‑Fi и Ethernet через Thunderbolt)
			</p>
			<p>
				(Если собрать стенд из того, что “лежит под рукой”, то можно узнать много нового о том, что “лежит под рукой”)
			</p>
			<p>
				(Проблема с Wi‑Fi и UDP broadcast пакетами – ограничение скорости на уровне <abbr title="Wireless Network Interface Card">WNIC</abbr>/прошивки/драйвера. Подробнее: <a href="https://superuser.com/q/946539">How to override wifi broadcast speed limit?</a>, <a href="https://networkengineering.stackexchange.com/q/1782">Why does my UDP Broadcast wireless communication is capped at 1MBs?</a>. В моем случае ограничение было либо 3 Mbps, либо 5 Mbps {точно уже не помню}. В итоге MacBook {Wi‑Fi интерфейс} стал Super‑хостом, только теперь он отправляет не broadcast‑пакеты, а unicast, а промежуточное сетевое устройство {Wi‑Fi-роутер или свитч‑роутер} преобразует unicast‑пакеты в broadcast {не передавая его назад – на Wi‑Fi}. В общем, с Wi‑Fi-роутером не получилось – CPU был слишком слаб для такой скорости. Поэтому пришлось делать это на свитч‑роутере.)
			</p>
			<p>
				(Почему используется такой большой размер UDP‑пакета, он же будет фрагментироваться!? Ответ: для Windows используется “блокирующая” запись в сокет {Windows ждет пока драйвер NIC не сообщит об успешной отправке?..}, к этому добавляются накладные расходы на частый вызов API, “съедающие CPU” {в Win8 был добавлен новый API, который в том числе минимизирует операции копирования данных… (см. ссылки в “LLTD/flood/main.go”)}. К тому же придется использовать таймер с “высоким разрешением”. Поэтому самое простое решение – одним вызовом API сразу отправляем большую порцию данных, которой должно хватить до следующего “тика” таймера. А в *nix запись асинхронная {моментальный возврат после вызова API}, можно использовать обычный размер пакета, и в каждом “тике” таймера делать несколько отправок данных {см. комментарии в “LLTD/flood/main.go”}. В тему: “<a href="http://burntchrome.blogspot.ru/2016/09/iperf3-and-microbursts.html">iperf3 and microbursts</a>”)
			</p>
			<p>
				(В ходе эксперимента исходники постоянно менялись → нужно синхронизовать изменения между ПК. Для этого просто использовался файловый сервер {один из ПК; SMB}: менялись исходники → собирались под все платформы → копировались на файловый сервер → MacBook создавал локальную копию. Все ПК запускали локальную копию, чтобы минимизировать влияние на сеть во время эксперимента.)
			</p>
			<p>
				(описание подготовки окружения для эксперимента находится в файле “LLTD/Prepare test environment.txt”)
			</p>
			<p>
				Ссылки:
			</p>
			<ul>
				<li><a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/releases/download/a1_v0.30.0/12.GoLLTD.7z">GoLLTD</a></li>
			</ul>
			<p>
				(часть собранной статистики находится в файле “LLTD/Client.go”, а статистики “по‑отдельности” – внизу “LLTD/flood/main.go”)
			</p>
			<p>
				(также на одном из ПК {Client1} NIC и раньше не любил, когда его закидывают большим числом пакетов – мог спонтанно отключиться, и помогало только полное обесточивание, то теперь я научился “по желанию” выводить его из строя: строчка в статистике “ interface always dead”)
			</p>
			<p>
				Note: Джон – Wi‑Fi роутер (точнее ADSL‑модем/роутер, в котором отпала необходимость в ADSL и роутер части – используется как точка доступа)
			</p>
			<p>
				Note: Со свитчом‑роутером тоже не получилось: он спокойно “переваривает” 100 Mbps входящего unicast трафика; он может спокойно сам генерировать 100 Mbps broadcast трафика. Но у него не получается делать это одновременно (по крайне мере, если использовать те правила/настройки, которые я задал)
			</p>
		</details>
		<p>
			<b>TODO</b>: Эксперимент с форматом статьи: одну из статьей опубликовать в виде комментариев к статье (каждый абзац – отдельный комментарий; можно оставлять комментарий сразу же к конкретному абзацу; можно будет даже голосовать +1/−1 за конкретный абзац). Это будет похоже на Google Wave, или на комментарии в Google Docs, или на контекстные комментарии Discus. Формат:
		</p>
		<ul>
			<li>текст до ката – как обычно</li>
			<li>после ката – пояснить, что статья в комментариях</li>
			<li>комментарии:
				<ul>
					<li>каждый абзац в отдельном комментарии</li>
					<li>раздел для комментариев, не связанных с конкретным абзацем (т.е. для обычного обсуждения) – создать комментарий с текстом “Комментарии” или “Для комментариев” – по идее все обычные комментарии должны быть дочерними к этому комментарию (т.е. создаваться “Ответом” на этот комментарий)</li>
				</ul>
			</li>
		</ul>
		<p>
			Также нужно будет создать UserJS/UserCSS, скрывающий все, кроме первого уровня комментариев, т.е. комментариев, содержащих саму статью.
		</p>
		<p>
			Также такой формат повлияет и на содержимое статьи – на размер ее абзацев – они должны быть крупными, чтобы UI комментариев (ник, аватарка, дата) встречались как можно реже (если будут встречаться часто, то взгляд будет постоянно о них “спотыкаться”). Либо уменьшить “шум” от этих элементов при помощи UserCSS. И все же я думаю, что не стоит их полностью убирать, чтобы оставалось ощущение, что находишься в комментариях (в иерархии комментариев), и можешь задать вопрос (оставить комментарий) прямо здесь (на месте).
		</p>
		<p>
			Через некоторое время продублировать содержимое статьи (из комментариев) в спойлере (в тексте после ката). В основном это нужно для мобильной версии хабра (основные мобильные браузеры вроде бы не поддерживают UserJS и UserCSS; Opera Presto поддерживала, Firefox тоже вроде поддерживает)
		</p>
		<p>
			Оптимальный кандидат для эксперимента – статья “<nobr>OMNeT++</nobr> продолжение 2”.
		</p>
		<p>
			<b>TODO</b>[x]: при вставке ссылок на исходники представить их в виде веток (дерева) + добавить комментарии, что в них было сделано + комментарий, про то, что это создавалось на старой версии <nobr>OMNeT++</nobr> v5.0b1 и INET v3.0.0 + сказать про то, что для статей я переписывал исходники (менял название переменных), и чтобы легче было ориентироваться – указать какие старые исходники соответствуют каким коммитам/тегам в репозитории
		</p>
		<p>
			<strong>Ссылки на исходники</strong>:
		</p>
		<ul>
			<li><a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/releases/download/a1_v0.30.0/01.OMNetProjectLLTD_lltdapp_+_sim.7z">OMNetProjectLLTD lltdapp + sim</a> – в то время LLTR не имел своего названия, и я его называл просто “LLTD” (“R” – это “D”, у которой выросли ножки/ветки/корни) [примерно соответствует последнему коммиту из “Часть 1”, т.е. ветке <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/tree/article_1">article_1</a> и тегу a1_v0.30.0 <img alt="git" width="19" height="19" src="https://hsto.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/>] {по датам в архиве можно посмотреть, когда что делал}</li>
			<li><a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/releases/download/a1_v0.30.0/02.OMNetProject_before_v0.9_lltdapp.7z">OMNetProject (before v0.9) lltdapp</a> – небольшие правки (“LLTDClient.cc”: исправил опечатку, и перешел на использование DISCARD‑порта для “разогрева” ARP) [также примерно соответствует ветке <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/tree/article_1">article_1</a>] {добавил в архив директорию “for diff (LLTR)” – сравнив (diff) ее содержимое с содержимым родительской директории, можно увидеть, как были переименованы переменные}</li>
			<li><a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/releases/download/a1_v0.30.0/03.OMNetProject_v0.9_lltdapp.7z">OMNetProject (v0.9) lltdapp</a> – изменена логика остановки подсчета количества принятых пакетов (“LLTDClient.cc”: “<code>trafCount[stepN]++</code>”): добавлено ограничение по времени (см. “<code>timeCalcEnd</code>” и “<code>timeoutCalc</code>”), что хорошо отразилось на статистике (“stat.txt”: увеличился контраст) [Часть 3] {за кадром остается “как я понял, что нужно сделать именно это”, т.е. что нужно увидеть, чтобы прийти к такому решению}</li>
			<li><a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/releases/download/a1_v0.30.0/11.Timers_QPC.7z">Timers (QPC)</a> – самое полезное в нем – это ссылки (в “Timers.cpp”; в частности на “<a href="http://www.windowstimestamp.com/description#C_part2">The Windows Timestamp Project: Adjustment of System Time (NTP)</a>”) [Часть 6] {по хронологии это должно быть здесь, после первой реализацией на Golang, но я решил все это перенести в “Часть 6”}</li>
			<li><a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/releases/download/a1_v0.30.0/04.OMNetProject_v0.9.1_lltdapp.7z">OMNetProject (v0.9.1) lltdapp</a> – несколько изменений, основное из них: добавлена синхронизация времени (“LLTDClient.cc”: “<code>sntpTimeOffset</code>” и “<code>sntpLatency</code>” – эти значения пока не используются, но пригодятся в будущем) [Часть 3]</li>
			<li>“fixed event time” ответвление – предрассчитал время наступления каждого события:
				<ul>
					<li><a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/releases/download/a1_v0.30.0/05.OMNetProject_fixed_event_time_-_v0.9.2_lltdapp.7z">OMNetProject (fixed event time - v0.9.2) lltdapp</a> – много изменений, основные улучшения описаны в “stat.txt” [Часть 3]</li>
				</ul>
			</li>
			<li><a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/releases/download/a1_v0.30.0/06.OMNetProject_v0.9.3_lltdapp.7z">OMNetProject (v0.9.3) lltdapp</a> – v0.9.1 + доделка синхронизации времени, и использование ее + улучшения из v0.9.2ft [Часть 3]</li>
			<li><a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/releases/download/a1_v0.30.0/09.Get_sequence_math_induction.7z">Get sequence (math induction)</a> – получение формул для новой последовательности сканирования сети: unicast_src_host<sub>i+1</sub> = unicast_dst_host<sub>i</sub>, т.е. хост, который сейчас принимает трафик (unicast dst), станет хостом, испускающим трафик (unicast src) [Часть 4] {одно из преимуществ этой последовательности можно увидеть, сравнив места возникновения “заторов” (наполнение буфера в свитчах) в двух рядом стоящих итерациях – теперь “затор” не будет возникать два раза подряд в одном и том же месте, что благоприятно скажется на: “самочувствии сети” (средней задержке прохождения пакета), и, соответственно, на качество собираемой статистики}</li>
			<li><a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/releases/download/a1_v0.30.0/07.OMNetProject_v0.9.4_lltdapp.7z">OMNetProject (v0.9.4) lltdapp</a> – в основном: использование новой последовательности сканирования сети, и несколько “хаков для <abbr title="Объектно‑ориентированное программирование">ООП</abbr>” [Часть 5]</li>
			<li><a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/releases/download/a1_v0.30.0/08.OMNetProject_vFinal_lltdapp.7z">OMNetProject (vFinal) lltdapp</a> – рефакторинг [Часть 5]</li>
			<li><a href="https://github.com/ZiroKyl/LLTR-Process/releases/download/vEnd/LLTD-Process_vFinal.7z">LLTD-Process (vFinal)</a> – адаптация под новую последовательность сканирования сети [Часть 5]</li>
			<li><a href="https://github.com/ZiroKyl/LLTR-Simulation-Model/releases/download/a1_v0.30.0/12.GoLLTD.7z">GoLLTD</a> – старая реализация на Go (“LLTD/old/main.old.go”) + новая реализация + описание подготовки окружения для эксперимента (“LLTD/Prepare test environment.txt”) + промежуточные инструменты, последовательность просмотра: “Timers/”, “SNTP/”, “LLTD/flood/broadcast.txt”, “LLTD/Prepare test environment.txt”, “LLTD/flood/old/main.go”, “LLTD/flood/main.go”, “LLTD/” [Часть 6,7]</li>
		</ul>
		<p>
			В предыдущих статьях (<em>частях</em>) были фотографии стикеров (листочков), на которых я делал заметки. Я называю их “заметки перед сном” – записи идей, родившихся во время засыпания.
		</p>
		<p>
			<font color="#54524F"><b>Note</b>:</font> пока я не запишу идею – я не могу заснуть, а самый быстрый (в это время) способ сохранить идею – нарисовать на листочке.
		</p>
		<p>
			К каждой <em>части</em> я хотел добавлять соответствующие “заметки перед сном”, либо сфотографировав, либо нарисовав “в векторе”.
		</p>
		<p>
			Все “заметки перед сном”, за исключением тех, фотографии которых уже были в предыдущих частях:
		</p>
		<a href="https://hsto.org/webt/ka/vm/ni/kavmnigbvpq8jlsgnlhe-lmjyzk.jpeg#stickers-other.jpg"><img id="fig_stickers-other" alt="Стикеры: просто стикеры и TOP SECRET" title="формат: ‹одна сторона› ‹обратная сторона›" align="center" height="820" src="https://hsto.org/webt/ka/vm/ni/kavmnigbvpq8jlsgnlhe-lmjyzk.jpeg#stickers-other.jpg"/></a>
		<p>
			В каждой строке – скан одного и того же листочка с двух сторон. В тех случаях, когда на обратной стороне не было полезной информации – заполнял пробел “случайной заметкой”.
		</p>
		<p>
			<font color="#54524F"><b>Note</b>:</font> “кулер” – хотел рассчитать соотношение теплоотвода (теплового сопротивления<sup>−1</sup>) к шуму (звуковому давлению) для такой конструкции и ее вариаций (например: тепловые трубки смещены к центру; основная крыльчатка находится снаружи; поток воздуха от центра – наружу); “хабра‑карма‑кластеры‑сообщества” – (представляя гиперповерхность) локальных экстремумов много, и было бы удобно видеть только то, что позволит тебе достигнуть ближайший экстремум как можно быстрее (чтобы начать путь к следующему экстремуму), и скрывать все, что будет перетягивать в другой локальный экстремум {а чтобы была возможность выбраться из “пузыря” (локального экстремума) – сделать карту кластеров, при клике в которой, можно посмотреть “а что там у других?”; + ситуация “хочу посмотреть статьи 'для меня', но не хочу логинется а чужом устройстве”, решение: отдельный идентификатор пользователя (cookie) для режима view‑only}
		</p>
		<p>
			<font color="#54524F"><b>Note</b>:</font> заметки расположены в хронологическом порядке (сверху‑вниз)
		</p>
		<details>
			<summary>А также текстовые заметки</summary>
			<p>
				LLTD v1 – с синхронизацией по TCP (нужен map?), сбор статистики в процессе,<br />
				и прикрутить отсечение лишних (симметричных) зондирований, если зондирование в одном направлении уже дало результат
			</p>
			<p>
				LLTD v0.9 – на client собирать статистику в текущей итерации не до прихода следующего синхросигнала, а до истечения времени (и прихода синхросигнала)
			</p>
			<p>
				либо сделать тестовую реализацию v0.5 на Go<br />
				для определения IP, в будущем переписать <a href="https://github.com/hashicorp/mdns">github.com/hashicorp/mdns</a><br />
				<a href="https://github.com/davecheney/mdns">github.com/davecheney/mdns</a><br />
				<a href="http://grokbase.com/t/gg/golang-nuts/132tcpawde/go-nuts-udp-multicast-who-is-on-my-network">grokbase.com/t/gg/golang-nuts/132tcpawde/go-nuts-udp-multicast-who-is-on-my-network</a>
			</p>
			<p>
				P.S. при рандомизации таймеров (в модели) использовать “нормальное распределение”.<br />
				r=rand();<br />
				Взять количество единичных бит у r, и функцию расчета номера перестановки бит при заданном числе бит.<br />
				Сделать два варианта:<br />
				1. нормально‑ступенчатое распределение. Количество единичных бит дает нормальное распределение, а номер перестановки – равномерное. Берем количество единичных бит за основу случайного числа + уточняем его при помощи +/- номера перестановки (с масштабированием в пределах текущей “ступеньки” нормального распределения).<br />
				2. “мешанина”. Берем номер перестановки за основу (при этом учитываем, что диапазон его значений всегда разный и зависит количества единичных бит; поэтому его надо масштабировать на весь диапазон случайного числа) + уточняем его количеством единичных бит (отмасштабированным в пределах текущей “ступеньки” равномерного распределения)
			</p>
			<p>
				iperf3 and microbursts <a href="http://burntchrome.blogspot.ru/2016/09/iperf3-and-microbursts.html">burntchrome.blogspot.ru/2016/09/iperf3-and-microbursts.html</a>
			</p>
		</details>
		<h3 id="check-list--todo"><a href="#check-list--todo" title="Ссылка на раздел"><font color="gray">#</font></a> Check‑list (TODO's)</h3>
		<p>
			Мои TODO, которые я использовал при подготовке статей.
		</p>
		<p>
			Подготовка PNG{SVG} (SVG с <em>thumbnail</em> в виде PNG) изображений:
		</p>
		<ol>
			<li>PNG:
				<ol type="a">
					<li>[если ширина изображения превышает 778px, 756px] придется где‑нибудь подрезать (подробнее см. в <a href="#any-img-prep">этапах подготовки любых изображений</a>)</li>
					<li>добавить метку‑иконку 7z (un[7z]me), расположить в наиболее не отвлекающем месте (главное – чтобы не “висело в воздухе”, а было продолжением какой‑либо группы объектов, но при этом было визуально‑логически отделено от нее)
						<ul>
							<li>[если иконка добавлялась в Photoshop] для сохранения использовать “Save for Web” → PNG 24+alpha</li>
							<li>[если иконка добавлялась в GIMP] экспортировать в “8bpc RGBA” (все <a href="https://docs.gimp.org/en/gimp-images-out.html#file-png-save-defaults">остальные опции</a> можно отключить), либо аналогичный режим в “<a href="http://registry.gimp.org/node/33">Save for Web</a>”</li>
						</ul>
					</li>
					<li>уменьшить количество цветов до 256 + alpha‑прозрачность
						<ul>
							<li>[если есть Adobe Fireworks] (<kbd>Ctrl+Shift+X</kbd>) → PNG‑8 + alpha</li>
							<li>[иначе]
								<ul>
									<li><a href="https://pngmini.com">ImageAlpha</a> (<a href="https://pngquant.org">pngquant</a>+<a href="http://sourceforge.net/projects/pngnqs9/">pngnq-s9</a>+<a href="https://github.com/kornelski/mediancut-posterizer">posterizer</a>)</li>
									<li><a href="http://x128.ho.ua/color-quantizer.html">Color Quantizer</a></li>
								</ul>
							</li>
						</ul>
					</li>
					<li>“дожать” изображения, используя <a href="https://habrahabr.ru/post/121096">Image Catalyst</a> (я “параллельно” использовал 2 версии: <a href="http://rgho.st/35627692">2.1</a> и <a href="https://github.com/lorents17/iCatalyst/releases/tag/2.5">2.5</a>, а затем оставлял файл минимального размера):
						<ol type="I">
							<li>“закинуть” копию изображений в <a href="http://forum.ru-board.com/topic.cgi?forum=4&topic=4263&start=220#8">Image</a> <a href="https://habrahabr.ru/post/135109">Catalyst</a> <a href="http://rgho.st/35627692">2.1</a> ([5] Xtreme profile)
								<details>
									<summary>Tools\config.ini</summary>
									<pre><code class="ini">[options]
;Если Вы не хотите оптимизировать изображения в подпапках указанной папки, то замените значение &quot;true&quot; на &quot;false&quot;.
fs = true

;Количество одновременных потоков обработки PNG. Если указано значение 0, то выбирается значение равное системной переменной %NUMBER_OF_PROCESSORS%.
threatpng = 0

;Обновление проекта. Если Вы не хотите автоматически проверять доступность новой версии проекта, то замените значение &quot;true&quot; на &quot;false&quot;.
up = false

[JPEG]
;Удаление Metadata. Если Вы не хотите удалять определенные Metadata в JPEG, то замените значение &quot;true&quot; на &quot;false&quot; там, где это необходимо.
dc = true    ;Delete comment field (as left by progs like Photoshop &amp; Compupic).
de = true    ;Strip Exif section (smaller JPEG file, but lose digicam info).
di = true    ;Delete IPTC section (from Photoshop, or Picasa).
dx = true    ;Deletex XMP section.
du = true    ;Delete non image sections except for Exif and comment sections.

[PNG]
;Оптимизация ColorType и BitDepth. Если Вы не хотите изменять ColorType и BitDepth в PNG, то замените значение &quot;true&quot; на &quot;false&quot;.
nc = true

;Оптимизация альфа-канала. Если Вы не хотите применять систему &quot;Dirty Transparency&quot; для PNG c альфа-каналом, то замените значение &quot;true&quot; на &quot;false&quot;.
na = true

;Удаление Chunks.
;Если Вы хотите удалить определенные Chunks или группы Chunks, то пропишите &quot;remove&quot; без кавычек и через запятую те Chunks или группы Chunks, которые хотите удалить.
;Если Вы хотите оставить определенные Chunks или группы Chunks, то пропишите &quot;keep&quot; без кавычек и через запятую те Chunks или группы Chunks, которые хотите оставить.
;Группы Chunks:
;text  = iTXt,tEXt,zTXt
;color = cHRM,sRGB,iCCP,gAMA
;misc  = bKGD,pHYs,sBIT,sPLT,hIST,tIME
;all   = all of noncritical chunks
сhunks = remove all</code></pre>
									<p>
										<font color="#54524F"><b>Note</b>:</font> если он выводит “<a href="https://habrahabr.ru/post/135109/#comment_4542924">Image Catalyst 2.1 уже запущен. Для выхода из приложения нажмите на Enter.</a>”, хотя это не так, то переименуйте папку, в которой он находится (я переименовал “Image Catalyst 2.1” в “Image-Catalyst-2.1”)
									</p>
								</details>
							</li>
							<li>“закинуть” копию изображений в <a href="https://habrahabr.ru/post/215213">Image Catalyst</a> <a href="https://github.com/lorents17/iCatalyst/releases/tag/2.5">2.5</a> ([1] Xtreme profile)
								<details>
									<summary>Tools\config.ini</summary>
									<pre><code class="ini">[options]
;Number of streams. If value early 0, is used value of parameter %NUMBER_OF_PROCESSORS%.
thread=0

;Automatic replacement of original images by the optimized.
outdir=true

;Check update
update=false

[PNG]
;Parameters of optimization of PNG:
;/a# - PNG dirty transparency 0=Clean, 1=Optimize;
;/g# - PNG gamma 0=Remove, 1=Apply &amp; Remove, 2=Keep;
;/na - PNG don't change RGB values for fully transparent pixels;
;/nc - PNG don't change ColorType and BitDepth;
;/np - PNG don't change Palette.
xtreme=/a1 /g0
advanced=/a0 /g0

;Remove PNG Metadata (Chunks).
chunks=true

[JPEG]
;Remove JPEG Metadata.
metadata=true

[GIF]
;Remove GIF Metadata.
giftags=true</code></pre>
									<p>
										<font color="#54524F"><b>Note</b>:</font> если он выводит “<a href="https://habrahabr.ru/post/135109/#comment_4542924">Attention: running 2 of Image Catalyst.</a>”, хотя это не так, то переименуйте папку, в которой он находится (я переименовал в “iCatalyst-2.5”)
									</p>
								</details>
							</li>
							<li>оставить файлы наименьшего размера
								<a name="merge_min-bat"></a><details>
									<summary>merge_min.bat</summary>
									<pre><code class="bat">@echo off
setlocal enabledelayedexpansion

:: Copy file from source to destination directory only if
:: source file is smaller in size than in destination directory

echo Src dir: %~f1
echo Dst dir: %~f2

echo ---

for /r &quot;%~1&quot; %%A in (*) do (
  set FileA=%%~fA
  set FileB=!FileA:%~f1=%~f2!

  set FileASize=%%~zA
  for %%Z in (&quot;!FileB!&quot;) do set FileBSize=%%~zZ

  if !FileASize! LSS !FileBSize! copy &quot;!FileA!&quot; &quot;!FileB!&quot;
)</code></pre>
								</details>
							</li>
						</ol>
					</li>
					<li>добавить “.svg” после имени файлов (перед расширением) – будет влиять на расширение файла (SVG) после его распаковки (un[7z]me)</li>
				</ol>
			</li>
			<li>SVG:
				<ol type="a">
					<li>экспортировать с настройками {SVG 1.1; UTF-8; стили внутри файла; единица измерения: пиксели; точность: “1:100”; текст преобразовать в кривые} (если до этого была выбрана другая <em>единица измерения</em>, то придется экспортировать 2 раза – в 1‑й раз будут установлены неверные размеры)</li>
					<li>избавится от всех transform в созданном SVG (в основном они создаются после поворота прямоугольника на 90 градусов) (для ускорения поиска можно экспортировать в SVG содержимое всей страницы):
						<ol type="I">
							<li>в браузере в DevTools найти все объекты с transform (используя селектор “<code>[transform]</code>”)</li>
							<li>убрать поворот в исходнике при помощи макроса “<code>Rotate90AndSwapWH()</code>” (я поместил его в “глобальные макросы”)
								<details>
									<summary>Rotate90AndSwapWH()</summary>
									<pre><code class="purebasic">Sub Rotate90AndSwapWH()
    Dim sr As ShapeRange, s As Shape, w#, h#
    Set sr = ActiveSelectionRange

    On Error Resume Next

    boostStart2 &quot;Rotate 90 and Swap W-H&quot;
    For Each s In sr
        s.GetSize w, h
        s.Rotate -90
        s.SetSizeEx s.CenterX, s.CenterY, w, h
    Next s
    boostFinish2
End Sub</code></pre>
									<p>
										+ boostStart2/boostFinish2:
									</p>
									<ul>
										<li><a href="https://github.com/cdrpro-macros/cdr-tools/blob/master/source/sToolsBoost.bas">github.com/cdrpro-macros/cdr-tools/blob/master/source/sToolsBoost.bas</a></li>
										<li><a href="https://cdrpro-forum-archive.github.io/node/2706.html">Как ускорить работу макросов в CorelDRAW</a></li>
									</ul>
									<p>
										Я их немного изменил:
									</p>
									<pre><code class="purebasic">Private Sub boostStart2(ByVal unDo$)
    On Error Resume Next
    ActiveDocument.BeginCommandGroup unDo
    Optimization = True
    EventsEnabled = False
End Sub
Private Sub boostFinish2()
    On Error Resume Next
    EventsEnabled = True
    Optimization = False
    ActiveWindow.Refresh
    ActiveDocument.EndCommandGroup
    'Refresh
End Sub</code></pre>
								</details>
							</li>
						</ol>
					</li>
					<li>перед финальным экспортом добавить <em>корректирующий положение и размер прямоугольник</em>:
						<ul>
							<li>залить его белым</li>
							<li>без абриса</li>
							<li>он должен:
								<ul>
									<li>покрывать все пиксели изображения (причем его размеры [ширина, высота] должны быть четными числами)</li>
									<li>быть привязан к пиксельной сетке (к краю пикселя)</li>
								</ul>
							</li>
							<li>перенести на задний план</li>
						</ul>
					</li>
					<li>экспортировать (с описанными выше настройками)</li>
					<li>подправить XML (добиться соответствия по структуре с уже экспортированными файлами)
						<ol type="I">
							<li>скопом (во всех файлах):
								<ul>
									<li>заменить “<code>DOCTYPE</code>” и комментарий “<code>Creator</code>” на комментарий “<code>96ppi</code>” (именно таким должен быть ppi у документа в CorelDRAW перед импортом в него этого SVG)</li>
									<li>стереть “<code>metadata</code>”, “<code>id</code>” (у внешней группы)</li>
									<li>в атрибутах тега svg:
										<ol>
											<li>стереть “<code>xmlns</code>” и “<code>xml:space</code>”</li>
											<li>стереть “<code>xmlns:xlink</code>”</li>
											<li>[проверить, что в “<code>style</code>” во всех файлах есть “<code>fill-rule:evenodd; clip-rule:evenodd</code>”] заменить “<code>version</code>” и “<code>style</code>” на `<code>style=&quot;margin:16px auto&quot; shape-rendering=&quot;geometricPrecision&quot; fill-rule=&quot;evenodd&quot; clip-rule=&quot;evenodd&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; baseProfile=&quot;full&quot;</code>`</li>
										</ol>
									</li>
									<li>заменить (убрать пробел) `<code> &quot;</code>` на `<code>&quot;</code>`</li>
								</ul>
							</li>
							<li>удалить <em>корректирующий прямоугольник</em> (он будет первым &lt;rect&gt; в &lt;g&gt;), проверив, что его размеры соответствуют размерам “<code>viewBox</code>” (в &lt;svg&gt;)
								<ul>
									<li>проверить, как SVG выглядит в браузере, и как выглядит после импорта в CorelDRAW – все должно быть четким, если края объектов получились размытыми, то это означает, что <em>корректирующий прямоугольник</em> не был корректно расположен (придется исправить его положение в исходнике, и повторить предыдущие пункты заново)</li>
								</ul>
							</li>
							<li>оптимизировать в <a href="http://petercollingridge.appspot.com/svg-optimiser">SVG optimiser</a>:
								<ul>
									<li>настройки:
										<ul>
											<li>Whitespace: pretty</li>
											<li>Style type: optimal</li>
											<li>Truncate * numbers: unchanged</li>
											<li>включить все опции (если нужно сохранить группы, то отключить “Remove clean group”, и затем вручную убрать одноэлементные группы)</li>
										</ul>
									</li>
									<li>не заменять оригинальные атрибуты тега &lt;svg&gt;</li>
									<li>не заменять содержимое тега &lt;style&gt; – в нем SVG optimiser только убирает CDATA (не изменяя сами стили)</li>
								</ul>
							</li>
							<li>отформатировать XML</li>
						</ol>
					</li>
				</ol>
			</li>
			<li>Объединить PNG со сжатым SVG:
				<ol type="a">
					<li>воспользоваться “PNG_SVG.bat” (лучшие параметры 7-Zip для сжатия SVG: “<code>-txz -m0=LZMA2:lc1:pb0 -mx</code>”)
						<details>
							<summary>PNG_SVG.bat</summary>
							<pre><code class="bat">@echo off
setlocal enabledelayedexpansion

:: PNG+7Zip{SVG}

echo PNG dir: %~f1
echo SVG dir: %~f2

echo ---

for /r &quot;%~2&quot; %%A in (*.svg) do (
  set SVG=%%~fA
  set PNG=!SVG:%~f2=%~f1!.png

  &quot;%ProgramFiles%\7-Zip\7z.exe&quot; a dummy -txz -m0=LZMA2:d96m:fb74:lc1:pb0 -mx -so -- &quot;!SVG!&quot; &gt;&gt; &quot;!PNG!&quot;
)</code></pre>
							<p>
								Как была получена “<code>LZMA2:d96m:fb74:lc1:pb0</code>”?
							</p>
							<p>
								Параметры подбирались слева‑направо (для “RingSync_no_problem.svg”):
							</p>
							<pre><code class="nohighlight">- &quot;LZMA2:d96m:fb64&quot;         6804 byte
- &quot;LZMA2:d96m:fb74&quot;         6800 byte
- &quot;LZMA2:d96m:fb74:lc2&quot;     6812 byte
- &quot;LZMA2:d96m:fb57:lc2&quot;     6780 byte
- &quot;LZMA2:d96m:fb57:lc1&quot;     6768 byte
- &quot;LZMA2:d96m:fb56:lc1&quot;     6760 byte
- &quot;LZMA2:d96m:fb49:lc1&quot;     6760 byte
- &quot;LZMA2:d96m:fb56:lc1:pb0&quot; 6696 byte
- &quot;LZMA2:d96m:fb46:lc1:pb0&quot; 6688 byte (fb44-fb47)
- &quot;LZMA2:d96m:fb63:lc1:pb0&quot; 6688 byte
- &quot;LZMA2:d96m:fb66:lc1:pb0&quot; 6684 byte
- &quot;LZMA2:d96m:fb74:lc1:pb0&quot; 6692 byte</code></pre>
							<p>
								Для всех остальных svg размер сравнивался с “<code>LZMA2:d96m</code>” (fb64), и “<code>LZMA2:d96m:fb74:lc1:pb0</code>” всегда был меньше.
							</p>
						</details>
					</li>
				</ol>
			</li>
		</ol>
		<p>
			<font color="#54524F"><b>Note</b>:</font> я использую немного измененный Image Catalyst: заменил ping на timeout, и сделал (для версии 2.5) вывод размера в байтах (как было в версии 2.1 – для возможности сравнения размеров между этими двумя версиями)
		</p>
		<details>
			<summary>Image Catalyst.bat</summary>
			<p>
				v2.1 diff:
			</p>
			<pre><code class="patch">182c182
&lt; if defined thrt &gt;nul 2&gt;&amp;1 ping -n 1 -w 500 127.255.255.255 &amp; goto:waithreat
---
&gt; if defined thrt &gt;nul 2&gt;&amp;1 timeout /t 1 /nobreak &amp; goto:waithreat
203c203
&lt; 1&gt;nul 2&gt;&amp;1 ping -n 1 -w 500 127.255.255.255
---
&gt; 1&gt;nul 2&gt;&amp;1 timeout /t 1 /nobreak
237c237
&lt; if exist &quot;%~1&quot; (1&gt;nul 2&gt;&amp;1 ping -n 1 -w 500 127.255.255.255 &amp; goto:waitflag)
---
&gt; if exist &quot;%~1&quot; (1&gt;nul 2&gt;&amp;1 timeout /t 1 /nobreak &amp; goto:waitflag)
513c513
&lt;      if exist &quot;%tmppath%\typelog.lck&quot; (1&gt;nul 2&gt;&amp;1 ping -n 1 -w 500 127.255.255.255 &amp; goto:savelog)
---
&gt;      if exist &quot;%tmppath%\typelog.lck&quot; (1&gt;nul 2&gt;&amp;1 timeout /t 1 /nobreak &amp; goto:savelog)
534c534
&lt; if &quot;%jpeg%&quot; equ &quot;0&quot; if &quot;%png%&quot; equ &quot;0&quot; 1&gt;nul ping -n 1 -w 500 127.255.255.255 2&gt;nul &amp; goto:finmessage
---
&gt; if &quot;%jpeg%&quot; equ &quot;0&quot; if &quot;%png%&quot; equ &quot;0&quot; 1&gt;nul timeout /t 1 /nobreak 2&gt;nul &amp; goto:finmessage
572c572
&lt;      1&gt;nul ping -n 1 -w 500 127.255.255.255 2&gt;nul
---
&gt;      1&gt;nul timeout /t 1 /nobreak 2&gt;nul</code></pre>
			<p>
				V2.5 diff:
			</p>
			<pre><code class="patch">319,320c319
&lt;      call:division float 1024 100
&lt;      call:echostd &quot; In    - !float! КБ&quot;
---
&gt;      call:echostd &quot; In    - !float! байт&quot;
322d320
&lt;      call:division change 1024 100
324,325c322
&lt;      call:division float 1024 100
&lt;      call:echostd &quot; Out   - !float! КБ (!change! КБ, %5%%%%%%)&quot;
---
&gt;      call:echostd &quot; Out   - !float! байт (!change! байт, %5%%%%%%)&quot;
362,363c359,360
&lt; set /a &quot;ww=%random%%%%1&quot;
&lt; 1&gt;nul 2&gt;&amp;1 ping -n 1 -w %ww% 127.255.255.255
---
&gt; set /a &quot;ww=%random%%%%1/1000&quot;
&gt; 1&gt;nul 2&gt;&amp;1 timeout /t %ww% /nobreak
707c704
&lt; if %jpeg% equ 0 if %png% equ 0 if %gif% equ 0 1&gt;nul 2&gt;&amp;1 ping -n 1 -w 500 127.255.255.255 &amp; goto:finmessage
---
&gt; if %jpeg% equ 0 if %png% equ 0 if %gif% equ 0 1&gt;nul 2&gt;&amp;1 timeout /t 1 /nobreak &amp; goto:finmessage
741d737
&lt; call:division changePNG 1024 100
747d742
&lt; call:division changeJPG 1024 100
753d747
&lt; call:division changeGIF 1024 100
800c794
&lt;      call:echostd &quot; Total %1:          %%change%1%% КБ, %%perc%1%%%%%%&quot;
---
&gt;      call:echostd &quot; Total %1:          %%change%1%% байт, %%perc%1%%%%%%&quot;</code></pre>
			<p>
				<font color="#54524F"><b>Note</b>:</font> батники Image Catalyst сохранены в кодировке (кодовой странице) CP866, поэтому эти diff, перед использованием, нужно сохранить в ней же.
			</p>
		</details>
		<p><a name="any-img-prep"></a>
			Подготовка любых изображений:
		</p>
		<ul>
			<li>778px – <em>максимальная ширина</em> (780px – максимальное разрешение по горизонтали − 2px запасных)
				<ul>
					<li>756px – при использовании изображения в спойлере первого уровня (758px – максимальное разрешение по горизонтали в спойлере − 2px запасных)</li>
					<li>738px – при использовании изображения в цитате первого уровня (740px – максимальное разрешение по горизонтали в цитате − 2px запасных)</li>
				</ul>
			</li>
			<li>Оптимизировать изображения в Image Catalyst v2.1 и v2.5, затем выбрать файлы наименьшего размера (используя “<a href="#merge_min-bat">merge_min.bat</a>”).</li>
			<li>При вставке изображений в пост – сохранить имена картинок: habrastorage превращает все имена в “dwbmwbyvlzes80cep1hvcdb5iy.png” (пример) и не возвращает оригинальное имя в HTTP‑заголовке “<code><a href="https://stackoverflow.com/a/7969807">Content-Disposition</a>: <a href="https://developer.mozilla.org/ru/docs/Web/HTTP/Заголовки/Content-Disposition">inline</a>;...</code>”, поэтому, чтобы сохранить оригинальное имя, можно использовать хеш (якорь): “dwbmwbyvlzes80cep1hvcdb5iy.png#real-name.png”. Все изображения будут загружаться так же, как и прежде – браузер не отправляет хеш на сервер (сервер не заметит разницы). Единственная проблема может возникнуть с SVG – для них хеш может указывать на символ (спрайт), либо на кадр в анимации, либо …</li>
			<li>Пометить изображения якорем (id, name). В качестве названия якоря использовать имя файла. (якоря на изображениях в спойлерах бесполезны – они не будут работать пока содержимое спойлера скрыто, но все же сделать якоря и для них, в частности – текст спойлера может иметь ссылку на изображение)</li>
			<li>Если ширина изображения оказалась все же больше <em>максимальной ширины</em>, то сделать изображение ссылкой на него же (чтобы при клике открылось не масштабированное изображение).</li>
			<li>Для всех изображений‑архивов (un[7z]me), после заливки на habrastorage – проверить, что с ними <a href="https://pwmon.org/p/5470/cloudflare-discolors-web/">сделал CloudFlare Polish</a>.</li>
		</ul>
		<p>
			<font color="#54524F"><b>Note</b>:</font> оказывается теперь habrastorage поддерживает SVG (раньше не поддерживал): <a href="https://habrahabr.ru/post/349362/#comment_10676658">пример</a> (<a href="https://hsto.org/getpro/habr/comment_images/027/ea2/357/027ea235753062811f9697dbd7a968a7.svg">картинка</a>), но я все равно оставил PNG{SVG} (в разных браузерах используется разный рендр SVG, даже в разных версиях одного браузера, и в разных режимах одной версии браузера – изображение может отличаться) (в растровом изображении максимум, что может исказится при рендере, кроме пропорций/размера – это гамма‑кривые / цветовой профиль, а в векторном к этому добавляется искажение геометрии)
		</p>
		<p>
			Текст и git:
		</p>
		<ul>
			<li>Пометить все ссылки на git tag значком git <img alt="" width="19" height="19" src="https://hsto.org/webt/z1/ho/tn/z1hotnqqi-dye8uvlxqhvqfjr6i.png#Git-Icon_2x.png"/> и добавить якорь “git-tag-‹версия›” к значку.</li>
			<li>Для каждой части создавать в git свою ветку, указывающую на последний коммит/тэг части, и давать названия “article_#”. (в основном это нужно для репозитория <a href="https://github.com/ZiroKyl/LLTR-Simulation-Model">LLTR Simulation Model</a>)</li>
			<li>Проверить (поиск по “http”), что все ссылки (в статье и в исходниках) есть в web.archive.org, и на sohabr.net:
				<pre><code class="javascript">var res=str.match(/http[^#)\s]*/gm);
var res_l=res.length;
for(var i=0;i&lt;res_l;i++) console.log(res[i]);
var archive = res.filter(function(a){return a.search(/(omnetpp.org\/doc\/omnetpp\/manual\/#|wikipedia|\/github.com\/)/)==-1;});</code></pre>
				<ul>
					<li>Перед публикацией опять проверить все ссылки, и неработающие заменить на web.archive.org или на sohabr.net .</li>
					<li>Не заменять ссылки на habrahabr.ru ссылками на habr.com, т.к. их нет в web.archive.org (либо они уже есть, но не получится посмотреть всю историю изменений целиком).</li>
				</ul>
			</li>
			<li>Проверить, что у всех ссылок на Wikipedia есть “?stable=1”.</li>
			<li>Заменить старые якоря (хеши) в ссылках MediaWiki (“#.D0.AD.D0.B2.D1.80.D0.B8.D1.81…”; поиск по “wikipedia”, и по “#.D0”) на новые (“#Эврис…”).</li>
			<li>Cделать бекап статьи (со всеми версиями и внешними ресурсами) + бекап Git.</li>
			<li>[начиная с “Части 2”] Для каждой ссылки на радел в другой части (“LLTR Часть #::”), добавить “title” (с названием части).</li>
			<li>Добавить к каждому заголовку якорь (id, name), и добавить перед заголовком значок (например, серый “#”) с ссылкой на этот якорь (дополнительно можно добавить title “Ссылка на раздел”).
				<ul>
					<li>sohabr.net заменяет `<code>id</code>` у заголовков (<a href="https://sohabr.net/habr/post/315186/">пример</a>), использовать `<code>&lt;a name=&quot;&quot;&gt;&lt;/a&gt;</code>`?</li>
					<li>Можно было добавить “Unicode Link Symbol” (U+1F517; “&amp;#128279;”) после заголовка, но не все браузеры его отобразят (Chrome отобразит, если в системе присутствует хотя бы один шрифт из заданного семейства, включающий этот символ), т.к. он будет отсутствовать в основном шрифте.</li>
				</ul>
			</li>
			<li>Начинать и заканчивать спойлер горизонтальными линиями (&lt;hr /&gt;) – для тех, кто не применил UserCSS (а в UserCSS убирать эти линии).</li>
			<li>Для абзацев использовать верстку `<code>&lt;p&gt;&lt;br /&gt;текст&lt;/p&gt;</code>`, чтобы в UserCSS можно было легко убрать `<code>&lt;br /&gt;</code>`, и установить `<code>margin</code>` для `<code>&lt;p&gt;</code>` (легко не получилось).
				<ul>
					<li><s>Похоже <a href="https://habrahabr.ru/info/topics/madskillz/#text">`<code>&lt;p&gt;</code>` будет использоваться</a>, только если включить Markdown…</s> (жалко, что `<code>&lt;p&gt;</code>` используется только в <a href="https://habrahabr.ru/info/topics/madskillz">info</a> разделе сайта, но не в основном его содержимом, я бы хотел изменить интервал между абзацами в UserCSS, очень хотел бы).</li>
				</ul>
			</li>
			<li>При вставке картинок указать height картинки (чтобы при загрузке страницы и картинок текст не прыгал верх‑вниз), если изображение обтекается текстом, то указать также и width.</li>
			<li>В смайликах использовать “<a href="http://xahlee.info/comp/unicode_matching_brackets">Full width brackets</a>” (чтобы можно было их быстро найти; хотел использовать декоративные скобки, но они слишком смещены по вертикали относительно двоеточия).</li>
			<li>Добавить к статье тег “какие еще добавить теги?”
				<ul>
					<li>Добавить названия хабов к тегам (на случай, если хабы удалят, связанность сохранится по тегам). Например, однажды мне нужно было найти (чтобы поделится ссылками) группу статей, они все были в корпоративном блоге одной компании. Компания, которая завела корпоративный блог – не стала продлять его. Все статьи сохранились, но потерялась связанность (мне пришлось долго искать нужные статьи). Если бы один из тегов был названием блога/компании, то связанность сохранилась бы. Хаб могут переименовать/объединить/удалить, а теги – вечны.</li>
					<li>Добавить тег “<a href="http://www.wikireality.ru/wiki/Хакерская_ценность" title="с Wikipedia был удален https://ru.wikipedia.org/wiki/Хакерская_ценность?action=edit">Хакерская ценность</a>”.</li>
				</ul>
			</li>
			<li>Прочесть <a href="https://habrahabr.ru/info/help/posts/">habrahabr.ru/info/help/posts/</a> (<a href="https://habr.com/info/help/posts/#allowed_tags">теги</a>, <a href="https://web.archive.org/web/20140429025144/http://habrahabr.ru/info/help/posts/">old теги</a>)
				<blockquote cite="https://habrahabr.ru/info/help/posts/">
					если ваша публикация является обучающей, уроком или how‑to – отметьте чекбокс «Обучающий материал» (tutorial), это поможет визуально выделить ее среди прочих;
				</blockquote>
			</li>
			<li>Прочесть <a href="https://habrahabr.ru/post/277577">памятку по базовой верстке статьи</a>.</li>
		</ul>
		<p>
			<font color="#54524F"><b>Note</b>:</font> habrahabr поддерживает тег <a href="https://habrahabr.ru/company/tm/blog/317490">&lt;oembed&gt;</a>, можно <a href="http://iframely.com/domains/github">вставлять исходники прямо с GitHub</a>, <a href="https://habrahabr.ru/company/Voximplant/blog/332792">пример использования</a>.
		</p>
		<p>
			<font color="#54524F"><b>Note</b>:</font> так TODO‑список выглядел только в самом начале, затем он разросся до 43 KiB (для “Части 0”), до 69 KiB (для “Части 1”), и до 45 KiB (для этой части).
		</p>
	</details>
</details>
<p>
	<a href="https://habr.com/post/421243/#comments" title="Вернуться на Хабр">Комментарии на Хабре →</a>
</p>
</body>
</html>
